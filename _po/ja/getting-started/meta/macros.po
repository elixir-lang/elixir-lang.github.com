msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Macros\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid "## Foreword"
msgstr ""

msgid ""
"Even though Elixir attempts its best to provide a safe environment for macros,"
" the major responsibility of writing clean code with macros falls on developer"
"s. Macros are harder to write than ordinary Elixir functions and it's consider"
"ed to be bad style to use them when they're not necessary. So write macros res"
"ponsibly."
msgstr ""

msgid ""
"Elixir already provides mechanisms to write your everyday code in a simple and"
" readable fashion by using its data structures and functions. Macros should on"
"ly be used as a last resort. Remember that **explicit is better than implicit*"
"*. **Clear code is better than concise code.**"
msgstr ""

msgid "## Our first macro"
msgstr ""

msgid "Macros in Elixir are defined via `defmacro/2`."
msgstr ""

msgid ""
"> For this chapter, we will be using files instead of running code samples in "
"IEx. That's because the code samples will span multiple lines of code and typi"
"ng them all in IEx can be counter-productive. You should be able to run the co"
"de samples by saving them into a `macros.exs` file and running it with `elixir"
" macros.exs` or `iex macros.exs`."
msgstr ""

msgid ""
"In order to better understand how macros work, let's create a new module where"
" we are going to implement `unless`, which does the opposite of `if`, as a mac"
"ro and as a function:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Unless do\n"
"  def fun_unless(clause, do: expression) do\n"
"    if(!clause, do: expression)\n"
"  end"
msgstr ""

msgid ""
"  defmacro macro_unless(clause, do: expression) do\n"
"    quote do\n"
"      if(!unquote(clause), do: unquote(expression))\n"
"    end\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"The function receives the arguments and passes them to `if`. However, as we le"
"arned in the [previous chapter](/getting-started/meta/quote-and-unquote.html),"
" the macro will receive quoted expressions, inject them into the quote, and fi"
"nally return another quoted expression."
msgstr ""

msgid "Let's start `iex` with the module above:"
msgstr ""

msgid ""
"```console\n"
"$ iex macros.exs\n"
"```"
msgstr ""

msgid "And play with those definitions:"
msgstr ""

msgid ""
"```iex\n"
"iex> require Unless\n"
"iex> Unless.macro_unless true, do: IO.puts \"this should never be printed\"\n"
"nil\n"
"iex> Unless.fun_unless true, do: IO.puts \"this should never be printed\"\n"
"\"this should never be printed\"\n"
"nil\n"
"```"
msgstr ""

msgid ""
"Note that in our macro implementation, the sentence was not printed, although "
"it was printed in our function implementation. That's because the arguments to"
" a function call are evaluated before calling the function. However, macros do"
" not evaluate their arguments. Instead, they receive the arguments as quoted e"
"xpressions which are then transformed into other quoted expressions. In this c"
"ase, we have rewritten our `unless` macro to become an `if` behind the scenes."
msgstr ""

msgid "In other words, when invoked as:"
msgstr ""

msgid ""
"```elixir\n"
"Unless.macro_unless true, do: IO.puts \"this should never be printed\"\n"
"```"
msgstr ""

msgid "Our `macro_unless` macro received the following:"
msgstr ""

msgid ""
"{% raw %}\n"
"```elixir\n"
"macro_unless(true, [do: {{:., [], [{:__aliases__, [alias: false], [:IO]}, :put"
"s]}, [], [\"this should never be printed\"]}])\n"
"```\n"
"{% endraw %}"
msgstr ""

msgid "And it then returned a quoted expression as follows:"
msgstr ""

msgid ""
"{% raw %}\n"
"```elixir\n"
"{:if, [],\n"
" [{:!, [], [true]},\n"
"  [do: {{:., [],\n"
"     [{:__aliases__,\n"
"       [], [:IO]},\n"
"      :puts]}, [], [\"this should never be printed\"]}]]}\n"
"```\n"
"{% endraw %}"
msgstr ""

msgid "We can actually verify that this is the case by using `Macro.expand_once/2`:"
msgstr ""

msgid ""
"```iex\n"
"iex> expr = quote do: Unless.macro_unless(true, do: IO.puts \"this should never"
" be printed\")\n"
"iex> res  = Macro.expand_once(expr, __ENV__)\n"
"iex> IO.puts Macro.to_string(res)\n"
"if(!true) do\n"
"  IO.puts(\"this should never be printed\")\n"
"end\n"
":ok\n"
"```"
msgstr ""

msgid ""
"`Macro.expand_once/2` receives a quoted expression and expands it according to"
" the current environment. In this case, it expanded/invoked the `Unless.macro_"
"unless/2` macro and returned its result. We then proceeded to convert the retu"
"rned quoted expression to a string and print it (we will talk about `__ENV__` "
"later in this chapter)."
msgstr ""

msgid ""
"That's what macros are all about. They are about receiving quoted expressions "
"and transforming them into something else. In fact, `unless/2` in Elixir is im"
"plemented as a macro:"
msgstr ""

msgid ""
"```elixir\n"
"defmacro unless(clause, do: expression) do\n"
"  quote do\n"
"    if(!unquote(clause), do: unquote(expression))\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"Constructs such as `unless/2`, `defmacro/2`, `def/2`, `defprotocol/2`, and man"
"y others used throughout this getting started guide are implemented in pure El"
"ixir, often as a macro. This means that the constructs being used to build the"
" language can be used by developers to extend the language to the domains they"
" are working on."
msgstr ""

msgid ""
"We can define any function and macro we want, including ones that override the"
" built-in definitions provided by Elixir. The only exceptions are Elixir speci"
"al forms which are not implemented in Elixir and therefore cannot be overridde"
"n, [the full list of special forms is available in `Kernel.SpecialForms`](http"
"s://hexdocs.pm/elixir/Kernel.SpecialForms.html#summary)."
msgstr ""

msgid "## Macros hygiene"
msgstr ""

msgid ""
"Elixir macros have late resolution. This guarantees that a variable defined in"
"side a quote won't conflict with a variable defined in the context where that "
"macro is expanded. For example:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Hygiene do\n"
"  defmacro no_interference do\n"
"    quote do: a = 1\n"
"  end\n"
"end"
msgstr ""

msgid ""
"defmodule HygieneTest do\n"
"  def go do\n"
"    require Hygiene\n"
"    a = 13\n"
"    Hygiene.no_interference\n"
"    a\n"
"  end\n"
"end"
msgstr ""

msgid ""
"HygieneTest.go\n"
"# => 13\n"
"```"
msgstr ""

msgid ""
"In the example above, even though the macro injects `a = 1`, it does not affec"
"t the variable `a` defined by the `go` function. If a macro wants to explicitl"
"y affect the context, it can use `var!`:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Hygiene do\n"
"  defmacro interference do\n"
"    quote do: var!(a) = 1\n"
"  end\n"
"end"
msgstr ""

msgid ""
"defmodule HygieneTest do\n"
"  def go do\n"
"    require Hygiene\n"
"    a = 13\n"
"    Hygiene.interference\n"
"    a\n"
"  end\n"
"end"
msgstr ""

msgid ""
"HygieneTest.go\n"
"# => 1\n"
"```"
msgstr ""

msgid ""
"Variable hygiene only works because Elixir annotates variables with their cont"
"ext. For example, a variable `x` defined on line 3 of a module would be repres"
"ented as:"
msgstr ""

msgid ""
"```elixir\n"
"{:x, [line: 3], nil}\n"
"```"
msgstr ""

msgid "However, a quoted variable is represented as:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Sample do\n"
"  def quoted do\n"
"    quote do: x\n"
"  end\n"
"end"
msgstr ""

msgid ""
"Sample.quoted #=> {:x, [line: 3], Sample}\n"
"```"
msgstr ""

msgid ""
"Notice that the third element in the quoted variable is the atom `Sample`, ins"
"tead of `nil`, which marks the variable as coming from the `Sample` module. Th"
"erefore, Elixir considers these two variables as coming from different context"
"s and handles them accordingly."
msgstr ""

msgid ""
"Elixir provides similar mechanisms for imports and aliases too. This guarantee"
"s that a macro will behave as specified by its source module rather than confl"
"icting with the target module where the macro is expanded. Hygiene can be bypa"
"ssed under specific situations by using macros like `var!/2` and `alias!/2`, a"
"lthough one must be careful when using those as they directly change the user "
"environment."
msgstr ""

msgid ""
"Sometimes variable names might be dynamically created. In such cases, `Macro.v"
"ar/2` can be used to define new variables:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Sample do\n"
"  defmacro initialize_to_char_count(variables) do\n"
"    Enum.map variables, fn(name) ->\n"
"      var = Macro.var(name, nil)\n"
"      length = name |> Atom.to_string |> String.length\n"
"      quote do\n"
"        unquote(var) = unquote(length)\n"
"      end\n"
"    end\n"
"  end"
msgstr ""

msgid ""
"  def run do\n"
"    initialize_to_char_count [:red, :green, :yellow]\n"
"    [red, green, yellow]\n"
"  end\n"
"end"
msgstr ""

msgid ""
"> Sample.run #=> [3, 5, 6]\n"
"```"
msgstr ""

msgid ""
"Take note of the second argument to `Macro.var/2`. This is the context being u"
"sed and will determine hygiene as described in the next section."
msgstr ""

msgid "## The environment"
msgstr ""

msgid ""
"When calling `Macro.expand_once/2` earlier in this chapter, we used the specia"
"l form `__ENV__`."
msgstr ""

msgid ""
"`__ENV__` returns an instance of the `Macro.Env` struct which contains useful "
"information about the compilation environment, including the current module, f"
"ile, and line, all variables defined in the current scope, as well as imports,"
" requires and so on:"
msgstr ""

msgid ""
"```iex\n"
"iex> __ENV__.module\n"
"nil\n"
"iex> __ENV__.file\n"
"\"iex\"\n"
"iex> __ENV__.requires\n"
"[IEx.Helpers, Kernel, Kernel.Typespec]\n"
"iex> require Integer\n"
"nil\n"
"iex> __ENV__.requires\n"
"[IEx.Helpers, Integer, Kernel, Kernel.Typespec]\n"
"```"
msgstr ""

msgid ""
"Many of the functions in the `Macro` module expect an environment. You can rea"
"d more about these functions in [the docs for the `Macro` module](https://hexd"
"ocs.pm/elixir/Macro.html) and learn more about the compilation environment in "
"the [docs for `Macro.Env`](https://hexdocs.pm/elixir/Macro.Env.html)."
msgstr ""

msgid "## Private macros"
msgstr ""

msgid ""
"Elixir also supports private macros via `defmacrop`. As private functions, the"
"se macros are only available inside the module that defines them, and only at "
"compilation time."
msgstr ""

msgid ""
"It is important that a macro is defined before its usage. Failing to define a "
"macro before its invocation will raise an error at runtime, since the macro wo"
"n't be expanded and will be translated to a function call:"
msgstr ""

msgid ""
"```iex\n"
"iex> defmodule Sample do\n"
"...>  def four, do: two + two\n"
"...>  defmacrop two, do: 2\n"
"...> end\n"
"** (CompileError) iex:2: function two/0 undefined\n"
"```"
msgstr ""

msgid "## Write macros responsibly"
msgstr ""

msgid ""
"Macros are a powerful construct and Elixir provides many mechanisms to ensure "
"they are used responsibly."
msgstr ""

msgid ""
"* Macros are hygienic: by default, variables defined inside a macro are not go"
"ing to affect the user code. Furthermore, function calls and aliases available"
" in the macro context are not going to leak into the user context."
msgstr ""

msgid ""
"* Macros are lexical: it is impossible to inject code or macros globally. In o"
"rder to use a macro, you need to explicitly `require` or `import` the module t"
"hat defines the macro."
msgstr ""

msgid ""
"* Macros are explicit: it is impossible to run a macro without explicitly invo"
"king it. For example, some languages allow developers to completely rewrite fu"
"nctions behind the scenes, often via parse transforms or via some reflection m"
"echanisms. In Elixir, a macro must be explicitly invoked in the caller during "
"compilation time."
msgstr ""

msgid ""
"* Macros' language is clear: many languages provide syntax shortcuts for `quot"
"e` and `unquote`. In Elixir, we preferred to have them explicitly spelled out,"
" in order to clearly delimit the boundaries of a macro definition and its quot"
"ed expressions."
msgstr ""

msgid ""
"Even with such guarantees, the developer plays a big role when writing macros "
"responsibly. If you are confident you need to resort to macros, remember that "
"macros are not your API. Keep your macro definitions short, including their qu"
"oted contents. For example, instead of writing a macro like this:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule MyModule do\n"
"  defmacro my_macro(a, b, c) do\n"
"    quote do\n"
"      do_this(unquote(a))\n"
"      ...\n"
"      do_that(unquote(b))\n"
"      ...\n"
"      and_that(unquote(c))\n"
"    end\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid "write:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule MyModule do\n"
"  defmacro my_macro(a, b, c) do\n"
"    quote do\n"
"      # Keep what you need to do here to a minimum\n"
"      # and move everything else to a function\n"
"      MyModule.do_this_that_and_that(unquote(a), unquote(b), unquote(c))\n"
"    end\n"
"  end"
msgstr ""

msgid ""
"  def do_this_that_and_that(a, b, c) do\n"
"    do_this(a)\n"
"    ...\n"
"    do_that(b)\n"
"    ...\n"
"    and_that(c)\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"This makes your code clearer and easier to test and maintain, as you can invok"
"e and test `do_this_that_and_that/3` directly. It also helps you design an act"
"ual API for developers that do not want to rely on macros."
msgstr ""

msgid ""
"With those lessons, we finish our introduction to macros. The next chapter is "
"a brief discussion on DSLs that shows how we can mix macros and module attribu"
"tes to annotate and extend modules and functions."
msgstr ""
