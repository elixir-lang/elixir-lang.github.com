msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Domain-specific languages\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid "## Foreword"
msgstr ""

msgid ""
"[Domain-specific languages (DSL)](https://en.wikipedia.org/wiki/Domain-specifi"
"c_language) allow developers to tailor their application to a particular domai"
"n. You don't need macros in order to have a DSL: every data structure and ever"
"y function you define in your module is part of your Domain-specific language."
msgstr ""

msgid ""
"For example, imagine we want to implement a Validator module which provides a "
"data validation domain-specific language. We could implement it using data str"
"uctures, functions or macros. Let's see what those different DSLs would look l"
"ike:"
msgstr ""

msgid ""
"```elixir\n"
"# 1. data structures\n"
"import Validator\n"
"validate user, name: [length: 1..100],\n"
"               email: [matches: ~r/@/]"
msgstr ""

msgid ""
"# 2. functions\n"
"import Validator\n"
"user\n"
"|> validate_length(:name, 1..100)\n"
"|> validate_matches(:email, ~r/@/)"
msgstr ""

msgid ""
"# 3. macros + modules\n"
"defmodule MyValidator do\n"
"  use Validator\n"
"  validate_length :name, 1..100\n"
"  validate_matches :email, ~r/@/\n"
"end"
msgstr ""

msgid ""
"MyValidator.validate(user)\n"
"```"
msgstr ""

msgid ""
"Of all the approaches above, the first is definitely the most flexible. If our"
" domain rules can be encoded with data structures, they are by far the easiest"
" to compose and implement, as Elixir's standard library is filled with functio"
"ns for manipulating different data types."
msgstr ""

msgid ""
"The second approach uses function calls which better suits more complex APIs ("
"for example, if you need to pass many options) and reads nicely in Elixir than"
"ks to the pipe operator."
msgstr ""

msgid ""
"The third approach uses macros, and is by far the most complex. It will take m"
"ore lines of code to implement, it is hard and expensive to test (compared to "
"testing simple functions), and it limits how the user may use the library sinc"
"e all validations need to be defined inside a module."
msgstr ""

msgid ""
"To drive the point home, imagine you want to validate a certain attribute only"
" if a given condition is met. We could easily achieve it with the first soluti"
"on, by manipulating the data structure accordingly, or with the second solutio"
"n by using conditionals (if/else) before invoking the function. However, it is"
" impossible to do so with the macros approach unless its DSL is augmented."
msgstr ""

msgid "In other words:"
msgstr ""

msgid "    data > functions > macros"
msgstr ""

msgid ""
"That said, there are still cases where using macros and modules to build domai"
"n-specific languages is useful. Since we have explored data structures and fun"
"ction definitions in the Getting Started guide, this chapter will explore how "
"to use macros and module attributes to tackle more complex DSLs."
msgstr ""

msgid "## Building our own test case"
msgstr ""

msgid ""
"The goal in this chapter is to build a module named `TestCase` that allows us "
"to write the following:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule MyTest do\n"
"  use TestCase"
msgstr ""

msgid ""
"  test \"arithmetic operations\" do\n"
"    4 = 2 + 2\n"
"  end"
msgstr ""

msgid ""
"  test \"list operations\" do\n"
"    [1, 2, 3] = [1, 2] ++ [3]\n"
"  end\n"
"end"
msgstr ""

msgid ""
"MyTest.run\n"
"```"
msgstr ""

msgid ""
"In the example above, by using `TestCase`, we can write tests using the `test`"
" macro, which defines a function named `run` to automatically run all tests fo"
"r us. Our prototype will rely on the match operator (`=`) as a mechanism to do"
" assertions."
msgstr ""

msgid "## The `test` macro"
msgstr ""

msgid ""
"Let's start by creating a module that defines and imports the `test` macro whe"
"n used:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule TestCase do\n"
"  # Callback invoked by `use`.\n"
"  #\n"
"  # For now it returns a quoted expression that\n"
"  # imports the module itself into the user code.\n"
"  @doc false\n"
"  defmacro __using__(_opts) do\n"
"    quote do\n"
"      import TestCase\n"
"    end\n"
"  end"
msgstr ""

msgid ""
"  @doc \"\"\"\n"
"  Defines a test case with the given description."
msgstr ""

msgid "  ## Examples"
msgstr ""

msgid ""
"      test \"arithmetic operations\" do\n"
"        4 = 2 + 2\n"
"      end"
msgstr ""

msgid ""
"  \"\"\"\n"
"  defmacro test(description, do: block) do\n"
"    function_name = String.to_atom(\"test \" <> description)\n"
"    quote do\n"
"      def unquote(function_name)(), do: unquote(block)\n"
"    end\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"Assuming we defined `TestCase` in a file named `tests.exs`, we can open it up "
"by running `iex tests.exs` and define our first tests:"
msgstr ""

msgid ""
"```iex\n"
"iex> defmodule MyTest do\n"
"...>   use TestCase\n"
"...>\n"
"...>   test \"hello\" do\n"
"...>     \"hello\" = \"world\"\n"
"...>   end\n"
"...> end\n"
"```"
msgstr ""

msgid ""
"For now, we don't have a mechanism to run tests, but we know that a function n"
"amed \"test hello\" was defined behind the scenes. When we invoke it, it should "
"fail:"
msgstr ""

msgid ""
"```iex\n"
"iex> MyTest.\"test hello\"()\n"
"** (MatchError) no match of right hand side value: \"world\"\n"
"```"
msgstr ""

msgid "## Storing information with attributes"
msgstr ""

msgid ""
"In order to finish our `TestCase` implementation, we need to be able to access"
" all defined test cases. One way of doing this is by retrieving the tests at r"
"untime via `__MODULE__.__info__(:functions)`, which returns a list of all func"
"tions in a given module. However, considering that we may want to store more i"
"nformation about each test besides the test name, a more flexible approach is "
"required."
msgstr ""

msgid ""
"When discussing module attributes in earlier chapters, we mentioned how they c"
"an be used as temporary storage. That's exactly the property we will apply in "
"this section."
msgstr ""

msgid ""
"In the `__using__/1` implementation, we will initialize a module attribute nam"
"ed `@tests` to an empty list, then store the name of each defined test in this"
" attribute so the tests can be invoked from the `run` function."
msgstr ""

msgid "Here is the updated code for the `TestCase` module:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule TestCase do\n"
"  @doc false\n"
"  defmacro __using__(_opts) do\n"
"    quote do\n"
"      import TestCase"
msgstr ""

msgid ""
"      # Initialize @tests to an empty list\n"
"      @tests []"
msgstr ""

msgid ""
"      # Invoke TestCase.__before_compile__/1 before the module is compiled\n"
"      @before_compile TestCase\n"
"    end\n"
"  end"
msgstr ""

msgid ""
"  \"\"\"\n"
"  defmacro test(description, do: block) do\n"
"    function_name = String.to_atom(\"test \" <> description)\n"
"    quote do\n"
"      # Prepend the newly defined test to the list of tests\n"
"      @tests [unquote(function_name) | @tests]\n"
"      def unquote(function_name)(), do: unquote(block)\n"
"    end\n"
"  end"
msgstr ""

msgid ""
"  # This will be invoked right before the target module is compiled\n"
"  # giving us the perfect opportunity to inject the `run/0` function\n"
"  @doc false\n"
"  defmacro __before_compile__(_env) do\n"
"    quote do\n"
"      def run do\n"
"        Enum.each @tests, fn name ->\n"
"          IO.puts \"Running #{name}\"\n"
"          apply(__MODULE__, name, [])\n"
"        end\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid "By starting a new IEx session, we can now define our tests and run them:"
msgstr ""

msgid ""
"```iex\n"
"iex> defmodule MyTest do\n"
"...>   use TestCase\n"
"...>\n"
"...>   test \"hello\" do\n"
"...>     \"hello\" = \"world\"\n"
"...>   end\n"
"...> end\n"
"iex> MyTest.run\n"
"Running test hello\n"
"** (MatchError) no match of right hand side value: \"world\"\n"
"```"
msgstr ""

msgid ""
"Although we have overlooked some details, this is the main idea behind creatin"
"g domain-specific modules in Elixir. Macros enable us to return quoted express"
"ions that are executed in the caller, which we can then use to transform code "
"and store relevant information in the target module via module attributes. Fin"
"ally, callbacks such as `@before_compile` allow us to inject code into the mod"
"ule when its definition is complete."
msgstr ""

msgid ""
"Besides `@before_compile`, there are other useful module attributes like `@on_"
"definition` and `@after_compile`, which you can read more about in [the docs f"
"or the `Module` module](https://hexdocs.pm/elixir/Module.html). You can also f"
"ind useful information about macros and the compilation environment in the doc"
"umentation for the [`Macro` module](https://hexdocs.pm/elixir/Macro.html) and "
"[`Macro.Env`](https://hexdocs.pm/elixir/Macro.Env.html)."
msgstr ""
