msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Agent\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid "{% include mix-otp-preface.html %}"
msgstr ""

msgid ""
"In this chapter, we will create a module named `KV.Bucket`. This module will b"
"e responsible for storing our key-value entries in a way that allows them to b"
"e read and modified by other processes."
msgstr ""

msgid ""
"If you have skipped the Getting Started guide or read it long ago, be sure to "
"re-read the [Processes](/getting-started/processes.html) chapter. We will use "
"it as a starting point."
msgstr ""

msgid "## The trouble with state"
msgstr ""

msgid ""
"Elixir is an immutable language where nothing is shared by default. If we want"
" to provide buckets, which can be read and modified from multiple places, we h"
"ave two main options in Elixir:"
msgstr ""

msgid ""
"* Processes\n"
"* [ETS (Erlang Term Storage)](http://www.erlang.org/doc/man/ets.html)"
msgstr ""

msgid ""
"We covered processes in the Getting Started guide. <abbr title=\"Erlang Term St"
"orage\">ETS</abbr> is a new topic that will explore on later chapters. When it "
"comes to processes though, we rarely hand-roll our own, instead we use the abs"
"tractions available in Elixir and  <abbr title=\"Open Telecom Platform\">OTP</ab"
"br>:"
msgstr ""

msgid ""
"* [Agent](https://hexdocs.pm/elixir/Agent.html) - Simple wrappers around state"
".\n"
"* [GenServer](https://hexdocs.pm/elixir/GenServer.html) - \"Generic servers\" (p"
"rocesses) that encapsulate state, provide sync and async calls, support code r"
"eloading, and more.\n"
"* [Task](https://hexdocs.pm/elixir/Task.html) - Asynchronous units of computat"
"ion that allow spawning a process and potentially retrieving its result at a l"
"ater time."
msgstr ""

msgid ""
"We will explore most of these abstractions in this guide. Keep in mind that th"
"ey are all implemented on top of processes using the basic features provided b"
"y the <abbr title=\"Virtual Machine\">VM</abbr>, like `send`, `receive`, `spawn`"
" and `link`."
msgstr ""

msgid "## Agents"
msgstr ""

msgid ""
"[Agents](https://hexdocs.pm/elixir/Agent.html) are simple wrappers around stat"
"e. If all you want from a process is to keep state, agents are a great fit. Le"
"t's start an `iex` session inside the project with:"
msgstr ""

msgid ""
"```bash\n"
"$ iex -S mix\n"
"```"
msgstr ""

msgid "And play a bit with agents:"
msgstr ""

msgid ""
"```iex\n"
"iex> {:ok, agent} = Agent.start_link fn -> [] end\n"
"{:ok, #PID<0.57.0>}\n"
"iex> Agent.update(agent, fn list -> [\"eggs\" | list] end)\n"
":ok\n"
"iex> Agent.get(agent, fn list -> list end)\n"
"[\"eggs\"]\n"
"iex> Agent.stop(agent)\n"
":ok\n"
"```"
msgstr ""

msgid ""
"We started an agent with an initial state of an empty list. We updated the age"
"nt's state, adding our new item to the head of the list. The second argument o"
"f [`Agent.update/3`](https://hexdocs.pm/elixir/Agent.html#update/3) is a funct"
"ion that takes the agent's current state as input and returns its desired new "
"state. Finally, we retrieved the whole list. The second argument of [`Agent.ge"
"t/3`](https://hexdocs.pm/elixir/Agent.html#get/3) is a function that takes the"
" state as input and returns the value that [`Agent.get/3`](https://hexdocs.pm/"
"elixir/Agent.html#get/3) itself will return. Once we are done with the agent, "
"we can call [`Agent.stop/3`](https://hexdocs.pm/elixir/Agent.html#stop/3) to t"
"erminate the agent process."
msgstr ""

msgid ""
"Let's implement our `KV.Bucket` using agents. But before starting the implemen"
"tation, let's first write some tests. Create a file at `test/kv/bucket_test.ex"
"s` (remember the `.exs` extension) with the following:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule KV.BucketTest do\n"
"  use ExUnit.Case, async: true"
msgstr ""

msgid ""
"  test \"stores values by key\" do\n"
"    {:ok, bucket} = start_supervised KV.Bucket\n"
"    assert KV.Bucket.get(bucket, \"milk\") == nil"
msgstr ""

msgid ""
"    KV.Bucket.put(bucket, \"milk\", 3)\n"
"    assert KV.Bucket.get(bucket, \"milk\") == 3\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"Our first test starts a new `KV.Bucket` using the `start_supervised` function "
"and performs some `get/2` and `put/3` operations on it, asserting the result. "
"We don't need to explicitly stop the agent because we used `start_supervised/2"
"` and that takes care of automatically terminating the processes under test wh"
"en the test finishes."
msgstr ""

msgid ""
"Also note the `async: true` option passed to `ExUnit.Case`. This option makes "
"the test case run in parallel with other `:async` test cases by using multiple"
" cores in our machine. This is extremely useful to speed up our test suite. Ho"
"wever, `:async` must *only* be set if the test case does not rely on or change"
" any global values. For example, if the test requires writing to the filesyste"
"m or access a database, keep it synchronous (omit the `:async` option) to avoi"
"d race conditions between tests."
msgstr ""

msgid ""
"Async or not, our new test should obviously fail, as none of the functionality"
" is implemented in the module being tested:"
msgstr ""

msgid ""
"```\n"
"** (ArgumentError) The module KV.Bucket was given as a child to a supervisor b"
"ut it does not implement child_spec/1\n"
"```"
msgstr ""

msgid ""
"Since the module has not yet been defined, the `child_spec/1` does not yet exi"
"st."
msgstr ""

msgid ""
"In order to fix the failing test, let's create a file at `lib/kv/bucket.ex` wi"
"th the contents below. Feel free to give a try at implementing the `KV.Bucket`"
" module yourself using agents before peeking at the implementation below."
msgstr ""

msgid ""
"```elixir\n"
"defmodule KV.Bucket do\n"
"  use Agent"
msgstr ""

msgid ""
"  @doc \"\"\"\n"
"  Starts a new bucket.\n"
"  \"\"\"\n"
"  def start_link(_opts) do\n"
"    Agent.start_link(fn -> %{} end)\n"
"  end"
msgstr ""

msgid ""
"  @doc \"\"\"\n"
"  Gets a value from the `bucket` by `key`.\n"
"  \"\"\"\n"
"  def get(bucket, key) do\n"
"    Agent.get(bucket, &Map.get(&1, key))\n"
"  end"
msgstr ""

msgid ""
"  @doc \"\"\"\n"
"  Puts the `value` for the given `key` in the `bucket`.\n"
"  \"\"\"\n"
"  def put(bucket, key, value) do\n"
"    Agent.update(bucket, &Map.put(&1, key, value))\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"The first step in our implementation is to call `use Agent`. By doing so, it w"
"ill define a `child_spec/1` function containing the exact steps to start our p"
"rocess."
msgstr ""

msgid ""
"Then we define a `start_link/1` function, which will effectively start the age"
"nt. The `start_link/1` function always receives a list of options, but we don'"
"t plan on using it right now. We then proceed to call `Agent.start_link/1`, wh"
"ich receives an anonymous function that returns the Agent initial state."
msgstr ""

msgid ""
"We are keeping a map inside the agent to store our keys and values. Getting an"
"d putting values on the map is done with the Agent API  and the capture operat"
"or `&`, introduced in [the Getting Started guide](/getting-started/modules-and"
"-functions.html#function-capturing)."
msgstr ""

msgid ""
"Now that the `KV.Bucket` module has been defined, our test should pass! You ca"
"n try it yourself by running: `mix test`."
msgstr ""

msgid "## Test setup with ExUnit callbacks"
msgstr ""

msgid ""
"Before moving on and adding more features to `KV.Bucket`, let's talk about ExU"
"nit callbacks. As you may expect, all `KV.Bucket` tests will require a bucket "
"agent to be up and running. Luckily, ExUnit supports callbacks that allow us t"
"o skip such repetitive tasks."
msgstr ""

msgid "Let's rewrite the test case to use callbacks:"
msgstr ""

msgid ""
"  setup do\n"
"    {:ok, bucket} = start_supervised(KV.Bucket)\n"
"    %{bucket: bucket}\n"
"  end"
msgstr ""

msgid ""
"  test \"stores values by key\", %{bucket: bucket} do\n"
"    assert KV.Bucket.get(bucket, \"milk\") == nil"
msgstr ""

msgid ""
"We have first defined a setup callback with the help of the `setup/1` macro. T"
"he `setup/1` callback runs before every test, in the same process as the test "
"itself."
msgstr ""

msgid ""
"Note that we need a mechanism to pass the `bucket` pid from the callback to th"
"e test. We do so by using the *test context*. When we return `%{bucket: bucket"
"}` from the callback, ExUnit will merge this map into the test context. Since "
"the test context is a map itself, we can pattern match the bucket out of it, p"
"roviding access to the bucket inside the test:"
msgstr ""

msgid ""
"```elixir\n"
"test \"stores values by key\", %{bucket: bucket} do\n"
"  # `bucket` is now the bucket from the setup block\n"
"end\n"
"```"
msgstr ""

msgid ""
"You can read more about ExUnit cases in the [`ExUnit.Case` module documentatio"
"n](https://hexdocs.pm/ex_unit/ExUnit.Case.html) and more about callbacks in [`"
"ExUnit.Callbacks` docs](https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html)."
msgstr ""

msgid "## Other agent actions"
msgstr ""

msgid ""
"Besides getting a value and updating the agent state, agents allow us to get a"
" value and update the agent state in one function call via `Agent.get_and_upda"
"te/2`. Let's implement a `KV.Bucket.delete/2` function that deletes a key from"
" the bucket, returning its current value:"
msgstr ""

msgid ""
"```elixir\n"
"@doc \"\"\"\n"
"Deletes `key` from `bucket`."
msgstr ""

msgid ""
"Returns the current value of `key`, if `key` exists.\n"
"\"\"\"\n"
"def delete(bucket, key) do\n"
"  Agent.get_and_update(bucket, &Map.pop(&1, key))\n"
"end\n"
"```"
msgstr ""

msgid ""
"Now it is your turn to write a test for the functionality above! Also, be sure"
" to explore [the documentation for the `Agent` module](https://hexdocs.pm/elix"
"ir/Agent.html) to learn more about them."
msgstr ""

msgid "## Client/Server in agents"
msgstr ""

msgid ""
"Before we move on to the next chapter, let's discuss the client/server dichoto"
"my in agents. Let's expand the `delete/2` function we have just implemented:"
msgstr ""

msgid ""
"```elixir\n"
"def delete(bucket, key) do\n"
"  Agent.get_and_update(bucket, fn dict ->\n"
"    Map.pop(dict, key)\n"
"  end)\n"
"end\n"
"```"
msgstr ""

msgid ""
"Everything that is inside the function we passed to the agent happens in the a"
"gent process. In this case, since the agent process is the one receiving and r"
"esponding to our messages, we say the agent process is the server. Everything "
"outside the function is happening in the client."
msgstr ""

msgid ""
"This distinction is important. If there are expensive actions to be done, you "
"must consider if it will be better to perform these actions on the client or o"
"n the server. For example:"
msgstr ""

msgid ""
"```elixir\n"
"def delete(bucket, key) do\n"
"  Process.sleep(1000) # puts client to sleep\n"
"  Agent.get_and_update(bucket, fn dict ->\n"
"    Process.sleep(1000) # puts server to sleep\n"
"    Map.pop(dict, key)\n"
"  end)\n"
"end\n"
"```"
msgstr ""

msgid ""
"When a long action is performed on the server, all other requests to that part"
"icular server will wait until the action is done, which may cause some clients"
" to timeout."
msgstr ""

msgid ""
"In the next chapter we will explore GenServers, where the segregation between "
"clients and servers is made more apparent."
msgstr ""
