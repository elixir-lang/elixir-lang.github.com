msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: GenServer\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid "{% include mix-otp-preface.html %}"
msgstr ""

msgid ""
"In the [previous chapter](/getting-started/mix-otp/agent.html), we used agents"
" to represent our buckets. In the first chapter, we specified we would like to"
" name each bucket so we can do the following:"
msgstr ""

msgid ""
"```elixir\n"
"CREATE shopping\n"
"OK"
msgstr ""

msgid ""
"PUT shopping milk 1\n"
"OK"
msgstr ""

msgid ""
"GET shopping milk\n"
"1\n"
"OK\n"
"```"
msgstr ""

msgid "In the session above we interacted with the \"shopping\" bucket."
msgstr ""

msgid ""
"Since agents are processes, each bucket has a process identifier (pid), but bu"
"ckets do not have a name. Back [in the Process chapter](/getting-started/proce"
"sses.html), we have learned that we can register processes in Elixir by giving"
" them atom names:"
msgstr ""

msgid ""
"```iex\n"
"iex> Agent.start_link(fn -> %{} end, name: :shopping)\n"
"{:ok, #PID<0.43.0>}\n"
"iex> KV.Bucket.put(:shopping, \"milk\", 1)\n"
":ok\n"
"iex> KV.Bucket.get(:shopping, \"milk\")\n"
"1\n"
"```"
msgstr ""

msgid ""
"However, naming dynamic processes with atoms is a terrible idea! If we use ato"
"ms, we would need to convert the bucket name (often received from an external "
"client) to atoms, and **we should never convert user input to atoms**. This is"
" because atoms are not garbage collected. Once an atom is created, it is never"
" reclaimed. Generating atoms from user input would mean the user can inject en"
"ough different names to exhaust our system memory!"
msgstr ""

msgid ""
"In practice, it is more likely you will reach the Erlang <abbr title=\"Virtual "
"Machine\">VM</abbr> limit for the maximum number of atoms before you run out of"
" memory, which will bring your system down regardless."
msgstr ""

msgid ""
"Instead of abusing the built-in name facility, we will create our own *process"
" registry* that associates the bucket name to the bucket process."
msgstr ""

msgid ""
"The registry needs to guarantee that it is always up to date. For example, if "
"one of the bucket processes crashes due to a bug, the registry must notice thi"
"s change and avoid serving stale entries. In Elixir, we say the registry needs"
" to *monitor* each bucket."
msgstr ""

msgid ""
"We will use a [GenServer](https://hexdocs.pm/elixir/GenServer.html) to create "
"a registry process that can monitor the bucket processes. GenServer provides i"
"ndustrial strength functionality for building servers in both Elixir and  <abb"
"r title=\"Open Telecom Platform\">OTP</abbr>."
msgstr ""

msgid "## Our first GenServer"
msgstr ""

msgid ""
"A GenServer is implemented in two parts: the client API and the server callbac"
"ks. You can either combine both parts into a single module or you can separate"
" them into a client module and a server module. The client and server run in s"
"eparate processes, with the client passing messages back and forth to the serv"
"er as its functions are called. Here we'll use a single module for both the se"
"rver callbacks and the client API."
msgstr ""

msgid "Create a new file at `lib/kv/registry.ex` with the following contents:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule KV.Registry do\n"
"  use GenServer"
msgstr ""

msgid "  ## Client API"
msgstr ""

msgid ""
"  @doc \"\"\"\n"
"  Starts the registry.\n"
"  \"\"\"\n"
"  def start_link(opts) do\n"
"    GenServer.start_link(__MODULE__, :ok, opts)\n"
"  end"
msgstr ""

msgid ""
"  @doc \"\"\"\n"
"  Looks up the bucket pid for `name` stored in `server`."
msgstr ""

msgid ""
"  Returns `{:ok, pid}` if the bucket exists, `:error` otherwise.\n"
"  \"\"\"\n"
"  def lookup(server, name) do\n"
"    GenServer.call(server, {:lookup, name})\n"
"  end"
msgstr ""

msgid ""
"  @doc \"\"\"\n"
"  Ensures there is a bucket associated with the given `name` in `server`.\n"
"  \"\"\"\n"
"  def create(server, name) do\n"
"    GenServer.cast(server, {:create, name})\n"
"  end"
msgstr ""

msgid "  ## Server Callbacks"
msgstr ""

msgid ""
"  def init(:ok) do\n"
"    {:ok, %{}}\n"
"  end"
msgstr ""

msgid ""
"  def handle_call({:lookup, name}, _from, names) do\n"
"    {:reply, Map.fetch(names, name), names}\n"
"  end"
msgstr ""

msgid ""
"  def handle_cast({:create, name}, names) do\n"
"    if Map.has_key?(names, name) do\n"
"      {:noreply, names}\n"
"    else\n"
"      {:ok, bucket} = KV.Bucket.start_link([])\n"
"      {:noreply, Map.put(names, name, bucket)}\n"
"    end\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"The first function is `start_link/1`, which starts a new GenServer passing thr"
"ee arguments:"
msgstr ""

msgid ""
"1. The module where the server callbacks are implemented, in this case `__MODU"
"LE__`, meaning the current module"
msgstr ""

msgid "2. The initialization arguments, in this case, the atom `:ok`"
msgstr ""

msgid ""
"3. A list of options which can be used to specify things like the name of the "
"server. For now, we forward the list of options that we receive on `start_link"
"/1`, which defaults to an empty list. We will customize it later on"
msgstr ""

msgid ""
"There are two types of requests you can send to a GenServer: calls and casts. "
"Calls are synchronous and the server **must** send a response back to such req"
"uests. Casts are asynchronous and the server won't send a response back."
msgstr ""

msgid ""
"The next two functions, `lookup/2` and `create/2` are responsible for sending "
"these requests to the server.  In this case, we have used `{:lookup, name}` an"
"d `{:create, name}` respectively.  Requests are often specified as tuples, lik"
"e this, in order to provide more than one \"argument\" in that first argument sl"
"ot. It's common to specify the action being requested as the first element of "
"a tuple, and arguments for that action in the remaining elements. Note that th"
"e requests must match the first argument to `handle_call/3` or `handle_cast/2`"
"."
msgstr ""

msgid ""
"That's it for the client API. On the server side, we can implement a variety o"
"f callbacks to guarantee the server initialization, termination, and handling "
"of requests. Those callbacks are optional and for now, we have only implemente"
"d the ones we care about."
msgstr ""

msgid ""
"The first is the `init/1` callback, that receives the second argument given to"
" `GenServer.start_link/3` and returns `{:ok, state}`, where state is a new map"
". We can already notice how the `GenServer` API makes the client/server segreg"
"ation more apparent. `start_link/3` happens in the client, while `init/1` is t"
"he respective callback that runs on the server."
msgstr ""

msgid ""
"For `call/2` requests, we  implement a `handle_call/3` callback that receives "
"the `request`, the process from which we received the request (`_from`), and t"
"he current server state (`names`). The `handle_call/3` callback returns a tupl"
"e in the format `{:reply, reply, new_state}`. The first element of the tuple, "
"`:reply`,  indicates that server should send a reply back to the client. The s"
"econd element, `reply`, is what will be sent to the client while the third, `n"
"ew_state` is the new server state."
msgstr ""

msgid ""
"For `cast/2` requests, we implement a `handle_cast/2` callback that receives t"
"he `request` and the current server state (`names`). The `handle_cast/2` callb"
"ack returns a tuple in the format `{:noreply, new_state}`. Note that in a real"
" application we would have probably implemented the callback for `:create` wit"
"h a synchronous call instead of an asynchronous cast. We are doing it this way"
" to illustrate how to implement a cast callback."
msgstr ""

msgid ""
"There are other tuple formats both `handle_call/3` and `handle_cast/2` callbac"
"ks may return. There are also other callbacks like `terminate/2` and `code_cha"
"nge/3` that we could implement. You are welcome to explore the [full GenServer"
" documentation](https://hexdocs.pm/elixir/GenServer.html) to learn more about "
"those."
msgstr ""

msgid "For now, let's write some tests to guarantee our GenServer works as expected."
msgstr ""

msgid "## Testing a GenServer"
msgstr ""

msgid ""
"Testing a GenServer is not much different from testing an agent. We will spawn"
" the server on a setup callback and use it throughout our tests. Create a file"
" at `test/kv/registry_test.exs` with the following:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule KV.RegistryTest do\n"
"  use ExUnit.Case, async: true"
msgstr ""

msgid ""
"  setup do\n"
"    registry = start_supervised!(KV.Registry)\n"
"    %{registry: registry}\n"
"  end"
msgstr ""

msgid ""
"  test \"spawns buckets\", %{registry: registry} do\n"
"    assert KV.Registry.lookup(registry, \"shopping\") == :error"
msgstr ""

msgid ""
"    KV.Registry.create(registry, \"shopping\")\n"
"    assert {:ok, bucket} = KV.Registry.lookup(registry, \"shopping\")"
msgstr ""

msgid ""
"    KV.Bucket.put(bucket, \"milk\", 1)\n"
"    assert KV.Bucket.get(bucket, \"milk\") == 1\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid "Our test should pass right out of the box!"
msgstr ""

msgid ""
"There is one important difference between the `setup` block we wrote for `KV.R"
"egistry` and the one we wrote for `KV.Bucket`. Instead of starting the registr"
"y by hand by calling `KV.Registry.start_link/1`, we instead called [the `start"
"_supervised!/1` function](https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#sta"
"rt_supervised/2), passing the `KV.Registry` module."
msgstr ""

msgid ""
"The `start_supervised!` function will do the job of starting the `KV.Registry`"
" process by calling `start_link/1`. The advantage of using `start_supervised!`"
" is that ExUnit will guarantee that the registry process will be shutdown befo"
"re the next test starts. In other words, it helps guarantee the state of one t"
"est is not going to interfere with the next one in case they depend on shared "
"resources."
msgstr ""

msgid ""
"When starting processes during your tests, we should always prefer to use `sta"
"rt_supervised!`. We recommend you to change the previous setup block in `bucke"
"t_test.exs` to use `start_supervised!` too."
msgstr ""

msgid ""
"If there is a need to stop a `GenServer` as part of the application logic, one"
" can use the `GenServer.stop/1` function:"
msgstr ""

msgid ""
"```elixir\n"
"## Client API"
msgstr ""

msgid ""
"@doc \"\"\"\n"
"Stops the registry.\n"
"\"\"\"\n"
"def stop(server) do\n"
"  GenServer.stop(server)\n"
"end\n"
"```"
msgstr ""

msgid "## The need for monitoring"
msgstr ""

msgid ""
"Our registry is almost complete. The only remaining issue is that the registry"
" may become stale if a bucket stops or crashes. Let's add a test to `KV.Regist"
"ryTest` that exposes this bug:"
msgstr ""

msgid ""
"```elixir\n"
"test \"removes buckets on exit\", %{registry: registry} do\n"
"  KV.Registry.create(registry, \"shopping\")\n"
"  {:ok, bucket} = KV.Registry.lookup(registry, \"shopping\")\n"
"  Agent.stop(bucket)\n"
"  assert KV.Registry.lookup(registry, \"shopping\") == :error\n"
"end\n"
"```"
msgstr ""

msgid ""
"The test above will fail on the last assertion as the bucket name remains in t"
"he registry even after we stop the bucket process."
msgstr ""

msgid ""
"In order to fix this bug, we need the registry to monitor every bucket it spaw"
"ns. Once we set up a monitor, the registry will receive a notification every t"
"ime a bucket process exits, allowing us to clean the registry up."
msgstr ""

msgid "Let's first play with monitors by starting a new console with `iex -S mix`:"
msgstr ""

msgid ""
"```iex\n"
"iex> {:ok, pid} = KV.Bucket.start_link([])\n"
"{:ok, #PID<0.66.0>}\n"
"iex> Process.monitor(pid)\n"
"#Reference<0.0.0.551>\n"
"iex> Agent.stop(pid)\n"
":ok\n"
"iex> flush()\n"
"{:DOWN, #Reference<0.0.0.551>, :process, #PID<0.66.0>, :normal}\n"
"```"
msgstr ""

msgid ""
"Note `Process.monitor(pid)` returns a unique reference that allows us to match"
" upcoming messages to that monitoring reference. After we stop the agent, we c"
"an `flush/0` all messages and notice a `:DOWN` message arrived, with the exact"
" reference returned by monitor, notifying that the bucket process exited with "
"reason `:normal`."
msgstr ""

msgid ""
"Let's reimplement the server callbacks to fix the bug and make the test pass. "
"First, we will modify the GenServer state to two dictionaries: one that contai"
"ns `name -> pid` and another that holds `ref -> name`. Then we need to monitor"
" the buckets on `handle_cast/2` as well as implement a `handle_info/2` callbac"
"k to handle the monitoring messages. The full server callbacks implementation "
"is shown below:"
msgstr ""

msgid ""
"```elixir\n"
"## Server callbacks"
msgstr ""

msgid ""
"def init(:ok) do\n"
"  names = %{}\n"
"  refs = %{}\n"
"  {:ok, {names, refs}}\n"
"end"
msgstr ""

msgid ""
"def handle_call({:lookup, name}, _from, {names, _} = state) do\n"
"  {:reply, Map.fetch(names, name), state}\n"
"end"
msgstr ""

msgid ""
"def handle_cast({:create, name}, {names, refs}) do\n"
"  if Map.has_key?(names, name) do\n"
"    {:noreply, {names, refs}}\n"
"  else\n"
"    {:ok, pid} = KV.Bucket.start_link([])\n"
"    ref = Process.monitor(pid)\n"
"    refs = Map.put(refs, ref, name)\n"
"    names = Map.put(names, name, pid)\n"
"    {:noreply, {names, refs}}\n"
"  end\n"
"end"
msgstr ""

msgid ""
"def handle_info({:DOWN, ref, :process, _pid, _reason}, {names, refs}) do\n"
"  {name, refs} = Map.pop(refs, ref)\n"
"  names = Map.delete(names, name)\n"
"  {:noreply, {names, refs}}\n"
"end"
msgstr ""

msgid ""
"def handle_info(_msg, state) do\n"
"  {:noreply, state}\n"
"end\n"
"```"
msgstr ""

msgid ""
"Observe that we were able to considerably change the server implementation wit"
"hout changing any of the client API. That's one of the benefits of explicitly "
"segregating the server and the client."
msgstr ""

msgid ""
"Finally, different from the other callbacks, we have defined a \"catch-all\" cla"
"use for `handle_info/2` that discards any unknown message. To understand why, "
"let's move on to the next section."
msgstr ""

msgid "## `call`, `cast` or `info`?"
msgstr ""

msgid ""
"So far we have used three callbacks: `handle_call/3`, `handle_cast/2` and `han"
"dle_info/2`. Here is what we should consider when deciding when to use each:"
msgstr ""

msgid ""
"1. `handle_call/3` must be used for synchronous requests. This should be the d"
"efault choice as waiting for the server reply is a useful backpressure mechani"
"sm."
msgstr ""

msgid ""
"2. `handle_cast/2` must be used for asynchronous requests, when you don't care"
" about a reply. A cast does not even guarantee the server has received the mes"
"sage and, for this reason, should be used sparingly. For example, the `create/"
"2` function we have defined in this chapter should have used `call/2`. We have"
" used `cast/2` for didactic purposes."
msgstr ""

msgid ""
"3. `handle_info/2` must be used for all other messages a server may receive th"
"at are not sent via `GenServer.call/2` or `GenServer.cast/2`, including regula"
"r messages sent with `send/2`. The monitoring `:DOWN` messages are such an exa"
"mple of this."
msgstr ""

msgid ""
"Since any message, including the ones sent via `send/2`, go to `handle_info/2`"
", there is a chance unexpected messages will arrive to the server. Therefore, "
"if we don't define the catch-all clause, those messages could cause our regist"
"ry to crash, because no clause would match. We don't need to worry about such "
"cases for `handle_call/3` and `handle_cast/2` though. Calls and casts are only"
" done via the `GenServer` API, so an unknown message is quite likely a develop"
"er mistake."
msgstr ""

msgid ""
"To help developers remember the differences between call, cast and info, the s"
"upported return values and more, [Benjamin Tan Wei Hao](http://benjamintan.io)"
" has created an excellent [GenServer cheat sheet](https://raw.githubuserconten"
"t.com/benjamintanweihao/elixir-cheatsheets/master/GenServer_CheatSheet.pdf)."
msgstr ""

msgid "## Monitors or links?"
msgstr ""

msgid ""
"We have previously learned about links in the [Process chapter](/getting-start"
"ed/processes.html). Now, with the registry complete, you may be wondering: whe"
"n should we use monitors and when should we use links?"
msgstr ""

msgid ""
"Links are bi-directional. If you link two processes and one of them crashes, t"
"he other side will crash too (unless it is trapping exits). A monitor is uni-d"
"irectional: only the monitoring process will receive notifications about the m"
"onitored one. In other words: use links when you want linked crashes, and moni"
"tors when you just want to be informed of crashes, exits, and so on."
msgstr ""

msgid ""
"Returning to our `handle_cast/2` implementation, you can see the registry is b"
"oth linking and monitoring the buckets:"
msgstr ""

msgid ""
"```elixir\n"
"{:ok, pid} = KV.Bucket.start_link([])\n"
"ref = Process.monitor(pid)\n"
"```"
msgstr ""

msgid ""
"This is a bad idea, as we don't want the registry to crash when a bucket crash"
"es! We typically avoid creating new processes directly, instead, we delegate t"
"his responsibility to supervisors. As we'll see in the next chapter, superviso"
"rs rely on links and that explains why link-based APIs (`spawn_link`, `start_l"
"ink`, etc) are so prevalent in Elixir and <abbr title=\"Open Telecom Platform\">"
"OTP</abbr>."
msgstr ""
