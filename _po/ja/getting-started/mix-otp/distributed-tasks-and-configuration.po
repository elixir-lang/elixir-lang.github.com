msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Distributed tasks and configuration\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid "{% include mix-otp-preface.html %}"
msgstr ""

msgid ""
"In this last chapter, we will go back to the `:kv` application and add a routi"
"ng layer that will allow us to distribute requests between nodes based on the "
"bucket name."
msgstr ""

msgid "The routing layer will receive a routing table of the following format:"
msgstr ""

msgid ""
"```elixir\n"
"[{?a..?m, :\"foo@computer-name\"},\n"
" {?n..?z, :\"bar@computer-name\"}]\n"
"```"
msgstr ""

msgid ""
"The router will check the first byte of the bucket name against the table and "
"dispatch to the appropriate node based on that. For example, a bucket starting"
" with the letter \"a\" (`?a` represents the Unicode codepoint of the letter \"a\")"
" will be dispatched to node `foo@computer-name`."
msgstr ""

msgid ""
"If the matching entry points to the node evaluating the request, then we've fi"
"nished routing, and this node will perform the requested operation. If the mat"
"ching entry points to a different node, we'll pass the request to this node, w"
"hich will look at its own routing table (which may be different from the one i"
"n the first node) and act accordingly. If no entry matches, an error will be r"
"aised."
msgstr ""

msgid ""
"You may wonder why we don't tell the node we found in our routing table to per"
"form the requested operation directly, but instead pass the routing request on"
" to that node to process. While a routing table as simple as the one above mig"
"ht reasonably be shared between all nodes, passing on the routing request in t"
"his way makes it much simpler to break the routing table into smaller pieces a"
"s our application grows. Perhaps at some point, `foo@computer-name` will only "
"be responsible for routing bucket requests, and the buckets it handles will be"
" dispatched to different nodes. In this way, `bar@computer-name` does not need"
" to know anything about this change."
msgstr ""

msgid ""
"> Note: we will be using two nodes in the same machine throughout this chapter"
". You are free to use two (or more) different machines in the same network but"
" you need to do some prep work. First of all, you need to ensure all machines "
"have a `~/.erlang.cookie` file with exactly the same value. Second, you need t"
"o guarantee [epmd](http://www.erlang.org/doc/man/epmd.html) is running on a po"
"rt that is not blocked (you can run `epmd -d` for debug info). Third, if you w"
"ant to learn more about distribution in general, we recommend [this great Dist"
"ribunomicon chapter from Learn You Some Erlang](http://learnyousomeerlang.com/"
"distribunomicon)."
msgstr ""

msgid "## Our first distributed code"
msgstr ""

msgid ""
"Elixir ships with facilities to connect nodes and exchange information between"
" them. In fact, we use the same concepts of processes, message passing and rec"
"eiving messages when working in a distributed environment because Elixir proce"
"sses are *location transparent*. This means that when sending a message, it do"
"esn't matter if the recipient process is on the same node or on another node, "
"the <abbr title=\"Virtual Machine\">VM</abbr> will be able to deliver the messag"
"e in both cases."
msgstr ""

msgid ""
"In order to run distributed code, we need to start the <abbr title=\"Virtual Ma"
"chine\">VM</abbr> with a name. The name can be short (when in the same network)"
" or long (requires the full computer address). Let's start a new IEx session:"
msgstr ""

msgid ""
"```bash\n"
"$ iex --sname foo\n"
"```"
msgstr ""

msgid ""
"You can see now the prompt is slightly different and shows the node name follo"
"wed by the computer name:"
msgstr ""

msgid ""
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"    iex(foo@jv)1>"
msgstr ""

msgid ""
"My computer is named `jv`, so I see `foo@jv` in the example above, but you wil"
"l get a different result. We will use `foo@computer-name` in the following exa"
"mples and you should update them accordingly when trying out the code."
msgstr ""

msgid "Let's define a module named `Hello` in this shell:"
msgstr ""

msgid ""
"```iex\n"
"iex> defmodule Hello do\n"
"...>   def world, do: IO.puts \"hello world\"\n"
"...> end\n"
"```"
msgstr ""

msgid ""
"If you have another computer on the same network with both Erlang and Elixir i"
"nstalled, you can start another shell on it. If you don't, you can start anoth"
"er IEx session in another terminal. In either case, give it the short name of "
"`bar`:"
msgstr ""

msgid ""
"```bash\n"
"$ iex --sname bar\n"
"```"
msgstr ""

msgid "Note that inside this new IEx session, we cannot access `Hello.world/0`:"
msgstr ""

msgid ""
"```iex\n"
"iex> Hello.world\n"
"** (UndefinedFunctionError) undefined function: Hello.world/0\n"
"    Hello.world()\n"
"```"
msgstr ""

msgid ""
"However we can spawn a new process on `foo@computer-name` from `bar@computer-n"
"ame`! Let's give it a try (where `@computer-name` is the one you see locally):"
msgstr ""

msgid ""
"```iex\n"
"iex> Node.spawn_link :\"foo@computer-name\", fn -> Hello.world end\n"
"#PID<9014.59.0>\n"
"hello world\n"
"```"
msgstr ""

msgid ""
"Elixir spawned a process on another node and returned its pid. The code then e"
"xecuted on the other node where the `Hello.world/0` function exists and invoke"
"d that function. Note that the result of \"hello world\" was printed on the curr"
"ent node `bar` and not on `foo`. In other words, the message to be printed was"
" sent back from `foo` to `bar`. This happens because the process spawned on th"
"e other node (`foo`) still has the group leader of the current node (`bar`). W"
"e have briefly talked about group leaders in the [IO chapter](/getting-started"
"/io-and-the-file-system.html#processes-and-group-leaders)."
msgstr ""

msgid ""
"We can send and receive message from the pid returned by `Node.spawn_link/2` a"
"s usual. Let's try a quick ping-pong example:"
msgstr ""

msgid ""
"```iex\n"
"iex> pid = Node.spawn_link :\"foo@computer-name\", fn ->\n"
"...>   receive do\n"
"...>     {:ping, client} -> send client, :pong\n"
"...>   end\n"
"...> end\n"
"#PID<9014.59.0>\n"
"iex> send pid, {:ping, self()}\n"
"{:ping, #PID<0.73.0>}\n"
"iex> flush()\n"
":pong\n"
":ok\n"
"```"
msgstr ""

msgid ""
"From our quick exploration, we could conclude that we should use `Node.spawn_l"
"ink/2` to spawn processes on a remote node every time we need to do a distribu"
"ted computation. However we have learned throughout this guide that spawning p"
"rocesses outside of supervision trees should be avoided if possible, so we nee"
"d to look for other options."
msgstr ""

msgid ""
"There are three better alternatives to `Node.spawn_link/2` that we could use i"
"n our implementation:"
msgstr ""

msgid ""
"1. We could use Erlang's [:rpc](http://www.erlang.org/doc/man/rpc.html) module"
" to execute functions on a remote node. Inside the `bar@computer-name` shell a"
"bove, you can call `:rpc.call(:\"foo@computer-name\", Hello, :world, [])` and it"
" will print \"hello world\""
msgstr ""

msgid ""
"2. We could have a server running on the other node and send requests to that "
"node via the [GenServer](https://hexdocs.pm/elixir/GenServer.html) API. For ex"
"ample, you can call a server on a remote node by using `GenServer.call({name, "
"node}, arg)` or passing the remote process PID as first argument"
msgstr ""

msgid ""
"3. We could use [tasks](https://hexdocs.pm/elixir/Task.html), which we have le"
"arned about in [a previous chapter](/getting-started/mix-otp/task-and-gen-tcp."
"html), as they can be spawned on both local and remote nodes"
msgstr ""

msgid ""
"The options above have different properties. Both `:rpc` and using a GenServer"
" would serialize your requests on a single server, while tasks are effectively"
" running asynchronously on the remote node, with the only serialization point "
"being the spawning done by the supervisor."
msgstr ""

msgid ""
"For our routing layer, we are going to use tasks, but feel free to explore the"
" other alternatives too."
msgstr ""

msgid "## async/await"
msgstr ""

msgid ""
"So far we have explored tasks that are started and run in isolation, with no r"
"egard for their return value. However, sometimes it is useful to run a task to"
" compute a value and read its result later on. For this, tasks also provide th"
"e `async/await` pattern:"
msgstr ""

msgid ""
"```elixir\n"
"task = Task.async(fn -> compute_something_expensive end)\n"
"res  = compute_something_else()\n"
"res + Task.await(task)\n"
"```"
msgstr ""

msgid ""
"`async/await` provides a very simple mechanism to compute values concurrently."
" Not only that, `async/await` can also be used with the same [`Task.Supervisor"
"`](https://hexdocs.pm/elixir/Task.Supervisor.html) we have used in previous ch"
"apters. We just need to call `Task.Supervisor.async/2` instead of `Task.Superv"
"isor.start_child/2` and use `Task.await/2` to read the result later on."
msgstr ""

msgid "## Distributed tasks"
msgstr ""

msgid ""
"Distributed tasks are exactly the same as supervised tasks. The only differenc"
"e is that we pass the node name when spawning the task on the supervisor. Open"
" up `lib/kv/supervisor.ex` from the `:kv` application. Let's add a task superv"
"isor as the last child of the tree:"
msgstr ""

msgid ""
"```elixir\n"
"{Task.Supervisor, name: KV.RouterTasks},\n"
"```"
msgstr ""

msgid "Now, let's start two named nodes again, but inside the `:kv` application:"
msgstr ""

msgid ""
"```bash\n"
"$ iex --sname foo -S mix\n"
"$ iex --sname bar -S mix\n"
"```"
msgstr ""

msgid ""
"From inside `bar@computer-name`, we can now spawn a task directly on the other"
" node via the supervisor:"
msgstr ""

msgid ""
"```iex\n"
"iex> task = Task.Supervisor.async {KV.RouterTasks, :\"foo@computer-name\"}, fn -"
">\n"
"...>   {:ok, node()}\n"
"...> end\n"
"%Task{owner: #PID<0.122.0>, pid: #PID<12467.88.0>, ref: #Reference<0.0.0.400>}"
"\n"
"iex> Task.await(task)\n"
"{:ok, :\"foo@computer-name\"}\n"
"```"
msgstr ""

msgid ""
"Our first distributed task retrieves the name of the node the task is running "
"on. Notice we have given an anonymous function to `Task.Supervisor.async/2` bu"
"t, in distributed cases, it is preferable to give the module, function and arg"
"uments explicitly:"
msgstr ""

msgid ""
"```iex\n"
"iex> task = Task.Supervisor.async {KV.RouterTasks, :\"foo@computer-name\"}, Kern"
"el, :node, []\n"
"%Task{owner: #PID<0.122.0>, pid: #PID<12467.89.0>, ref: #Reference<0.0.0.404>}"
"\n"
"iex> Task.await(task)\n"
":\"foo@computer-name\"\n"
"```"
msgstr ""

msgid ""
"The difference is that anonymous functions requires the target node to have ex"
"actly the same code version as the caller. Using module, function and argument"
"s is more robust because you only need to find a function with matching arity "
"in the given module."
msgstr ""

msgid "With this knowledge in hand, let's finally write the routing code."
msgstr ""

msgid "## Routing layer"
msgstr ""

msgid "Create a file at `lib/kv/router.ex` with the following contents:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule KV.Router do\n"
"  @doc \"\"\"\n"
"  Dispatch the given `mod`, `fun`, `args` request\n"
"  to the appropriate node based on the `bucket`.\n"
"  \"\"\"\n"
"  def route(bucket, mod, fun, args) do\n"
"    # Get the first byte of the binary\n"
"    first = :binary.first(bucket)"
msgstr ""

msgid ""
"    # Try to find an entry in the table() or raise\n"
"    entry =\n"
"      Enum.find(table(), fn {enum, _node} ->\n"
"        first in enum\n"
"      end) || no_entry_error(bucket)"
msgstr ""

msgid ""
"    # If the entry node is the current node\n"
"    if elem(entry, 1) == node() do\n"
"      apply(mod, fun, args)\n"
"    else\n"
"      {KV.RouterTasks, elem(entry, 1)}\n"
"      |> Task.Supervisor.async(KV.Router, :route, [bucket, mod, fun, args])\n"
"      |> Task.await()\n"
"    end\n"
"  end"
msgstr ""

msgid ""
"  defp no_entry_error(bucket) do\n"
"    raise \"could not find entry for #{inspect bucket} in table #{inspect table"
"()}\"\n"
"  end"
msgstr ""

msgid ""
"  @doc \"\"\"\n"
"  The routing table.\n"
"  \"\"\"\n"
"  def table do\n"
"    # Replace computer-name with your local machine name.\n"
"    [{?a..?m, :\"foo@computer-name\"},\n"
"     {?n..?z, :\"bar@computer-name\"}]\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"Let's write a test to verify our router works. Create a file named `test/kv/ro"
"uter_test.exs` containing:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule KV.RouterTest do\n"
"  use ExUnit.Case, async: true"
msgstr ""

msgid ""
"  test \"route requests across nodes\" do\n"
"    assert KV.Router.route(\"hello\", Kernel, :node, []) ==\n"
"           :\"foo@computer-name\"\n"
"    assert KV.Router.route(\"world\", Kernel, :node, []) ==\n"
"           :\"bar@computer-name\"\n"
"  end"
msgstr ""

msgid ""
"  test \"raises on unknown entries\" do\n"
"    assert_raise RuntimeError, ~r/could not find entry/, fn ->\n"
"      KV.Router.route(<<0>>, Kernel, :node, [])\n"
"    end\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"The first test invokes `Kernel.node/0`, which returns the name of the current "
"node, based on the bucket names \"hello\" and \"world\". According to our routing "
"table so far, we should get `foo@computer-name` and `bar@computer-name` as res"
"ponses, respectively."
msgstr ""

msgid "The second test checks that the code raises for unknown entries."
msgstr ""

msgid ""
"In order to run the first test, we need to have two nodes running. Move into `"
"apps/kv` and let's restart the node named `bar` which is going to be used by t"
"ests."
msgstr ""

msgid ""
"```bash\n"
"$ iex --sname bar -S mix\n"
"```"
msgstr ""

msgid "And now run tests with:"
msgstr ""

msgid ""
"```bash\n"
"$ elixir --sname foo -S mix test\n"
"```"
msgstr ""

msgid "The test should pass."
msgstr ""

msgid "## Test filters and tags"
msgstr ""

msgid ""
"Although our tests pass, our testing structure is getting more complex. In par"
"ticular, running tests with only `mix test` causes failures in our suite, sinc"
"e our test requires a connection to another node."
msgstr ""

msgid ""
"Luckily, ExUnit ships with a facility to tag tests, allowing us to run specifi"
"c callbacks or even filter tests altogether based on those tags. We have alrea"
"dy used the `:capture_log` tag in the previous chapter, which has its semantic"
"s specified by ExUnit itself."
msgstr ""

msgid "This time let's add a `:distributed` tag to `test/kv/router_test.exs`:"
msgstr ""

msgid ""
"```elixir\n"
"@tag :distributed\n"
"test \"route requests across nodes\" do\n"
"```"
msgstr ""

msgid "Writing `@tag :distributed` is equivalent to writing `@tag distributed: true`."
msgstr ""

msgid ""
"With the test properly tagged, we can now check if the node is alive on the ne"
"twork and, if not, we can exclude all distributed tests. Open up `test/test_he"
"lper.exs` inside the `:kv` application and add the following:"
msgstr ""

msgid ""
"```elixir\n"
"exclude =\n"
"  if Node.alive?, do: [], else: [distributed: true]"
msgstr ""

msgid ""
"ExUnit.start(exclude: exclude)\n"
"```"
msgstr ""

msgid "Now run tests with `mix test`:"
msgstr ""

msgid ""
"```bash\n"
"$ mix test\n"
"Excluding tags: [distributed: true]"
msgstr ""

msgid "......."
msgstr ""

msgid ""
"Finished in 0.1 seconds (0.1s on load, 0.01s on tests)\n"
"7 tests, 0 failures, 1 skipped\n"
"```"
msgstr ""

msgid ""
"This time all tests passed and ExUnit warned us that distributed tests were be"
"ing excluded. If you run tests with `$ elixir --sname foo -S mix test`, one ex"
"tra test should run and successfully pass as long as the `bar@computer-name` n"
"ode is available."
msgstr ""

msgid ""
"The `mix test` command also allows us to dynamically include and exclude tags."
" For example, we can run `$ mix test --include distributed` to run distributed"
" tests regardless of the value set in `test/test_helper.exs`. We could also pa"
"ss `--exclude` to exclude a particular tag from the command line. Finally, `--"
"only` can be used to run only tests with a particular tag:"
msgstr ""

msgid ""
"```bash\n"
"$ elixir --sname foo -S mix test --only distributed\n"
"```"
msgstr ""

msgid ""
"You can read more about filters, tags and the default tags in [`ExUnit.Case` m"
"odule documentation](https://hexdocs.pm/ex_unit/ExUnit.Case.html)."
msgstr ""

msgid "## Application environment and configuration"
msgstr ""

msgid ""
"So far we have hardcoded the routing table into the `KV.Router` module. Howeve"
"r, we would like to make the table dynamic. This allows us not only to configu"
"re development/test/production, but also to allow different nodes to run with "
"different entries in the routing table. There is a feature of  <abbr title=\"Op"
"en Telecom Platform\">OTP</abbr> that does exactly that: the application enviro"
"nment."
msgstr ""

msgid ""
"Each application has an environment that stores the application's specific con"
"figuration by key. For example, we could store the routing table in the `:kv` "
"application environment, giving it a default value and allowing other applicat"
"ions to change the table as needed."
msgstr ""

msgid ""
"Open up `apps/kv/mix.exs` and change the `application/0` function to return th"
"e following:"
msgstr ""

msgid ""
"```elixir\n"
"def application do\n"
"  [extra_applications: [:logger],\n"
"   env: [routing_table: []],\n"
"   mod: {KV, []}]\n"
"end\n"
"```"
msgstr ""

msgid ""
"We have added a new `:env` key to the application. It returns the application "
"default environment, which has an entry of key `:routing_table` and value of a"
"n empty list. It makes sense for the application environment to ship with an e"
"mpty table, as the specific routing table depends on the testing/deployment st"
"ructure."
msgstr ""

msgid ""
"In order to use the application environment in our code, we need to replace `K"
"V.Router.table/0` with the definition below:"
msgstr ""

msgid ""
"```elixir\n"
"@doc \"\"\"\n"
"The routing table.\n"
"\"\"\"\n"
"def table do\n"
"  Application.fetch_env!(:kv, :routing_table)\n"
"end\n"
"```"
msgstr ""

msgid ""
"We use `Application.fetch_env!/2` to read the entry for `:routing_table` in `:"
"kv`'s environment. You can find more information and other functions to manipu"
"late the app environment in the [Application module](https://hexdocs.pm/elixir"
"/Application.html)."
msgstr ""

msgid ""
"Since our routing table is now empty, our distributed test should fail. Restar"
"t the apps and re-run tests to see the failure:"
msgstr ""

msgid ""
"```bash\n"
"$ iex --sname bar -S mix\n"
"$ elixir --sname foo -S mix test --only distributed\n"
"```"
msgstr ""

msgid ""
"The interesting thing about the application environment is that it can be conf"
"igured not only for the current application, but for all applications. Such co"
"nfiguration is done by the `config/config.exs` file. For example, we can confi"
"gure IEx default prompt to another value. Just open `apps/kv/config/config.exs"
"` and add the following to the end:"
msgstr ""

msgid ""
"```elixir\n"
"config :iex, default_prompt: \">>>\"\n"
"```"
msgstr ""

msgid "Start IEx with `iex -S mix` and you can see that the IEx prompt has changed."
msgstr ""

msgid ""
"This means we can also configure our `:routing_table` directly in the `apps/kv"
"/config/config.exs` file:"
msgstr ""

msgid ""
"```elixir\n"
"# Replace computer-name with your local machine nodes.\n"
"config :kv, :routing_table,\n"
"       [{?a..?m, :\"foo@computer-name\"},\n"
"        {?n..?z, :\"bar@computer-name\"}]\n"
"```"
msgstr ""

msgid "Restart the nodes and run distributed tests again. Now they should all pass."
msgstr ""

msgid ""
"Since Elixir v1.2, all umbrella applications share their configurations, thank"
"s to this line in `config/config.exs` in the umbrella root that loads the conf"
"iguration of all children:"
msgstr ""

msgid ""
"```elixir\n"
"import_config \"../apps/*/config/config.exs\"\n"
"```"
msgstr ""

msgid ""
"The `mix run` command also accepts a `--config` flag, which allows configurati"
"on files to be given on demand. This could be used to start different nodes, e"
"ach with its own specific configuration (for example, different routing tables"
")."
msgstr ""

msgid ""
"Overall, the built-in ability to configure applications and the fact that we h"
"ave built our software as an umbrella application gives us plenty of options w"
"hen deploying the software. We can:"
msgstr ""

msgid ""
"* deploy the umbrella application to a node that will work as both TCP server "
"and key-value storage"
msgstr ""

msgid ""
"* deploy the `:kv_server` application to work only as a TCP server as long as "
"the routing table points only to other nodes"
msgstr ""

msgid ""
"* deploy only the `:kv` application when we want a node to work only as storag"
"e (no TCP access)"
msgstr ""

msgid ""
"As we add more applications in the future, we can continue controlling our dep"
"loy with the same level of granularity, cherry-picking which applications with"
" which configuration are going to production."
msgstr ""

msgid ""
"You can also consider building multiple releases with a tool like [Distillery]"
"(https://github.com/bitwalker/distillery), which will package the chosen appli"
"cations and configuration, including the current Erlang and Elixir installatio"
"ns, so we can deploy the application even if the runtime is not pre-installed "
"on the target system."
msgstr ""

msgid ""
"Finally, we have learned some new things in this chapter, and they could be ap"
"plied to the `:kv_server` application as well. We are going to leave the next "
"steps as an exercise:"
msgstr ""

msgid ""
"* change the `:kv_server` application to read the port from its application en"
"vironment instead of using the hardcoded value of 4040"
msgstr ""

msgid ""
"* change and configure the `:kv_server` application to use the routing functio"
"nality instead of dispatching directly to the local `KV.Registry`. For `:kv_se"
"rver` tests, you can make the routing table point to the current node itself"
msgstr ""

msgid "## Summing up"
msgstr ""

msgid ""
"In this chapter we have built a simple router as a way to explore the distribu"
"ted features of Elixir and the Erlang <abbr title=\"Virtual Machine\">VM</abbr>,"
" and learned how to configure its routing table. This is the last chapter in o"
"ur Mix and  <abbr title=\"Open Telecom Platform\">OTP</abbr> guide."
msgstr ""

msgid ""
"Throughout the guide, we have built a very simple distributed key-value store "
"as an opportunity to explore many constructs like generic servers, supervisors"
", tasks, agents, applications and more. Not only that, we have written tests f"
"or the whole application, got familiar with ExUnit, and learned how to use the"
" Mix build tool to accomplish a wide range of tasks."
msgstr ""

msgid ""
"If you are looking for a distributed key-value store to use in production, you"
" should definitely look into [Riak](http://basho.com/riak/), which also runs i"
"n the Erlang <abbr title=\"Virtual Machine\">VM</abbr>. In Riak, the buckets are"
" replicated, to avoid data loss, and instead of a router, they use [consistent"
" hashing](https://en.wikipedia.org/wiki/Consistent_hashing) to map a bucket to"
" a node. A consistent hashing algorithm helps reduce the amount of data that n"
"eeds to be migrated when new nodes to store buckets are added to your infrastr"
"ucture."
msgstr ""

msgid "Happy coding!"
msgstr ""
