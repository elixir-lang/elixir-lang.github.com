msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Doctests, patterns and with\n"
"redirect_from: /getting-started/mix_otp/docs-tests-and-pipelines.html\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid "{% include mix-otp-preface.html %}"
msgstr ""

msgid ""
"In this chapter, we will implement the code that parses the commands we descri"
"bed in the first chapter:"
msgstr ""

msgid ""
"```\n"
"CREATE shopping\n"
"OK"
msgstr ""

msgid ""
"PUT shopping milk 1\n"
"OK"
msgstr ""

msgid ""
"PUT shopping eggs 3\n"
"OK"
msgstr ""

msgid ""
"GET shopping milk\n"
"1\n"
"OK"
msgstr ""

msgid ""
"DELETE shopping eggs\n"
"OK\n"
"```"
msgstr ""

msgid ""
"After the parsing is done, we will update our server to dispatch the parsed co"
"mmands to the `:kv` application we built previously."
msgstr ""

msgid "## Doctests"
msgstr ""

msgid ""
"On the language homepage, we mention that Elixir makes documentation a first-c"
"lass citizen in the language. We have explored this concept many times through"
"out this guide, be it via `mix help` or by typing `h Enum` or another module i"
"n an IEx console."
msgstr ""

msgid ""
"In this section, we will implement the parsing functionality, document it and "
"make sure our documentation is up to date with doctests. This helps us provide"
" documentation with accurate code samples."
msgstr ""

msgid ""
"Let's create our command parser at `lib/kv_server/command.ex` and start with t"
"he doctest:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule KVServer.Command do\n"
"  @doc ~S\"\"\"\n"
"  Parses the given `line` into a command."
msgstr ""

msgid "  ## Examples"
msgstr ""

msgid ""
"      iex> KVServer.Command.parse(\"CREATE shopping\n"
"\")\n"
"      {:ok, {:create, \"shopping\"}}"
msgstr ""

msgid ""
"  \"\"\"\n"
"  def parse(_line) do\n"
"    :not_implemented\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"Doctests are specified by an indentation of four spaces followed by the `iex>`"
" prompt in a documentation string. If a command spans multiple lines, you can "
"use `...>`, as in IEx. The expected result should start at the next line after"
" `iex>` or `...>` line(s) and is terminated either by a newline or a new `iex>"
"` prefix."
msgstr ""

msgid ""
"Also, note that we started the documentation string using `@doc ~S\"\"\"`. The `~"
"S` prevents the `\n"
"` characters from being converted to a carriage return and line feed until the"
"y are evaluated in the test."
msgstr ""

msgid ""
"To run our doctests, we'll create a file at `test/kv_server/command_test.exs` "
"and call `doctest KVServer.Command` in the test case:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule KVServer.CommandTest do\n"
"  use ExUnit.Case, async: true\n"
"  doctest KVServer.Command\n"
"end\n"
"```"
msgstr ""

msgid "Run the test suite and the doctest should fail:"
msgstr ""

msgid ""
"```\n"
"  1) test doc at KVServer.Command.parse/1 (1) (KVServer.CommandTest)\n"
"     test/kv_server/command_test.exs:3\n"
"     Doctest failed\n"
"     code: KVServer.Command.parse \"CREATE shopping\n"
"\" === {:ok, {:create, \"shopping\"}}\n"
"     lhs:  :not_implemented\n"
"     stacktrace:\n"
"       lib/kv_server/command.ex:7: KVServer.Command (module)\n"
"```"
msgstr ""

msgid "Excellent!"
msgstr ""

msgid "Now let's make the doctest pass. Let's implement the `parse/1` function:"
msgstr ""

msgid ""
"```elixir\n"
"def parse(line) do\n"
"  case String.split(line) do\n"
"    [\"CREATE\", bucket] -> {:ok, {:create, bucket}}\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"Our implementation splits the line on whitespace and then matches the command "
"against a list. Using `String.split/1` means our commands will be whitespace-i"
"nsensitive. Leading and trailing whitespace won't matter, nor will consecutive"
" spaces between words. Let's add some new doctests to test this behaviour alon"
"g with the other commands:"
msgstr ""

msgid ""
"```elixir\n"
"@doc ~S\"\"\"\n"
"Parses the given `line` into a command."
msgstr ""

msgid "## Examples"
msgstr ""

msgid ""
"    iex> KVServer.Command.parse \"CREATE shopping\n"
"\"\n"
"    {:ok, {:create, \"shopping\"}}"
msgstr ""

msgid ""
"    iex> KVServer.Command.parse \"CREATE  shopping  \n"
"\"\n"
"    {:ok, {:create, \"shopping\"}}"
msgstr ""

msgid ""
"    iex> KVServer.Command.parse \"PUT shopping milk 1\n"
"\"\n"
"    {:ok, {:put, \"shopping\", \"milk\", \"1\"}}"
msgstr ""

msgid ""
"    iex> KVServer.Command.parse \"GET shopping milk\n"
"\"\n"
"    {:ok, {:get, \"shopping\", \"milk\"}}"
msgstr ""

msgid ""
"    iex> KVServer.Command.parse \"DELETE shopping eggs\n"
"\"\n"
"    {:ok, {:delete, \"shopping\", \"eggs\"}}"
msgstr ""

msgid ""
"Unknown commands or commands with the wrong number of\n"
"arguments return an error:"
msgstr ""

msgid ""
"    iex> KVServer.Command.parse \"UNKNOWN shopping eggs\n"
"\"\n"
"    {:error, :unknown_command}"
msgstr ""

msgid ""
"    iex> KVServer.Command.parse \"GET shopping\n"
"\"\n"
"    {:error, :unknown_command}"
msgstr ""

msgid ""
"\"\"\"\n"
"```"
msgstr ""

msgid ""
"With doctests at hand, it is your turn to make tests pass! Once you're ready, "
"you can compare your work with our solution below:"
msgstr ""

msgid ""
"```elixir\n"
"def parse(line) do\n"
"  case String.split(line) do\n"
"    [\"CREATE\", bucket] -> {:ok, {:create, bucket}}\n"
"    [\"GET\", bucket, key] -> {:ok, {:get, bucket, key}}\n"
"    [\"PUT\", bucket, key, value] -> {:ok, {:put, bucket, key, value}}\n"
"    [\"DELETE\", bucket, key] -> {:ok, {:delete, bucket, key}}\n"
"    _ -> {:error, :unknown_command}\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"Notice how we were able to elegantly parse the commands without adding a bunch"
" of `if/else` clauses that check the command name and number of arguments!"
msgstr ""

msgid ""
"Finally, you may have observed that each doctest corresponds to a different te"
"st in our suite, which now reports a total of 7 doctests. That is because ExUn"
"it considers the following to define two different doctests:"
msgstr ""

msgid ""
"```iex\n"
"iex> KVServer.Command.parse(\"UNKNOWN shopping eggs\n"
"\")\n"
"{:error, :unknown_command}"
msgstr ""

msgid ""
"iex> KVServer.Command.parse(\"GET shopping\n"
"\")\n"
"{:error, :unknown_command}\n"
"```"
msgstr ""

msgid "Without new lines, as seen below, ExUnit compiles it into a single doctest:"
msgstr ""

msgid ""
"```iex\n"
"iex> KVServer.Command.parse(\"UNKNOWN shopping eggs\n"
"\")\n"
"{:error, :unknown_command}\n"
"iex> KVServer.Command.parse(\"GET shopping\n"
"\")\n"
"{:error, :unknown_command}\n"
"```"
msgstr ""

msgid ""
"As the name says, doctest is documentation first and a test later. Their goal "
"is not to replace tests but to provide up to date documentation. You can read "
"more about doctests in [the `ExUnit.DocTest` docs](https://hexdocs.pm/ex_unit/"
"ExUnit.DocTest.html)."
msgstr ""

msgid "## with"
msgstr ""

msgid ""
"As we are now able to parse commands, we can finally start implementing the lo"
"gic that runs the commands. Let's add a stub definition for this function for "
"now:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule KVServer.Command do\n"
"  @doc \"\"\"\n"
"  Runs the given command.\n"
"  \"\"\"\n"
"  def run(command) do\n"
"    {:ok, \"OK\n"
"\"}\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"Before we implement this function, let's change our server to start using our "
"new `parse/1` and `run/1` functions. Remember, our `read_line/1` function was "
"also crashing when the client closed the socket, so let's take the opportunity"
" to fix it, too. Open up `lib/kv_server.ex` and replace the existing server de"
"finition:"
msgstr ""

msgid ""
"```elixir\n"
"defp serve(socket) do\n"
"  socket\n"
"  |> read_line()\n"
"  |> write_line(socket)"
msgstr ""

msgid ""
"  serve(socket)\n"
"end"
msgstr ""

msgid ""
"defp read_line(socket) do\n"
"  {:ok, data} = :gen_tcp.recv(socket, 0)\n"
"  data\n"
"end"
msgstr ""

msgid ""
"defp write_line(line, socket) do\n"
"  :gen_tcp.send(socket, line)\n"
"end\n"
"```"
msgstr ""

msgid "by the following:"
msgstr ""

msgid ""
"```elixir\n"
"defp serve(socket) do\n"
"  msg =\n"
"    case read_line(socket) do\n"
"      {:ok, data} ->\n"
"        case KVServer.Command.parse(data) do\n"
"          {:ok, command} ->\n"
"            KVServer.Command.run(command)\n"
"          {:error, _} = err ->\n"
"            err\n"
"        end\n"
"      {:error, _} = err ->\n"
"        err\n"
"    end"
msgstr ""

msgid ""
"  write_line(socket, msg)\n"
"  serve(socket)\n"
"end"
msgstr ""

msgid ""
"defp read_line(socket) do\n"
"  :gen_tcp.recv(socket, 0)\n"
"end"
msgstr ""

msgid ""
"defp write_line(socket, {:ok, text}) do\n"
"  :gen_tcp.send(socket, text)\n"
"end"
msgstr ""

msgid ""
"defp write_line(socket, {:error, :unknown_command}) do\n"
"  # Known error. Write to the client.\n"
"  :gen_tcp.send(socket, \"UNKNOWN COMMAND\n"
"\")\n"
"end"
msgstr ""

msgid ""
"defp write_line(_socket, {:error, :closed}) do\n"
"  # The connection was closed, exit politely.\n"
"  exit(:shutdown)\n"
"end"
msgstr ""

msgid ""
"defp write_line(socket, {:error, error}) do\n"
"  # Unknown error. Write to the client and exit.\n"
"  :gen_tcp.send(socket, \"ERROR\n"
"\")\n"
"  exit(error)\n"
"end\n"
"```"
msgstr ""

msgid ""
"If we start our server, we can now send commands to it. For now, we will get t"
"wo different responses: \"OK\" when the command is known and \"UNKNOWN COMMAND\" o"
"therwise:"
msgstr ""

msgid ""
"```console\n"
"$ telnet 127.0.0.1 4040\n"
"Trying 127.0.0.1...\n"
"Connected to localhost.\n"
"Escape character is '^]'.\n"
"CREATE shopping\n"
"OK\n"
"HELLO\n"
"UNKNOWN COMMAND\n"
"```"
msgstr ""

msgid ""
"This means our implementation is going in the correct direction, but it doesn'"
"t look very elegant, does it?"
msgstr ""

msgid ""
"The previous implementation used pipelines which made the logic straightforwar"
"d to follow. However, now that we need to handle different error codes along t"
"he way, our server logic is nested inside many `case` calls."
msgstr ""

msgid ""
"Thankfully, Elixir v1.2 introduced the `with` construct, which allows you to s"
"implify code like the above, replacing nested `case` calls with a chain of mat"
"ching clauses. Let's rewrite the `serve/1` function to use `with`:"
msgstr ""

msgid ""
"```elixir\n"
"defp serve(socket) do\n"
"  msg =\n"
"    with {:ok, data} <- read_line(socket),\n"
"         {:ok, command} <- KVServer.Command.parse(data),\n"
"         do: KVServer.Command.run(command)"
msgstr ""

msgid ""
"  write_line(socket, msg)\n"
"  serve(socket)\n"
"end\n"
"```"
msgstr ""

msgid ""
"Much better! `with` will retrieve the value returned by the right-side of `<-`"
" and match it against the pattern on the left side. If the value matches the p"
"attern, `with` moves on to the next expression. In case there is no match, the"
" non-matching value is returned."
msgstr ""

msgid ""
"In other words, we converted each expression given to `case/2` as a step in `w"
"ith`. As soon as any of the steps return something that does not match `{:ok, "
"x}`, `with` aborts, and returns the non-matching value."
msgstr ""

msgid ""
"You can read more about [`with` in our documentation](https://hexdocs.pm/elixi"
"r/Kernel.SpecialForms.html#with/1)."
msgstr ""

msgid "## Running commands"
msgstr ""

msgid ""
"The last step is to implement `KVServer.Command.run/1`, to run the parsed comm"
"ands against the `:kv` application. Its implementation is shown below:"
msgstr ""

msgid ""
"```elixir\n"
"@doc \"\"\"\n"
"Runs the given command.\n"
"\"\"\"\n"
"def run(command)"
msgstr ""

msgid ""
"def run({:create, bucket}) do\n"
"  KV.Registry.create(KV.Registry, bucket)\n"
"  {:ok, \"OK\n"
"\"}\n"
"end"
msgstr ""

msgid ""
"def run({:get, bucket, key}) do\n"
"  lookup(bucket, fn pid ->\n"
"    value = KV.Bucket.get(pid, key)\n"
"    {:ok, \"#{value}\n"
"OK\n"
"\"}\n"
"  end)\n"
"end"
msgstr ""

msgid ""
"def run({:put, bucket, key, value}) do\n"
"  lookup(bucket, fn pid ->\n"
"    KV.Bucket.put(pid, key, value)\n"
"    {:ok, \"OK\n"
"\"}\n"
"  end)\n"
"end"
msgstr ""

msgid ""
"def run({:delete, bucket, key}) do\n"
"  lookup(bucket, fn pid ->\n"
"    KV.Bucket.delete(pid, key)\n"
"    {:ok, \"OK\n"
"\"}\n"
"  end)\n"
"end"
msgstr ""

msgid ""
"defp lookup(bucket, callback) do\n"
"  case KV.Registry.lookup(KV.Registry, bucket) do\n"
"    {:ok, pid} -> callback.(pid)\n"
"    :error -> {:error, :not_found}\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"Every function clause dispatches the appropriate command to the `KV.Registry` "
"server that we registered during the `:kv` application startup. Since our `:kv"
"_server` depends on the `:kv` application, it is completely fine to depend on "
"the services it provides."
msgstr ""

msgid ""
"You might have noticed we have a function head, `def run(command)`, without a "
"body. In the [Modules and Functions](/getting-started/modules-and-functions#de"
"fault-arguments) chapter, we learned that a bodiless function can be used to d"
"eclare default arguments for a multi-clause function. Here is another use case"
" where we use a function without a body to document what the arguments are."
msgstr ""

msgid ""
"Note that we have also defined a private function named `lookup/2` to help wit"
"h the common functionality of looking up a bucket and returning its `pid` if i"
"t exists, `{:error, :not_found}` otherwise."
msgstr ""

msgid ""
"By the way, since we are now returning `{:error, :not_found}`, we should amend"
" the `write_line/2` function in `KVServer` to print such error as well:"
msgstr ""

msgid ""
"```elixir\n"
"defp write_line(socket, {:error, :not_found}) do\n"
"  :gen_tcp.send(socket, \"NOT FOUND\n"
"\")\n"
"end\n"
"```"
msgstr ""

msgid ""
"Our server functionality is almost complete. Only tests are missing. This time"
", we have left tests for last because there are some important considerations "
"to be made."
msgstr ""

msgid ""
"`KVServer.Command.run/1`'s implementation is sending commands directly to the "
"server named `KV.Registry`, which is registered by the `:kv` application. This"
" means this server is global and if we have two tests sending messages to it a"
"t the same time, our tests will conflict with each other (and likely fail). We"
" need to decide between having unit tests that are isolated and can run asynch"
"ronously, or writing integration tests that work on top of the global state, b"
"ut exercise our application's full stack as it is meant to be exercised in pro"
"duction."
msgstr ""

msgid ""
"So far we have only written unit tests, typically testing a single module dire"
"ctly. However, in order to make `KVServer.Command.run/1` testable as a unit we"
" would need to change its implementation to not send commands directly to the "
"`KV.Registry` process but instead pass a server as an argument. For example, w"
"e would need to change `run`'s signature to `def run(command, pid)` and then c"
"hange all clauses accordingly:"
msgstr ""

msgid ""
"```elixir\n"
"def run({:create, bucket}, pid) do\n"
"  KV.Registry.create(pid, bucket)\n"
"  {:ok, \"OK\n"
"\"}\n"
"end"
msgstr ""

msgid ""
"# ... other run clauses ...\n"
"```"
msgstr ""

msgid ""
"Feel free to go ahead and do the changes above and write some unit tests. The "
"idea is that your tests will start an instance of the `KV.Registry` and pass i"
"t as an argument to `run/2` instead of relying on the global `KV.Registry`. Th"
"is has the advantage of keeping our tests asynchronous as there is no shared s"
"tate."
msgstr ""

msgid ""
"But let's also try something different. Let's write integration tests that rel"
"y on the global server names to exercise the whole stack from the TCP server t"
"o the bucket. Our integration tests will rely on global state and must be sync"
"hronous. With integration tests, we get coverage on how the components in our "
"application work together at the cost of test performance. They are typically "
"used to test the main flows in your application. For example, we should avoid "
"using integration tests to test an edge case in our command parsing implementa"
"tion."
msgstr ""

msgid ""
"Our integration test will use a TCP client that sends commands to our server a"
"nd assert we are getting the desired responses."
msgstr ""

msgid ""
"Let's implement the integration test in `test/kv_server_test.exs` as shown bel"
"ow:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule KVServerTest do\n"
"  use ExUnit.Case"
msgstr ""

msgid ""
"  setup do\n"
"    Application.stop(:kv)\n"
"    :ok = Application.start(:kv)\n"
"  end"
msgstr ""

msgid ""
"  setup do\n"
"    opts = [:binary, packet: :line, active: false]\n"
"    {:ok, socket} = :gen_tcp.connect('localhost', 4040, opts)\n"
"    %{socket: socket}\n"
"  end"
msgstr ""

msgid ""
"  test \"server interaction\", %{socket: socket} do\n"
"    assert send_and_recv(socket, \"UNKNOWN shopping\n"
"\") ==\n"
"           \"UNKNOWN COMMAND\n"
"\""
msgstr ""

msgid ""
"    assert send_and_recv(socket, \"GET shopping eggs\n"
"\") ==\n"
"           \"NOT FOUND\n"
"\""
msgstr ""

msgid ""
"    assert send_and_recv(socket, \"CREATE shopping\n"
"\") ==\n"
"           \"OK\n"
"\""
msgstr ""

msgid ""
"    assert send_and_recv(socket, \"PUT shopping eggs 3\n"
"\") ==\n"
"           \"OK\n"
"\""
msgstr ""

msgid ""
"    # GET returns two lines\n"
"    assert send_and_recv(socket, \"GET shopping eggs\n"
"\") == \"3\n"
"\"\n"
"    assert send_and_recv(socket, \"\") == \"OK\n"
"\""
msgstr ""

msgid ""
"    assert send_and_recv(socket, \"DELETE shopping eggs\n"
"\") ==\n"
"           \"OK\n"
"\""
msgstr ""

msgid ""
"    # GET returns two lines\n"
"    assert send_and_recv(socket, \"GET shopping eggs\n"
"\") == \"\n"
"\"\n"
"    assert send_and_recv(socket, \"\") == \"OK\n"
"\"\n"
"  end"
msgstr ""

msgid ""
"  defp send_and_recv(socket, command) do\n"
"    :ok = :gen_tcp.send(socket, command)\n"
"    {:ok, data} = :gen_tcp.recv(socket, 0, 1000)\n"
"    data\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"Our integration test checks all server interaction, including unknown commands"
" and not found errors. It is worth noting that, as with <abbr title=\"Erlang Te"
"rm Storage\">ETS</abbr> tables and linked processes, there is no need to close "
"the socket. Once the test process exits, the socket is automatically closed."
msgstr ""

msgid ""
"This time, since our test relies on global data, we have not given `async: tru"
"e` to `use ExUnit.Case`. Furthermore, in order to guarantee our test is always"
" in a clean state, we stop and start the `:kv` application before each test. I"
"n fact, stopping the `:kv` application even prints a warning on the terminal:"
msgstr ""

msgid ""
"```\n"
"18:12:10.698 [info] Application kv exited: :stopped\n"
"```"
msgstr ""

msgid ""
"To avoid printing log messages during tests, ExUnit provides a neat feature ca"
"lled `:capture_log`. By setting `@tag :capture_log` before each test or `@modu"
"letag :capture_log` for the whole test case, ExUnit will automatically capture"
" anything that is logged while the test runs. In case our test fails, the capt"
"ured logs will be printed alongside the ExUnit report."
msgstr ""

msgid "Between `use ExUnit.Case` and setup, add the following call:"
msgstr ""

msgid ""
"```elixir\n"
"@moduletag :capture_log\n"
"```"
msgstr ""

msgid "In case the test crashes, you will see a report as follows:"
msgstr ""

msgid ""
"```\n"
"  1) test server interaction (KVServerTest)\n"
"     test/kv_server_test.exs:17\n"
"     ** (RuntimeError) oops\n"
"     stacktrace:\n"
"       test/kv_server_test.exs:29"
msgstr ""

msgid "     The following output was logged:"
msgstr ""

msgid ""
"     13:44:10.035 [info]  Application kv exited: :stopped\n"
"```"
msgstr ""

msgid ""
"With this simple integration test, we start to see why integration tests may b"
"e slow. Not only this test cannot run asynchronously, it also requires the exp"
"ensive setup of stopping and starting the `:kv` application."
msgstr ""

msgid ""
"At the end of the day, it is up to you and your team to figure out the best te"
"sting strategy for your applications. You need to balance code quality, confid"
"ence, and test suite runtime. For example, we may start with testing the serve"
"r only with integration tests, but if the server continues to grow in future r"
"eleases, or it becomes a part of the application with frequent bugs, it is imp"
"ortant to consider breaking it apart and writing more intensive unit tests tha"
"t don't have the weight of an integration test."
msgstr ""

msgid ""
"In the next chapter, we will finally make our system distributed by adding a b"
"ucket routing mechanism. We'll also learn about application configuration."
msgstr ""
