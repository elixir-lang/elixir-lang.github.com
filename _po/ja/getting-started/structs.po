msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2018-07-27 22:30+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Structs\n"
"redirect_from: /getting-started/struct.html\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid "In [chapter 7](/getting-started/keywords-and-maps.html) we learned about maps:"
msgstr ""

msgid ""
"```iex\n"
"iex> map = %{a: 1, b: 2}\n"
"%{a: 1, b: 2}\n"
"iex> map[:a]\n"
"1\n"
"iex> %{map | a: 3}\n"
"%{a: 3, b: 2}\n"
"```"
msgstr ""

msgid ""
"Structs are extensions built on top of maps that provide compile-time checks a"
"nd default values."
msgstr ""

msgid "## Defining structs"
msgstr ""

msgid "To define a struct, the `defstruct` construct is used:"
msgstr ""

msgid ""
"```iex\n"
"iex> defmodule User do\n"
"...>   defstruct name: \"John\", age: 27\n"
"...> end\n"
"```"
msgstr ""

msgid ""
"The keyword list used with `defstruct` defines what fields the struct will hav"
"e along with their default values."
msgstr ""

msgid ""
"Structs take the name of the module they're defined in. In the example above, "
"we defined a struct named `User`."
msgstr ""

msgid ""
"We can now create `User` structs by using a syntax similar to the one used to "
"create maps:"
msgstr ""

msgid ""
"```iex\n"
"iex> %User{}\n"
"%User{age: 27, name: \"John\"}\n"
"iex> %User{name: \"Jane\"}\n"
"%User{age: 27, name: \"Jane\"}\n"
"```"
msgstr ""

msgid ""
"Structs provide *compile-time* guarantees that only the fields (and *all* of t"
"hem) defined through `defstruct` will be allowed to exist in a struct:"
msgstr ""

msgid ""
"```iex\n"
"iex> %User{oops: :field}\n"
"** (KeyError) key :oops not found in: %User{age: 27, name: \"John\"}\n"
"```"
msgstr ""

msgid "## Accessing and updating structs"
msgstr ""

msgid ""
"When we discussed maps, we showed how we can access and update the fields of a"
" map. The same techniques (and the same syntax) apply to structs as well:"
msgstr ""

msgid ""
"```iex\n"
"iex> john = %User{}\n"
"%User{age: 27, name: \"John\"}\n"
"iex> john.name\n"
"\"John\"\n"
"iex> jane = %{john | name: \"Jane\"}\n"
"%User{age: 27, name: \"Jane\"}\n"
"iex> %{jane | oops: :field}\n"
"** (KeyError) key :oops not found in: %User{age: 27, name: \"Jane\"}\n"
"```"
msgstr ""

msgid ""
"When using the update syntax (`|`), the <abbr title=\"Virtual Machine\">VM</abbr"
"> is aware that no new keys will be added to the struct, allowing the maps und"
"erneath to share their structure in memory. In the example above, both `john` "
"and `jane` share the same key structure in memory."
msgstr ""

msgid ""
"Structs can also be used in pattern matching, both for matching on the value o"
"f specific keys as well as for ensuring that the matching value is a struct of"
" the same type as the matched value."
msgstr ""

msgid ""
"```iex\n"
"iex> %User{name: name} = john\n"
"%User{age: 27, name: \"John\"}\n"
"iex> name\n"
"\"John\"\n"
"iex> %User{} = %{}\n"
"** (MatchError) no match of right hand side value: %{}\n"
"```"
msgstr ""

msgid "## Structs are bare maps underneath"
msgstr ""

msgid ""
"In the example above, pattern matching works because underneath structs are ba"
"re maps with a fixed set of fields. As maps, structs store a \"special\" field n"
"amed `__struct__` that holds the name of the struct:"
msgstr ""

msgid ""
"```iex\n"
"iex> is_map(john)\n"
"true\n"
"iex> john.__struct__\n"
"User\n"
"```"
msgstr ""

msgid ""
"Notice that we referred to structs as **bare** maps because none of the protoc"
"ols implemented for maps are available for structs. For example, you can neith"
"er enumerate nor access a struct:"
msgstr ""

msgid ""
"```iex\n"
"iex> john = %User{}\n"
"%User{age: 27, name: \"John\"}\n"
"iex> john[:name]\n"
"** (UndefinedFunctionError) function User.fetch/2 is undefined (User does not "
"implement the Access behaviour)\n"
"             User.fetch(%User{age: 27, name: \"John\"}, :name)\n"
"iex> Enum.each john, fn({field, value}) -> IO.puts(value) end\n"
"** (Protocol.UndefinedError) protocol Enumerable not implemented for %User{age"
": 27, name: \"John\"}\n"
"```"
msgstr ""

msgid ""
"However, since structs are just maps, they work with the functions from the `M"
"ap` module:"
msgstr ""

msgid ""
"```iex\n"
"iex> jane = Map.put(%User{}, :name, \"Jane\")\n"
"%User{age: 27, name: \"Jane\"}\n"
"iex> Map.merge(jane, %User{name: \"John\"})\n"
"%User{age: 27, name: \"John\"}\n"
"iex> Map.keys(jane)\n"
"[:__struct__, :age, :name]\n"
"```"
msgstr ""

msgid ""
"Structs alongside protocols provide one of the most important features for Eli"
"xir developers: data polymorphism. That's what we will explore in the next cha"
"pter."
msgstr ""

msgid "## Default values and required keys"
msgstr ""

msgid ""
"If you don't specify a default key value when defining a struct, `nil` will be"
" assumed:"
msgstr ""

msgid ""
"```iex\n"
"iex> defmodule Product do\n"
"...>   defstruct [:name]\n"
"...> end\n"
"iex> %Product{}\n"
"%Product{name: nil}\n"
"```"
msgstr ""

msgid ""
"You can also enforce that certain keys have to be specified when creating the "
"struct:"
msgstr ""

msgid ""
"```iex\n"
"iex> defmodule Car do\n"
"...>   @enforce_keys [:make]\n"
"...>   defstruct [:model, :make]\n"
"...> end\n"
"iex> %Car{}\n"
"** (ArgumentError) the following keys must also be given when building struct "
"Car: [:make]\n"
"    expanding struct: Car.__struct__/1\n"
"```"
msgstr ""
