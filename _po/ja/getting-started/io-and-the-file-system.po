msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2018-07-27 22:30+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: IO and the file system\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid ""
"This chapter is a quick introduction to input/output mechanisms and file-syste"
"m-related tasks, as well as to related modules like [`IO`](https://hexdocs.pm/"
"elixir/IO.html), [`File`](https://hexdocs.pm/elixir/File.html) and [`Path`](ht"
"tps://hexdocs.pm/elixir/Path.html)."
msgstr ""

msgid ""
"We had originally sketched this chapter to come much earlier in the getting st"
"arted guide. However, we noticed the IO system provides a great opportunity to"
" shed some light on some philosophies and curiosities of Elixir and the <abbr "
"title=\"Virtual Machine\">VM</abbr>."
msgstr ""

msgid "## The `IO` module"
msgstr ""

msgid ""
"The [`IO`](https://hexdocs.pm/elixir/IO.html) module is the main mechanism in "
"Elixir for reading and writing to standard input/output (`:stdio`), standard e"
"rror (`:stderr`), files, and other IO devices. Usage of the module is pretty s"
"traightforward:"
msgstr ""

msgid ""
"```iex\n"
"iex> IO.puts \"hello world\"\n"
"hello world\n"
":ok\n"
"iex> IO.gets \"yes or no? \"\n"
"yes or no? yes\n"
"\"yes\n"
"\"\n"
"```"
msgstr ""

msgid ""
"By default, functions in the `IO` module read from the standard input and writ"
"e to the standard output. We can change that by passing, for example, `:stderr"
"` as an argument (in order to write to the standard error device):"
msgstr ""

msgid ""
"```iex\n"
"iex> IO.puts :stderr, \"hello world\"\n"
"hello world\n"
":ok\n"
"```"
msgstr ""

msgid "## The `File` module"
msgstr ""

msgid ""
"The [`File`](https://hexdocs.pm/elixir/File.html) module contains functions th"
"at allow us to open files as IO devices. By default, files are opened in binar"
"y mode, which requires developers to use the specific `IO.binread/2` and `IO.b"
"inwrite/2` functions from the `IO` module:"
msgstr ""

msgid ""
"```iex\n"
"iex> {:ok, file} = File.open \"hello\", [:write]\n"
"{:ok, #PID<0.47.0>}\n"
"iex> IO.binwrite file, \"world\"\n"
":ok\n"
"iex> File.close file\n"
":ok\n"
"iex> File.read \"hello\"\n"
"{:ok, \"world\"}\n"
"```"
msgstr ""

msgid ""
"A file can also be opened with `:utf8` encoding, which tells the `File` module"
" to interpret the bytes read from the file as UTF-8-encoded bytes."
msgstr ""

msgid ""
"Besides functions for opening, reading and writing files, the `File` module ha"
"s many functions to work with the file system. Those functions are named after"
" their UNIX equivalents. For example, `File.rm/1` can be used to remove files,"
" `File.mkdir/1` to create directories, `File.mkdir_p/1` to create directories "
"and all their parent chain. There are even `File.cp_r/2` and `File.rm_rf/1` to"
" respectively copy and remove files and directories recursively (i.e., copying"
" and removing the contents of the directories too)."
msgstr ""

msgid ""
"You will also notice that functions in the `File` module have two variants: on"
"e \"regular\" variant and another variant with a trailing bang (`!`). For exampl"
"e, when we read the `\"hello\"` file in the example above, we use `File.read/1`."
" Alternatively, we can use `File.read!/1`:"
msgstr ""

msgid ""
"```iex\n"
"iex> File.read \"hello\"\n"
"{:ok, \"world\"}\n"
"iex> File.read! \"hello\"\n"
"\"world\"\n"
"iex> File.read \"unknown\"\n"
"{:error, :enoent}\n"
"iex> File.read! \"unknown\"\n"
"** (File.Error) could not read file \"unknown\": no such file or directory\n"
"```"
msgstr ""

msgid ""
"Notice that the version with `!` returns the contents of the file instead of a"
" tuple, and if anything goes wrong the function raises an error."
msgstr ""

msgid ""
"The version without `!` is preferred when you want to handle different outcome"
"s using pattern matching:"
msgstr ""

msgid ""
"```elixir\n"
"case File.read(file) do\n"
"  {:ok, body}      -> # do something with the `body`\n"
"  {:error, reason} -> # handle the error caused by `reason`\n"
"end\n"
"```"
msgstr ""

msgid ""
"However, if you expect the file to be there, the bang variation is more useful"
" as it raises a meaningful error message. Avoid writing:"
msgstr ""

msgid ""
"```elixir\n"
"{:ok, body} = File.read(file)\n"
"```"
msgstr ""

msgid ""
"as, in case of an error, `File.read/1` will return `{:error, reason}` and the "
"pattern matching will fail. You will still get the desired result (a raised er"
"ror), but the message will be about the pattern which doesn't match (thus bein"
"g cryptic in respect to what the error actually is about)."
msgstr ""

msgid ""
"Therefore, if you don't want to handle the error outcomes, prefer using `File."
"read!/1`."
msgstr ""

msgid "## The `Path` module"
msgstr ""

msgid ""
"The majority of the functions in the `File` module expect paths as arguments. "
"Most commonly, those paths will be regular binaries. The [`Path`](https://hexd"
"ocs.pm/elixir/Path.html) module provides facilities for working with such path"
"s:"
msgstr ""

msgid ""
"```iex\n"
"iex> Path.join(\"foo\", \"bar\")\n"
"\"foo/bar\"\n"
"iex> Path.expand(\"~/hello\")\n"
"\"/Users/jose/hello\"\n"
"```"
msgstr ""

msgid ""
"Using functions from the `Path` module as opposed to directly manipulating str"
"ings is preferred since the `Path` module takes care of different operating sy"
"stems transparently. Finally, keep in mind that Elixir will automatically conv"
"ert slashes (`/`) into backslashes (`\\`) on Windows when performing file opera"
"tions."
msgstr ""

msgid ""
"With this, we have covered the main modules that Elixir provides for dealing w"
"ith IO and interacting with the file system. In the next sections, we will dis"
"cuss some advanced topics regarding IO. Those sections are not necessary in or"
"der to write Elixir code, so feel free to skip them, but they do provide a nic"
"e overview of how the IO system is implemented in the <abbr title=\"Virtual Mac"
"hine\">VM</abbr> and other curiosities."
msgstr ""

msgid "## Processes and group leaders"
msgstr ""

msgid "You may have noticed that `File.open/2` returns a tuple like `{:ok, pid}`:"
msgstr ""

msgid ""
"```iex\n"
"iex> {:ok, file} = File.open \"hello\", [:write]\n"
"{:ok, #PID<0.47.0>}\n"
"```"
msgstr ""

msgid ""
"That happens because the `IO` module actually works with processes (see [chapt"
"er 11](/getting-started/processes.html)). When you write `IO.write(pid, binary"
")`, the `IO` module will send a message to the process identified by `pid` wit"
"h the desired operation. Let's see what happens if we use our own process:"
msgstr ""

msgid ""
"```iex\n"
"iex> pid = spawn fn ->\n"
"...>  receive do: (msg -> IO.inspect msg)\n"
"...> end\n"
"#PID<0.57.0>\n"
"iex> IO.write(pid, \"hello\")\n"
"{:io_request, #PID<0.41.0>, #Reference<0.0.8.91>,\n"
" {:put_chars, :unicode, \"hello\"}}\n"
"** (ErlangError) erlang error: :terminated\n"
"```"
msgstr ""

msgid ""
"After `IO.write/2`, we can see the request sent by the `IO` module (a four-ele"
"ments tuple) printed out. Soon after that, we see that it fails since the `IO`"
" module expected some kind of result that we did not supply."
msgstr ""

msgid ""
"The [`StringIO`](https://hexdocs.pm/elixir/StringIO.html) module provides an i"
"mplementation of the `IO` device messages on top of strings:"
msgstr ""

msgid ""
"```iex\n"
"iex> {:ok, pid} = StringIO.open(\"hello\")\n"
"{:ok, #PID<0.43.0>}\n"
"iex> IO.read(pid, 2)\n"
"\"he\"\n"
"```"
msgstr ""

msgid ""
"By modeling IO devices with processes, the Erlang <abbr title=\"Virtual Machine"
"\">VM</abbr> allows different nodes in the same network to exchange file proces"
"ses in order to read/write files in between nodes. Of all IO devices, there is"
" one that is special to each process: the **group leader**."
msgstr ""

msgid ""
"When you write to `:stdio`, you are actually sending a message to the group le"
"ader, which writes to the standard-output file descriptor:"
msgstr ""

msgid ""
"```iex\n"
"iex> IO.puts :stdio, \"hello\"\n"
"hello\n"
":ok\n"
"iex> IO.puts Process.group_leader, \"hello\"\n"
"hello\n"
":ok\n"
"```"
msgstr ""

msgid ""
"The group leader can be configured per process and is used in different situat"
"ions. For example, when executing code in a remote terminal, it guarantees mes"
"sages in a remote node are redirected and printed in the terminal that trigger"
"ed the request."
msgstr ""

msgid "## `iodata` and `chardata`"
msgstr ""

msgid ""
"In all of the examples above, we used binaries when writing to files. In the c"
"hapter [\"Binaries, strings and char lists\"](/getting-started/binaries-strings-"
"and-char-lists.html), we mentioned how strings are made of bytes while char li"
"sts are lists with Unicode codepoints."
msgstr ""

msgid ""
"The functions in `IO` and `File` also allow lists to be given as arguments. No"
"t only that, they also allow a mixed list of lists, integers, and binaries to "
"be given:"
msgstr ""

msgid ""
"```iex\n"
"iex> IO.puts 'hello world'\n"
"hello world\n"
":ok\n"
"iex> IO.puts ['hello', ?\\s, \"world\"]\n"
"hello world\n"
":ok\n"
"```"
msgstr ""

msgid ""
"However, using lists in IO operations requires some attention. A list may repr"
"esent either a bunch of bytes or a bunch of characters and which one to use de"
"pends on the encoding of the IO device. If the file is opened without encoding"
", the file is expected to be in raw mode, and the functions in the `IO` module"
" starting with `bin*` must be used. Those functions expect an `iodata` as an a"
"rgument; i.e., they expect a list of integers representing bytes and binaries "
"to be given."
msgstr ""

msgid ""
"On the other hand, `:stdio` and files opened with `:utf8` encoding work with t"
"he remaining functions in the `IO` module. Those functions expect a `char_data"
"` as an argument, that is, a list of characters or strings."
msgstr ""

msgid ""
"Although this is a subtle difference, you only need to worry about these detai"
"ls if you intend to pass lists to those functions. Binaries are already repres"
"ented by the underlying bytes and as such their representation is always \"raw\""
"."
msgstr ""

msgid ""
"This finishes our tour of IO devices and IO related functionality. We have lea"
"rned about four Elixir modules - [`IO`](https://hexdocs.pm/elixir/IO.html), [`"
"File`](https://hexdocs.pm/elixir/File.html), [`Path`](https://hexdocs.pm/elixi"
"r/Path.html) and [`StringIO`](https://hexdocs.pm/elixir/StringIO.html) - as we"
"ll as how the <abbr title=\"Virtual Machine\">VM</abbr> uses processes for the u"
"nderlying IO mechanisms and how to use `chardata` and `iodata` for IO operatio"
"ns."
msgstr ""
