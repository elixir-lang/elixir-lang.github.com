msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Basic operators\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid ""
"In the [previous chapter](/getting-started/basic-types.html), we saw Elixir pr"
"ovides `+`, `-`, `*`, `/` as arithmetic operators, plus the functions `div/2` "
"and `rem/2` for integer division and remainder."
msgstr ""

msgid "Elixir also provides `++` and `--` to manipulate lists:"
msgstr ""

msgid ""
"```iex\n"
"iex> [1, 2, 3] ++ [4, 5, 6]\n"
"[1, 2, 3, 4, 5, 6]\n"
"iex> [1, 2, 3] -- [2]\n"
"[1, 3]\n"
"```"
msgstr ""

msgid "String concatenation is done with `<>`:"
msgstr ""

msgid ""
"```iex\n"
"iex> \"foo\" <> \"bar\"\n"
"\"foobar\"\n"
"```"
msgstr ""

msgid ""
"Elixir also provides three boolean operators: `or`, `and` and `not`. These ope"
"rators are strict in the sense that they expect a boolean (`true` or `false`) "
"as their first argument:"
msgstr ""

msgid ""
"```iex\n"
"iex> true and true\n"
"true\n"
"iex> false or is_atom(:example)\n"
"true\n"
"```"
msgstr ""

msgid "Providing a non-boolean will raise an exception:"
msgstr ""

msgid ""
"```iex\n"
"iex> 1 and true\n"
"** (BadBooleanError) expected a boolean on left-side of \"and\", got: 1\n"
"```"
msgstr ""

msgid ""
"`or` and `and` are short-circuit operators. They only execute the right side i"
"f the left side is not enough to determine the result:"
msgstr ""

msgid ""
"```iex\n"
"iex> false and raise(\"This error will never be raised\")\n"
"false\n"
"iex> true or raise(\"This error will never be raised\")\n"
"true\n"
"```"
msgstr ""

msgid ""
"> Note: If you are an Erlang developer, `and` and `or` in Elixir actually map "
"to the `andalso` and `orelse` operators in Erlang."
msgstr ""

msgid ""
"Besides these boolean operators, Elixir also provides `||`, `&&` and `!` which"
" accept arguments of any type. For these operators, all values except `false` "
"and `nil` will evaluate to true:"
msgstr ""

msgid ""
"```iex\n"
"# or\n"
"iex> 1 || true\n"
"1\n"
"iex> false || 11\n"
"11"
msgstr ""

msgid ""
"# and\n"
"iex> nil && 13\n"
"nil\n"
"iex> true && 17\n"
"17"
msgstr ""

msgid ""
"# !\n"
"iex> !true\n"
"false\n"
"iex> !1\n"
"false\n"
"iex> !nil\n"
"true\n"
"```"
msgstr ""

msgid ""
"As a rule of thumb, use `and`, `or` and `not` when you are expecting booleans."
" If any of the arguments are non-boolean, use `&&`, `||` and `!`."
msgstr ""

msgid ""
"Elixir also provides `==`, `!=`, `===`, `!==`, `<=`, `>=`, `<`, and `>` as com"
"parison operators:"
msgstr ""

msgid ""
"```iex\n"
"iex> 1 == 1\n"
"true\n"
"iex> 1 != 2\n"
"true\n"
"iex> 1 < 2\n"
"true\n"
"```"
msgstr ""

msgid ""
"The difference between `==` and `===` is that the latter is more strict when c"
"omparing integers and floats:"
msgstr ""

msgid ""
"```iex\n"
"iex> 1 == 1.0\n"
"true\n"
"iex> 1 === 1.0\n"
"false\n"
"```"
msgstr ""

msgid "In Elixir, we can compare two different data types:"
msgstr ""

msgid ""
"```iex\n"
"iex> 1 < :atom\n"
"true\n"
"```"
msgstr ""

msgid ""
"The reason we can compare different data types is pragmatism. Sorting algorith"
"ms don't need to worry about different data types in order to sort. The overal"
"l sorting order is defined below:"
msgstr ""

msgid ""
"    number < atom < reference < function < port < pid < tuple < map < list < b"
"itstring"
msgstr ""

msgid ""
"You don't actually need to memorize this ordering, it's enough to know that th"
"is ordering exists."
msgstr ""

msgid ""
"For reference information about operators (and ordering), check the [reference"
" page on operators](/docs/master/elixir/operators.html)."
msgstr ""

msgid ""
"In the next chapter, we are going to discuss some basic functions, data type c"
"onversions, and a bit of control flow."
msgstr ""
