msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Modules and Functions\n"
"redirect_from: /getting-started/modules.html\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid ""
"In Elixir we group several functions into modules. We've already used many dif"
"ferent modules in the previous chapters such as [the `String` module](https://"
"hexdocs.pm/elixir/String.html):"
msgstr ""

msgid ""
"```iex\n"
"iex> String.length(\"hello\")\n"
"5\n"
"```"
msgstr ""

msgid ""
"In order to create our own modules in Elixir, we use the `defmodule` macro. We"
" use the `def` macro to define functions in that module:"
msgstr ""

msgid ""
"```iex\n"
"iex> defmodule Math do\n"
"...>   def sum(a, b) do\n"
"...>     a + b\n"
"...>   end\n"
"...> end"
msgstr ""

msgid ""
"iex> Math.sum(1, 2)\n"
"3\n"
"```"
msgstr ""

msgid ""
"In the following sections, our examples are going to get longer in size, and i"
"t can be tricky to type them all in the shell. It's about time for us to learn"
" how to compile Elixir code and also how to run Elixir scripts."
msgstr ""

msgid "## Compilation"
msgstr ""

msgid ""
"Most of the time it is convenient to write modules into files so they can be c"
"ompiled and reused. Let's assume we have a file named `math.ex` with the follo"
"wing contents:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Math do\n"
"  def sum(a, b) do\n"
"    a + b\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid "This file can be compiled using `elixirc`:"
msgstr ""

msgid ""
"```bash\n"
"$ elixirc math.ex\n"
"```"
msgstr ""

msgid ""
"This will generate a file named `Elixir.Math.beam` containing the bytecode for"
" the defined module. If we start `iex` again, our module definition will be av"
"ailable (provided that `iex` is started in the same directory the bytecode fil"
"e is in):"
msgstr ""

msgid ""
"```iex\n"
"iex> Math.sum(1, 2)\n"
"3\n"
"```"
msgstr ""

msgid "Elixir projects are usually organized into three directories:"
msgstr ""

msgid ""
"* ebin - contains the compiled bytecode\n"
"* lib - contains elixir code (usually `.ex` files)\n"
"* test - contains tests (usually `.exs` files)"
msgstr ""

msgid ""
"When working on actual projects, the build tool called `mix` will be responsib"
"le for compiling and setting up the proper paths for you. For learning purpose"
"s, Elixir also supports a scripted mode which is more flexible and does not ge"
"nerate any compiled artifacts."
msgstr ""

msgid "## Scripted mode"
msgstr ""

msgid ""
"In addition to the Elixir file extension `.ex`, Elixir also supports `.exs` fi"
"les for scripting. Elixir treats both files exactly the same way, the only dif"
"ference is in intention. `.ex` files are meant to be compiled while `.exs` fil"
"es are used for scripting. When executed, both extensions compile and load the"
"ir modules into memory, although only `.ex` files write their bytecode to disk"
" in the format of `.beam` files."
msgstr ""

msgid "For instance, we can create a file called `math.exs`:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Math do\n"
"  def sum(a, b) do\n"
"    a + b\n"
"  end\n"
"end"
msgstr ""

msgid ""
"IO.puts Math.sum(1, 2)\n"
"```"
msgstr ""

msgid "And execute it as:"
msgstr ""

msgid ""
"```bash\n"
"$ elixir math.exs\n"
"```"
msgstr ""

msgid ""
"The file will be compiled in memory and executed, printing \"3\" as the result. "
"No bytecode file will be created. In the following examples, we recommend you "
"write your code into script files and execute them as shown above."
msgstr ""

msgid "## Named functions"
msgstr ""

msgid ""
"Inside a module, we can define functions with `def/2` and private functions wi"
"th `defp/2`. A function defined with `def/2` can be invoked from other modules"
" while a private function can only be invoked locally."
msgstr ""

msgid ""
"```elixir\n"
"defmodule Math do\n"
"  def sum(a, b) do\n"
"    do_sum(a, b)\n"
"  end"
msgstr ""

msgid ""
"  defp do_sum(a, b) do\n"
"    a + b\n"
"  end\n"
"end"
msgstr ""

msgid ""
"IO.puts Math.sum(1, 2)    #=> 3\n"
"IO.puts Math.do_sum(1, 2) #=> ** (UndefinedFunctionError)\n"
"```"
msgstr ""

msgid ""
"Function declarations also support guards and multiple clauses. If a function "
"has several clauses, Elixir will try each clause until it finds one that match"
"es. Here is an implementation of a function that checks if the given number is"
" zero or not:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Math do\n"
"  def zero?(0) do\n"
"    true\n"
"  end"
msgstr ""

msgid ""
"  def zero?(x) when is_integer(x) do\n"
"    false\n"
"  end\n"
"end"
msgstr ""

msgid ""
"IO.puts Math.zero?(0)         #=> true\n"
"IO.puts Math.zero?(1)         #=> false\n"
"IO.puts Math.zero?([1, 2, 3]) #=> ** (FunctionClauseError)\n"
"IO.puts Math.zero?(0.0)       #=> ** (FunctionClauseError)\n"
"```"
msgstr ""

msgid "Giving an argument that does not match any of the clauses raises an error."
msgstr ""

msgid ""
"Similar to constructs like `if`, named functions support both `do:` and `do`/`"
"end` block syntax, as [we learned `do`/`end` is a convenient syntax for the ke"
"yword list format](/getting-started/case-cond-and-if.html#doend-blocks). For e"
"xample, we can edit `math.exs` to look like this:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Math do\n"
"  def zero?(0), do: true\n"
"  def zero?(x) when is_integer(x), do: false\n"
"end\n"
"```"
msgstr ""

msgid ""
"And it will provide the same behaviour. You may use `do:` for one-liners but a"
"lways use `do`/`end` for functions spanning multiple lines."
msgstr ""

msgid "## Function capturing"
msgstr ""

msgid ""
"Throughout this tutorial, we have been using the notation `name/arity` to refe"
"r to functions. It happens that this notation can actually be used to retrieve"
" a named function as a function type. Start `iex`, running the `math.exs` file"
" defined above:"
msgstr ""

msgid ""
"```bash\n"
"$ iex math.exs\n"
"```"
msgstr ""

msgid ""
"```iex\n"
"iex> Math.zero?(0)\n"
"true\n"
"iex> fun = &Math.zero?/1\n"
"&Math.zero?/1\n"
"iex> is_function(fun)\n"
"true\n"
"iex> fun.(0)\n"
"true\n"
"```"
msgstr ""

msgid ""
"Remember Elixir makes a distinction between anonymous functions and named func"
"tions, where the former must be invoked with a dot (`.`) between the variable "
"name and parentheses. The capture operator bridges this gap by allowing named "
"functions to be assigned to variables and passed as arguments in the same way "
"we assign, invoke and pass anonymous functions."
msgstr ""

msgid ""
"Local or imported functions, like `is_function/1`, can be captured without the"
" module:"
msgstr ""

msgid ""
"```iex\n"
"iex> &is_function/1\n"
"&:erlang.is_function/1\n"
"iex> (&is_function/1).(fun)\n"
"true\n"
"```"
msgstr ""

msgid "Note the capture syntax can also be used as a shortcut for creating functions:"
msgstr ""

msgid ""
"```iex\n"
"iex> fun = &(&1 + 1)\n"
"#Function<6.71889879/1 in :erl_eval.expr/5>\n"
"iex> fun.(1)\n"
"2\n"
"```"
msgstr ""

msgid ""
"The `&1` represents the first argument passed into the function. `&(&1+1)` abo"
"ve is exactly the same as `fn x -> x + 1 end`. The syntax above is useful for "
"short function definitions."
msgstr ""

msgid ""
"If you want to capture a function from a module, you can do `&Module.function("
")`:"
msgstr ""

msgid ""
"```iex\n"
"iex> fun = &List.flatten(&1, &2)\n"
"&List.flatten/2\n"
"iex> fun.([1, [[2], 3]], [4, 5])\n"
"[1, 2, 3, 4, 5]\n"
"```"
msgstr ""

msgid ""
"`&List.flatten(&1, &2)` is the same as writing `fn(list, tail) -> List.flatten"
"(list, tail) end` which in this case is equivalent to `&List.flatten/2`. You c"
"an read more about the capture operator `&` in [the `Kernel.SpecialForms` docu"
"mentation](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#&/1)."
msgstr ""

msgid "## Default arguments"
msgstr ""

msgid "Named functions in Elixir also support default arguments:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Concat do\n"
"  def join(a, b, sep \\\\ \" \") do\n"
"    a <> sep <> b\n"
"  end\n"
"end"
msgstr ""

msgid ""
"IO.puts Concat.join(\"Hello\", \"world\")      #=> Hello world\n"
"IO.puts Concat.join(\"Hello\", \"world\", \"_\") #=> Hello_world\n"
"```"
msgstr ""

msgid ""
"Any expression is allowed to serve as a default value, but it won't be evaluat"
"ed during the function definition. Every time the function is invoked and any "
"of its default values have to be used, the expression for that default value w"
"ill be evaluated:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule DefaultTest do\n"
"  def dowork(x \\\\ \"hello\") do\n"
"    x\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"```iex\n"
"iex> DefaultTest.dowork\n"
"\"hello\"\n"
"iex> DefaultTest.dowork 123\n"
"123\n"
"iex> DefaultTest.dowork\n"
"\"hello\"\n"
"```"
msgstr ""

msgid ""
"If a function with default values has multiple clauses, it is required to crea"
"te a function head (without an actual body) for declaring defaults:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Concat do\n"
"  def join(a, b \\\\ nil, sep \\\\ \" \")"
msgstr ""

msgid ""
"  def join(a, b, _sep) when is_nil(b) do\n"
"    a\n"
"  end"
msgstr ""

msgid ""
"  def join(a, b, sep) do\n"
"    a <> sep <> b\n"
"  end\n"
"end"
msgstr ""

msgid ""
"IO.puts Concat.join(\"Hello\", \"world\")      #=> Hello world\n"
"IO.puts Concat.join(\"Hello\", \"world\", \"_\") #=> Hello_world\n"
"IO.puts Concat.join(\"Hello\")               #=> Hello\n"
"```"
msgstr ""

msgid ""
"When using default values, one must be careful to avoid overlapping function d"
"efinitions. Consider the following example:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Concat do\n"
"  def join(a, b) do\n"
"    IO.puts \"***First join\"\n"
"    a <> b\n"
"  end"
msgstr ""

msgid ""
"  def join(a, b, sep \\\\ \" \") do\n"
"    IO.puts \"***Second join\"\n"
"    a <> sep <> b\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"If we save the code above in a file named \"concat.ex\" and compile it, Elixir w"
"ill emit the following warning:"
msgstr ""

msgid ""
"    warning: this clause cannot match because a previous clause at line 2 alwa"
"ys matches"
msgstr ""

msgid ""
"The compiler is telling us that invoking the `join` function with two argument"
"s will always choose the first definition of `join` whereas the second one wil"
"l only be invoked when three arguments are passed:"
msgstr ""

msgid ""
"```bash\n"
"$ iex concat.exs\n"
"```"
msgstr ""

msgid ""
"```iex\n"
"iex> Concat.join \"Hello\", \"world\"\n"
"***First join\n"
"\"Helloworld\"\n"
"```"
msgstr ""

msgid ""
"```iex\n"
"iex> Concat.join \"Hello\", \"world\", \"_\"\n"
"***Second join\n"
"\"Hello_world\"\n"
"```"
msgstr ""

msgid ""
"This finishes our short introduction to modules. In the next chapters, we will"
" learn how to use named functions for recursion, explore Elixir lexical direct"
"ives that can be used for importing functions from other modules and discuss m"
"odule attributes."
msgstr ""
