msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: try, catch, and rescue\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid ""
"Elixir has three error mechanisms: errors, throws, and exits. In this chapter,"
" we will explore each of them and include remarks about when each should be us"
"ed."
msgstr ""

msgid "## Errors"
msgstr ""

msgid ""
"Errors (or *exceptions*) are used when exceptional things happen in the code. "
"A sample error can be retrieved by trying to add a number into an atom:"
msgstr ""

msgid ""
"```iex\n"
"iex> :foo + 1\n"
"** (ArithmeticError) bad argument in arithmetic expression\n"
"     :erlang.+(:foo, 1)\n"
"```"
msgstr ""

msgid "A runtime error can be raised any time by using `raise/1`:"
msgstr ""

msgid ""
"```iex\n"
"iex> raise \"oops\"\n"
"** (RuntimeError) oops\n"
"```"
msgstr ""

msgid ""
"Other errors can be raised with `raise/2` passing the error name and a list of"
" keyword arguments:"
msgstr ""

msgid ""
"```iex\n"
"iex> raise ArgumentError, message: \"invalid argument foo\"\n"
"** (ArgumentError) invalid argument foo\n"
"```"
msgstr ""

msgid ""
"You can also define your own errors by creating a module and using the `defexc"
"eption` construct inside it; this way, you'll create an error with the same na"
"me as the module it's defined in. The most common case is to define a custom e"
"xception with a message field:"
msgstr ""

msgid ""
"```iex\n"
"iex> defmodule MyError do\n"
"iex>   defexception message: \"default message\"\n"
"iex> end\n"
"iex> raise MyError\n"
"** (MyError) default message\n"
"iex> raise MyError, message: \"custom message\"\n"
"** (MyError) custom message\n"
"```"
msgstr ""

msgid "Errors can be **rescued** using the `try/rescue` construct:"
msgstr ""

msgid ""
"```iex\n"
"iex> try do\n"
"...>   raise \"oops\"\n"
"...> rescue\n"
"...>   e in RuntimeError -> e\n"
"...> end\n"
"%RuntimeError{message: \"oops\"}\n"
"```"
msgstr ""

msgid ""
"The example above rescues the runtime error and returns the error itself which"
" is then printed in the `iex` session."
msgstr ""

msgid "If you don't have any use for the error, you don't have to provide it:"
msgstr ""

msgid ""
"```iex\n"
"iex> try do\n"
"...>   raise \"oops\"\n"
"...> rescue\n"
"...>   RuntimeError -> \"Error!\"\n"
"...> end\n"
"\"Error!\"\n"
"```"
msgstr ""

msgid ""
"In practice, however, Elixir developers rarely use the `try/rescue` construct."
" For example, many languages would force you to rescue an error when a file ca"
"nnot be opened successfully. Elixir instead provides a `File.read/1` function "
"which returns a tuple containing information about whether the file was opened"
" successfully:"
msgstr ""

msgid ""
"```iex\n"
"iex> File.read \"hello\"\n"
"{:error, :enoent}\n"
"iex> File.write \"hello\", \"world\"\n"
":ok\n"
"iex> File.read \"hello\"\n"
"{:ok, \"world\"}\n"
"```"
msgstr ""

msgid ""
"There is no `try/rescue` here. In case you want to handle multiple outcomes of"
" opening a file, you can use pattern matching within the `case` construct:"
msgstr ""

msgid ""
"```iex\n"
"iex> case File.read \"hello\" do\n"
"...>   {:ok, body}      -> IO.puts \"Success: #{body}\"\n"
"...>   {:error, reason} -> IO.puts \"Error: #{reason}\"\n"
"...> end\n"
"```"
msgstr ""

msgid ""
"At the end of the day, it's up to your application to decide if an error while"
" opening a file is exceptional or not. That's why Elixir doesn't impose except"
"ions on `File.read/1` and many other functions. Instead, it leaves it up to th"
"e developer to choose the best way to proceed."
msgstr ""

msgid ""
"For the cases where you do expect a file to exist (and the lack of that file i"
"s truly an *error*) you may use `File.read!/1`:"
msgstr ""

msgid ""
"```iex\n"
"iex> File.read! \"unknown\"\n"
"** (File.Error) could not read file unknown: no such file or directory\n"
"    (elixir) lib/file.ex:272: File.read!/1\n"
"```"
msgstr ""

msgid ""
"Many functions in the standard library follow the pattern of having a counterp"
"art that raises an exception instead of returning tuples to match against. The"
" convention is to create a function (`foo`) which returns `{:ok, result}` or `"
"{:error, reason}` tuples and another function (`foo!`, same name but with a tr"
"ailing `!`) that takes the same arguments as `foo` but which raises an excepti"
"on if there's an error. `foo!` should return the result (not wrapped in a tupl"
"e) if everything goes fine. The [`File` module](https://hexdocs.pm/elixir/File"
".html) is a good example of this convention."
msgstr ""

msgid ""
"In Elixir, we avoid using `try/rescue` because **we don't use errors for contr"
"ol flow**. We take errors literally: they are reserved for unexpected and/or e"
"xceptional situations. In case you actually need flow control constructs, *thr"
"ows* should be used. That's what we are going to see next."
msgstr ""

msgid "## Throws"
msgstr ""

msgid ""
"In Elixir, a value can be thrown and later be caught. `throw` and `catch` are "
"reserved for situations where it is not possible to retrieve a value unless by"
" using `throw` and `catch`."
msgstr ""

msgid ""
"Those situations are quite uncommon in practice except when interfacing with l"
"ibraries that do not provide a proper API. For example, let's imagine the `Enu"
"m` module did not provide any API for finding a value and that we needed to fi"
"nd the first multiple of 13 in a list of numbers:"
msgstr ""

msgid ""
"```iex\n"
"iex> try do\n"
"...>   Enum.each -50..50, fn(x) ->\n"
"...>     if rem(x, 13) == 0, do: throw(x)\n"
"...>   end\n"
"...>   \"Got nothing\"\n"
"...> catch\n"
"...>   x -> \"Got #{x}\"\n"
"...> end\n"
"\"Got -39\"\n"
"```"
msgstr ""

msgid ""
"Since `Enum` *does* provide a proper API, in practice `Enum.find/2` is the way"
" to go:"
msgstr ""

msgid ""
"```iex\n"
"iex> Enum.find -50..50, &(rem(&1, 13) == 0)\n"
"-39\n"
"```"
msgstr ""

msgid "## Exits"
msgstr ""

msgid ""
"All Elixir code runs inside processes that communicate with each other. When a"
" process dies of \"natural causes\" (e.g., unhandled exceptions), it sends an `e"
"xit` signal. A process can also die by explicitly sending an exit signal:"
msgstr ""

msgid ""
"```iex\n"
"iex> spawn_link fn -> exit(1) end\n"
"** (EXIT from #PID<0.56.0>) evaluator process exited with reason: 1\n"
"```"
msgstr ""

msgid ""
"In the example above, the linked process died by sending an `exit` signal with"
" a value of 1. The Elixir shell automatically handles those messages and print"
"s them to the terminal."
msgstr ""

msgid "`exit` can also be \"caught\" using `try/catch`:"
msgstr ""

msgid ""
"```iex\n"
"iex> try do\n"
"...>   exit \"I am exiting\"\n"
"...> catch\n"
"...>   :exit, _ -> \"not really\"\n"
"...> end\n"
"\"not really\"\n"
"```"
msgstr ""

msgid ""
"Using `try/catch` is already uncommon and using it to catch exits is even rare"
"r."
msgstr ""

msgid ""
"`exit` signals are an important part of the fault tolerant system provided by "
"the Erlang <abbr title=\"Virtual Machine\">VM</abbr>. Processes usually run unde"
"r supervision trees which are themselves processes that listen to `exit` signa"
"ls from the supervised processes. Once an exit signal is received, the supervi"
"sion strategy kicks in and the supervised process is restarted."
msgstr ""

msgid ""
"It is exactly this supervision system that makes constructs like `try/catch` a"
"nd `try/rescue` so uncommon in Elixir. Instead of rescuing an error, we'd rath"
"er \"fail fast\" since the supervision tree will guarantee our application will "
"go back to a known initial state after the error."
msgstr ""

msgid "## After"
msgstr ""

msgid ""
"Sometimes it's necessary to ensure that a resource is cleaned up after some ac"
"tion that could potentially raise an error. The `try/after` construct allows y"
"ou to do that. For example, we can open a file and use an `after` clause to cl"
"ose it--even if something goes wrong:"
msgstr ""

msgid ""
"```iex\n"
"iex> {:ok, file} = File.open \"sample\", [:utf8, :write]\n"
"iex> try do\n"
"...>   IO.write file, \"olÃ¡\"\n"
"...>   raise \"oops, something went wrong\"\n"
"...> after\n"
"...>   File.close(file)\n"
"...> end\n"
"** (RuntimeError) oops, something went wrong\n"
"```"
msgstr ""

msgid ""
"The `after` clause will be executed regardless of whether or not the tried blo"
"ck succeeds. Note, however, that if a linked process exits,\n"
"this process will exit and the `after` clause will not get run. Thus `after` p"
"rovides only a soft guarantee. Luckily, files in Elixir are also linked to the"
" current processes and therefore they will always get closed if the current pr"
"ocess crashes, independent of the\n"
"`after` clause. You will find the same to be true for other resources like ETS"
" tables, sockets, ports and more."
msgstr ""

msgid ""
"Sometimes you may want to wrap the entire body of a function in a `try` constr"
"uct, often to guarantee some code will be executed afterwards. In such cases, "
"Elixir allows you to omit the `try` line:"
msgstr ""

msgid ""
"```iex\n"
"iex> defmodule RunAfter do\n"
"...>   def without_even_trying do\n"
"...>     raise \"oops\"\n"
"...>   after\n"
"...>     IO.puts \"cleaning up!\"\n"
"...>   end\n"
"...> end\n"
"iex> RunAfter.without_even_trying\n"
"cleaning up!\n"
"** (RuntimeError) oops\n"
"```"
msgstr ""

msgid ""
"Elixir will automatically wrap the function body in a `try` whenever one of `a"
"fter`, `rescue` or `catch` is specified."
msgstr ""

msgid "## Else"
msgstr ""

msgid ""
"If an `else` block is present, it will match on the results of the `try` block"
" whenever the `try` block finishes without a throw or an error."
msgstr ""

msgid ""
"```iex\n"
"iex> x = 2\n"
"2\n"
"iex> try do\n"
"...>   1 / x\n"
"...> rescue\n"
"...>   ArithmeticError ->\n"
"...>     :infinity\n"
"...> else\n"
"...>   y when y < 1 and y > -1 ->\n"
"...>     :small\n"
"...>   _ ->\n"
"...>     :large\n"
"...> end\n"
":small\n"
"```"
msgstr ""

msgid ""
"Exceptions in the `else` block are not caught. If no pattern inside the `else`"
" block matches, an exception will be raised; this exception is not caught by t"
"he current `try/catch/rescue/after` block."
msgstr ""

msgid "## Variables scope"
msgstr ""

msgid ""
"It is important to bear in mind that variables defined inside `try/catch/rescu"
"e/after` blocks do not leak to the outer context. This is because the `try` bl"
"ock may fail and as such the variables may never be bound in the first place. "
"In other words, this code is invalid:"
msgstr ""

msgid ""
"```iex\n"
"iex> try do\n"
"...>   raise \"fail\"\n"
"...>   what_happened = :did_not_raise\n"
"...> rescue\n"
"...>   _ -> what_happened = :rescued\n"
"...> end\n"
"iex> what_happened\n"
"** (RuntimeError) undefined function: what_happened/0\n"
"```"
msgstr ""

msgid "Instead, you can store the value of the `try` expression:"
msgstr ""

msgid ""
"```iex\n"
"iex> what_happened =\n"
"...>   try do\n"
"...>     raise \"fail\"\n"
"...>     :did_not_raise\n"
"...>   rescue\n"
"...>     _ -> :rescued\n"
"...>   end\n"
"iex> what_happened\n"
":rescued\n"
"```"
msgstr ""

msgid ""
"This finishes our introduction to `try`, `catch`, and `rescue`. You will find "
"they are used less frequently in Elixir than in other languages, although they"
" may be handy in some situations where a library or some particular code is no"
"t playing \"by the rules\"."
msgstr ""
