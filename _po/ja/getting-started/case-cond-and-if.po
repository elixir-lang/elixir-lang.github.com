msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2018-07-27 22:30+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: case, cond, and if\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid ""
"In this chapter, we will learn about the `case`, `cond`, and `if` control flow"
" structures."
msgstr ""

msgid "## `case`"
msgstr ""

msgid ""
"`case` allows us to compare a value against many patterns until we find a matc"
"hing one:"
msgstr ""

msgid ""
"```iex\n"
"iex> case {1, 2, 3} do\n"
"...>   {4, 5, 6} ->\n"
"...>     \"This clause won't match\"\n"
"...>   {1, x, 3} ->\n"
"...>     \"This clause will match and bind x to 2 in this clause\"\n"
"...>   _ ->\n"
"...>     \"This clause would match any value\"\n"
"...> end\n"
"\"This clause will match and bind x to 2 in this clause\"\n"
"```"
msgstr ""

msgid ""
"If you want to pattern match against an existing variable, you need to use the"
" `^` operator:"
msgstr ""

msgid ""
"```iex\n"
"iex> x = 1\n"
"1\n"
"iex> case 10 do\n"
"...>   ^x -> \"Won't match\"\n"
"...>   _ -> \"Will match\"\n"
"...> end\n"
"\"Will match\"\n"
"```"
msgstr ""

msgid "Clauses also allow extra conditions to be specified via guards:"
msgstr ""

msgid ""
"```iex\n"
"iex> case {1, 2, 3} do\n"
"...>   {1, x, 3} when x > 0 ->\n"
"...>     \"Will match\"\n"
"...>   _ ->\n"
"...>     \"Would match, if guard condition were not satisfied\"\n"
"...> end\n"
"\"Will match\"\n"
"```"
msgstr ""

msgid "The first clause above will only match when `x` is positive."
msgstr ""

msgid "Keep in mind errors in guards do not leak but simply make the guard fail:"
msgstr ""

msgid ""
"```iex\n"
"iex> hd(1)\n"
"** (ArgumentError) argument error\n"
"iex> case 1 do\n"
"...>   x when hd(x) -> \"Won't match\"\n"
"...>   x -> \"Got #{x}\"\n"
"...> end\n"
"\"Got 1\"\n"
"```"
msgstr ""

msgid "If none of the clauses match, an error is raised:"
msgstr ""

msgid ""
"```iex\n"
"iex> case :ok do\n"
"...>   :error -> \"Won't match\"\n"
"...> end\n"
"** (CaseClauseError) no case clause matching: :ok\n"
"```"
msgstr ""

msgid ""
"Consult [the full documentation for guards](https://hexdocs.pm/elixir/guards.h"
"tml) for more information about guards, how they are used, and what expression"
"s are allowed in them."
msgstr ""

msgid "Note anonymous functions can also have multiple clauses and guards:"
msgstr ""

msgid ""
"```iex\n"
"iex> f = fn\n"
"...>   x, y when x > 0 -> x + y\n"
"...>   x, y -> x * y\n"
"...> end\n"
"#Function<12.71889879/2 in :erl_eval.expr/5>\n"
"iex> f.(1, 3)\n"
"4\n"
"iex> f.(-1, 3)\n"
"-3\n"
"```"
msgstr ""

msgid ""
"The number of arguments in each anonymous function clause needs to be the same"
", otherwise an error is raised."
msgstr ""

msgid ""
"```iex\n"
"iex> f2 = fn\n"
"...>   x, y when x > 0 -> x + y\n"
"...>   x, y, z -> x * y + z\n"
"...> end\n"
"** (CompileError) iex:1: cannot mix clauses with different arities in function"
" definition\n"
"```"
msgstr ""

msgid "## `cond`"
msgstr ""

msgid ""
"`case` is useful when you need to match against different values. However, in "
"many circumstances, we want to check different conditions and find the first o"
"ne that evaluates to true. In such cases, one may use `cond`:"
msgstr ""

msgid ""
"```iex\n"
"iex> cond do\n"
"...>   2 + 2 == 5 ->\n"
"...>     \"This will not be true\"\n"
"...>   2 * 2 == 3 ->\n"
"...>     \"Nor this\"\n"
"...>   1 + 1 == 2 ->\n"
"...>     \"But this will\"\n"
"...> end\n"
"\"But this will\"\n"
"```"
msgstr ""

msgid ""
"This is equivalent to `else if` clauses in many imperative languages (although"
" used way less frequently here)."
msgstr ""

msgid ""
"If none of the conditions return true, an error (`CondClauseError`) is raised."
" For this reason, it may be necessary to add a final condition, equal to `true"
"`, which will always match:"
msgstr ""

msgid ""
"```iex\n"
"iex> cond do\n"
"...>   2 + 2 == 5 ->\n"
"...>     \"This is never true\"\n"
"...>   2 * 2 == 3 ->\n"
"...>     \"Nor this\"\n"
"...>   true ->\n"
"...>     \"This is always true (equivalent to else)\"\n"
"...> end\n"
"\"This is always true (equivalent to else)\"\n"
"```"
msgstr ""

msgid "Finally, note `cond` considers any value besides `nil` and `false` to be true:"
msgstr ""

msgid ""
"```iex\n"
"iex> cond do\n"
"...>   hd([1, 2, 3]) ->\n"
"...>     \"1 is considered as true\"\n"
"...> end\n"
"\"1 is considered as true\"\n"
"```"
msgstr ""

msgid "## `if` and `unless`"
msgstr ""

msgid ""
"Besides `case` and `cond`, Elixir also provides the macros `if/2` and `unless/"
"2` which are useful when you need to check for only one condition:"
msgstr ""

msgid ""
"```iex\n"
"iex> if true do\n"
"...>   \"This works!\"\n"
"...> end\n"
"\"This works!\"\n"
"iex> unless true do\n"
"...>   \"This will never be seen\"\n"
"...> end\n"
"nil\n"
"```"
msgstr ""

msgid ""
"If the condition given to `if/2` returns `false` or `nil`, the body given betw"
"een `do/end` is not executed and instead it returns `nil`. The opposite happen"
"s with `unless/2`."
msgstr ""

msgid "They also support `else` blocks:"
msgstr ""

msgid ""
"```iex\n"
"iex> if nil do\n"
"...>   \"This won't be seen\"\n"
"...> else\n"
"...>   \"This will\"\n"
"...> end\n"
"\"This will\"\n"
"```"
msgstr ""

msgid ""
"> Note: An interesting note regarding `if/2` and `unless/2` is that they are i"
"mplemented as macros in the language; they aren't special language constructs "
"as they would be in many languages. You can check the documentation and the so"
"urce of `if/2` in [the `Kernel` module docs](https://hexdocs.pm/elixir/Kernel."
"html). The `Kernel` module is also where operators like `+/2` and functions li"
"ke `is_function/2` are defined, all automatically imported and available in yo"
"ur code by default."
msgstr ""

msgid "## `do/end` blocks"
msgstr ""

msgid ""
"At this point, we have learned four control structures: `case`, `cond`, `if`, "
"and `unless`, and they were all wrapped in `do/end` blocks. It happens we coul"
"d also write `if` as follows:"
msgstr ""

msgid ""
"```iex\n"
"iex> if true, do: 1 + 2\n"
"3\n"
"```"
msgstr ""

msgid ""
"Notice how the example above has a comma between `true` and `do:`, that's beca"
"use it is using Elixir's regular syntax where each argument is separated by a "
"comma. We say this syntax is using *keyword lists*. We can pass `else` using k"
"eywords too:"
msgstr ""

msgid ""
"```iex\n"
"iex> if false, do: :this, else: :that\n"
":that\n"
"```"
msgstr ""

msgid ""
"`do/end` blocks are a syntactic convenience built on top of the keywords one. "
"That's why `do/end` blocks do not require a comma between the previous argumen"
"t and the block. They are useful exactly because they remove the verbosity whe"
"n writing blocks of code. These are equivalent:"
msgstr ""

msgid ""
"```iex\n"
"iex> if true do\n"
"...>   a = 1 + 2\n"
"...>   a + 10\n"
"...> end\n"
"13\n"
"iex> if true, do: (\n"
"...>   a = 1 + 2\n"
"...>   a + 10\n"
"...> )\n"
"13\n"
"```"
msgstr ""

msgid ""
"One thing to keep in mind when using `do/end` blocks is they are always bound "
"to the outermost function call. For example, the following expression:"
msgstr ""

msgid ""
"```iex\n"
"iex> is_number if true do\n"
"...>  1 + 2\n"
"...> end\n"
"** (CompileError) undefined function: is_number/2\n"
"```"
msgstr ""

msgid "Would be parsed as:"
msgstr ""

msgid ""
"```iex\n"
"iex> is_number(if true) do\n"
"...>  1 + 2\n"
"...> end\n"
"** (CompileError) undefined function: is_number/2\n"
"```"
msgstr ""

msgid ""
"which leads to an undefined function error because that invocation passes two "
"arguments, and `is_number/2` does not exist. The `if true` expression is inval"
"id in itself because it needs the block, but since the arity of `is_number/2` "
"does not match, Elixir does not even reach its evaluation."
msgstr ""

msgid "Adding explicit parentheses is enough to bind the block to `if`:"
msgstr ""

msgid ""
"```iex\n"
"iex> is_number(if true do\n"
"...>  1 + 2\n"
"...> end)\n"
"true\n"
"```"
msgstr ""

msgid ""
"Keyword lists play an important role in the language and are quite common in m"
"any functions and macros. We will explore them a bit more in a future chapter."
" Now it is time to talk about \"Binaries, strings, and char lists\"."
msgstr ""
