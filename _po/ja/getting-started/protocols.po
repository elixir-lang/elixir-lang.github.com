msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Protocols\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid ""
"Protocols are a mechanism to achieve polymorphism in Elixir. Dispatching on a "
"protocol is available to any data type as long as it implements the protocol. "
"Let's see an example."
msgstr ""

msgid ""
"In Elixir, we have two idioms for checking how many items there are in a data "
"structure: `length` and `size`. `length` means the information must be compute"
"d. For example, `length(list)` needs to traverse the whole list to calculate i"
"ts length. On the other hand, `tuple_size(tuple)` and `byte_size(binary)` do n"
"ot depend on the tuple and binary size as the size information is pre-computed"
" in the data structure."
msgstr ""

msgid ""
"Even if we have type-specific functions for getting the size built into Elixir"
" (such as `tuple_size/1`), we could implement a generic `Size` protocol that a"
"ll data structures for which size is pre-computed would implement."
msgstr ""

msgid "The protocol definition would look like this:"
msgstr ""

msgid ""
"```elixir\n"
"defprotocol Size do\n"
"  @doc \"Calculates the size (and not the length!) of a data structure\"\n"
"  def size(data)\n"
"end\n"
"```"
msgstr ""

msgid ""
"The `Size` protocol expects a function called `size` that receives one argumen"
"t (the data structure we want to know the size of) to be implemented. We can n"
"ow implement this protocol for the data structures that would have a compliant"
" implementation:"
msgstr ""

msgid ""
"```elixir\n"
"defimpl Size, for: BitString do\n"
"  def size(string), do: byte_size(string)\n"
"end"
msgstr ""

msgid ""
"defimpl Size, for: Map do\n"
"  def size(map), do: map_size(map)\n"
"end"
msgstr ""

msgid ""
"defimpl Size, for: Tuple do\n"
"  def size(tuple), do: tuple_size(tuple)\n"
"end\n"
"```"
msgstr ""

msgid ""
"We didn't implement the `Size` protocol for lists as there is no \"size\" inform"
"ation pre-computed for lists, and the length of a list has to be computed (wit"
"h `length/1`)."
msgstr ""

msgid ""
"Now with the protocol defined and implementations in hand, we can start using "
"it:"
msgstr ""

msgid ""
"```iex\n"
"iex> Size.size(\"foo\")\n"
"3\n"
"iex> Size.size({:ok, \"hello\"})\n"
"2\n"
"iex> Size.size(%{label: \"some label\"})\n"
"1\n"
"```"
msgstr ""

msgid "Passing a data type that doesn't implement the protocol raises an error:"
msgstr ""

msgid ""
"```iex\n"
"iex> Size.size([1, 2, 3])\n"
"** (Protocol.UndefinedError) protocol Size not implemented for [1, 2, 3]\n"
"```"
msgstr ""

msgid "It's possible to implement protocols for all Elixir data types:"
msgstr ""

msgid ""
"* `Atom`\n"
"* `BitString`\n"
"* `Float`\n"
"* `Function`\n"
"* `Integer`\n"
"* `List`\n"
"* `Map`\n"
"* `PID`\n"
"* `Port`\n"
"* `Reference`\n"
"* `Tuple`"
msgstr ""

msgid "## Protocols and structs"
msgstr ""

msgid ""
"The power of Elixir's extensibility comes when protocols and structs are used "
"together."
msgstr ""

msgid ""
"In the [previous chapter](/getting-started/structs.html), we have learned that"
" although structs are maps, they do not share protocol implementations with ma"
"ps. For example, [`MapSet`](https://hexdocs.pm/elixir/MapSet.html)s (sets base"
"d on maps) are implemented as structs. Let's try to use the `Size` protocol wi"
"th a `MapSet`:"
msgstr ""

msgid ""
"```iex\n"
"iex> Size.size(%{})\n"
"0\n"
"iex> set = %MapSet{} = MapSet.new\n"
"#MapSet<[]>\n"
"iex> Size.size(set)\n"
"** (Protocol.UndefinedError) protocol Size not implemented for #MapSet<[]>\n"
"```"
msgstr ""

msgid ""
"Instead of sharing protocol implementation with maps, structs require their ow"
"n protocol implementation. Since a `MapSet` has its size precomputed and acces"
"sible through `MapSet.size/1`, we can define a `Size` implementation for it:"
msgstr ""

msgid ""
"```elixir\n"
"defimpl Size, for: MapSet do\n"
"  def size(set), do: MapSet.size(set)\n"
"end\n"
"```"
msgstr ""

msgid ""
"If desired, you could come up with your own semantics for the size of your str"
"uct. Not only that, you could use structs to build more robust data types, lik"
"e queues, and implement all relevant protocols, such as `Enumerable` and possi"
"bly `Size`, for this data type."
msgstr ""

msgid ""
"```elixir\n"
"defmodule User do\n"
"  defstruct [:name, :age]\n"
"end"
msgstr ""

msgid ""
"defimpl Size, for: User do\n"
"  def size(_user), do: 2\n"
"end\n"
"```"
msgstr ""

msgid "## Implementing `Any`"
msgstr ""

msgid ""
"Manually implementing protocols for all types can quickly become repetitive an"
"d tedious. In such cases, Elixir provides two options: we can explicitly deriv"
"e the protocol implementation for our types or automatically implement the pro"
"tocol for all types. In both cases, we need to implement the protocol for `Any"
"`."
msgstr ""

msgid "### Deriving"
msgstr ""

msgid ""
"Elixir allows us to derive a protocol implementation based on the `Any` implem"
"entation. Let's first implement `Any` as follows:"
msgstr ""

msgid ""
"```elixir\n"
"defimpl Size, for: Any do\n"
"  def size(_), do: 0\n"
"end\n"
"```"
msgstr ""

msgid ""
"The implementation above is arguably not a reasonable one. For example, it mak"
"es no sense to say that the size of a `PID` or an `Integer` is `0`."
msgstr ""

msgid ""
"However, should we be fine with the implementation for `Any`, in order to use "
"such implementation we would need to tell our struct to explicitly derive the "
"`Size` protocol:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule OtherUser do\n"
"  @derive [Size]\n"
"  defstruct [:name, :age]\n"
"end\n"
"```"
msgstr ""

msgid ""
"When deriving, Elixir will implement the `Size` protocol for `OtherUser` based"
" on the implementation provided for `Any`."
msgstr ""

msgid "### Fallback to `Any`"
msgstr ""

msgid ""
"Another alternative to `@derive` is to explicitly tell the protocol to fallbac"
"k to `Any` when an implementation cannot be found. This can be achieved by set"
"ting `@fallback_to_any` to `true` in the protocol definition:"
msgstr ""

msgid ""
"```elixir\n"
"defprotocol Size do\n"
"  @fallback_to_any true\n"
"  def size(data)\n"
"end\n"
"```"
msgstr ""

msgid ""
"As we said in the previous section, the implementation of `Size` for `Any` is "
"not one that can apply to any data type. That's one of the reasons why `@fallb"
"ack_to_any` is an opt-in behaviour. For the majority of protocols, raising an "
"error when a protocol is not implemented is the proper behaviour. That said, a"
"ssuming we have implemented `Any` as in the previous section:"
msgstr ""

msgid ""
"Now all data types (including structs) that have not implemented the `Size` pr"
"otocol will be considered to have a size of `0`."
msgstr ""

msgid ""
"Which technique is best between deriving and falling back to any depends on th"
"e use case but, given Elixir developers prefer explicit over implicit, you may"
" see many libraries pushing towards the `@derive` approach."
msgstr ""

msgid "## Built-in protocols"
msgstr ""

msgid ""
"Elixir ships with some built-in protocols. In previous chapters, we have discu"
"ssed the `Enum` module which provides many functions that work with any data s"
"tructure that implements the `Enumerable` protocol:"
msgstr ""

msgid ""
"```iex\n"
"iex> Enum.map [1, 2, 3], fn(x) -> x * 2 end\n"
"[2, 4, 6]\n"
"iex> Enum.reduce 1..3, 0, fn(x, acc) -> x + acc end\n"
"6\n"
"```\n"
"Another useful example is the `String.Chars` protocol, which specifies how to "
"convert a data structure with characters to a string. It's exposed via the `to"
"_string` function:"
msgstr ""

msgid ""
"```iex\n"
"iex> to_string :hello\n"
"\"hello\"\n"
"```"
msgstr ""

msgid "Notice that string interpolation in Elixir calls the `to_string` function:"
msgstr ""

msgid ""
"```iex\n"
"iex> \"age: #{25}\"\n"
"\"age: 25\"\n"
"```"
msgstr ""

msgid ""
"The snippet above only works because numbers implement the `String.Chars` prot"
"ocol. Passing a tuple, for example, will lead to an error:"
msgstr ""

msgid ""
"```iex\n"
"iex> tuple = {1, 2, 3}\n"
"{1, 2, 3}\n"
"iex> \"tuple: #{tuple}\"\n"
"** (Protocol.UndefinedError) protocol String.Chars not implemented for {1, 2, "
"3}\n"
"```"
msgstr ""

msgid ""
"When there is a need to \"print\" a more complex data structure, one can use the"
" `inspect` function, based on the `Inspect` protocol:"
msgstr ""

msgid ""
"```iex\n"
"iex> \"tuple: #{inspect tuple}\"\n"
"\"tuple: {1, 2, 3}\"\n"
"```"
msgstr ""

msgid ""
"The `Inspect` protocol is the protocol used to transform any data structure in"
"to a readable textual representation. This is what tools like IEx use to print"
" results:"
msgstr ""

msgid ""
"```iex\n"
"iex> {1, 2, 3}\n"
"{1, 2, 3}\n"
"iex> %User{}\n"
"%User{name: \"john\", age: 27}\n"
"```"
msgstr ""

msgid ""
"Keep in mind that, by convention, whenever the inspected value starts with `#`"
", it is representing a data structure in non-valid Elixir syntax. This means t"
"he inspect protocol is not reversible as information may be lost along the way"
":"
msgstr ""

msgid ""
"```iex\n"
"iex> inspect &(&1+2)\n"
"\"#Function<6.71889879/1 in :erl_eval.expr/5>\"\n"
"```"
msgstr ""

msgid "There are other protocols in Elixir but this covers the most common ones."
msgstr ""

msgid "## Protocol consolidation"
msgstr ""

msgid ""
"When working with Elixir projects, using the Mix build tool, you may see the o"
"utput as follows:"
msgstr ""

msgid ""
"```\n"
"Consolidated String.Chars\n"
"Consolidated Collectable\n"
"Consolidated List.Chars\n"
"Consolidated IEx.Info\n"
"Consolidated Enumerable\n"
"Consolidated Inspect\n"
"```"
msgstr ""

msgid ""
"Those are all protocols that ship with Elixir and they are being consolidated."
" Because a protocol can dispatch to any data type, the protocol must check on "
"every call if an implementation for the given type exists. This may be expensi"
"ve."
msgstr ""

msgid ""
"However, after our project is compiled using a tool like Mix, we know all modu"
"les that have been defined, including protocols and their implementations. Thi"
"s way, the protocol can be consolidated into a very simple and fast dispatch m"
"odule."
msgstr ""

msgid ""
"From Elixir v1.2, protocol consolidation happens automatically for all project"
"s. We will build our own project in the ***Mix and OTP guide***."
msgstr ""
