msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Keyword lists and maps\n"
"redirect_from: /getting-started/maps-and-dicts.html\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid ""
"So far we haven't discussed any associative data structures, i.e. data structu"
"res that are able to associate a certain value (or multiple values) to a key. "
"Different languages call these different names like dictionaries, hashes, asso"
"ciative arrays, etc."
msgstr ""

msgid ""
"In Elixir, we have two main associative data structures: keyword lists and map"
"s. It's time to learn more about them!"
msgstr ""

msgid "## Keyword lists"
msgstr ""

msgid ""
"In many functional programming languages, it is common to use a list of 2-item"
" tuples as the representation of a key-value data structure. In Elixir, when w"
"e have a list of tuples and the first item of the tuple (i.e. the key) is an a"
"tom, we call it a keyword list:"
msgstr ""

msgid ""
"```iex\n"
"iex> list = [{:a, 1}, {:b, 2}]\n"
"[a: 1, b: 2]\n"
"iex> list == [a: 1, b: 2]\n"
"true\n"
"```"
msgstr ""

msgid ""
"As you can see above, Elixir supports a special syntax for defining such lists"
": `[key: value]`. Underneath it maps to the same list of tuples as above. Sinc"
"e keyword lists are lists, we can use all operations available to lists. For e"
"xample, we can use `++` to add new values to a keyword list:"
msgstr ""

msgid ""
"```iex\n"
"iex> list ++ [c: 3]\n"
"[a: 1, b: 2, c: 3]\n"
"iex> [a: 0] ++ list\n"
"[a: 0, a: 1, b: 2]\n"
"```"
msgstr ""

msgid "Note that values added to the front are the ones fetched on lookup:"
msgstr ""

msgid ""
"```iex\n"
"iex> new_list = [a: 0] ++ list\n"
"[a: 0, a: 1, b: 2]\n"
"iex> new_list[:a]\n"
"0\n"
"```"
msgstr ""

msgid "Keyword lists are important because they have three special characteristics:"
msgstr ""

msgid ""
"  * Keys must be atoms.\n"
"  * Keys are ordered, as specified by the developer.\n"
"  * Keys can be given more than once."
msgstr ""

msgid ""
"For example, [the Ecto library](https://github.com/elixir-lang/ecto) makes use"
" of these features to provide an elegant DSL for writing database queries:"
msgstr ""

msgid ""
"```elixir\n"
"query = from w in Weather,\n"
"      where: w.prcp > 0,\n"
"      where: w.temp < 20,\n"
"     select: w\n"
"```"
msgstr ""

msgid ""
"These characteristics are what prompted keyword lists to be the default mechan"
"ism for passing options to functions in Elixir. In chapter 5, when we discusse"
"d the `if/2` macro, we mentioned the following syntax is supported:"
msgstr ""

msgid ""
"```iex\n"
"iex> if false, do: :this, else: :that\n"
":that\n"
"```"
msgstr ""

msgid ""
"The `do:` and `else:` pairs are keyword lists! In fact, the call above is equi"
"valent to:"
msgstr ""

msgid ""
"```iex\n"
"iex> if(false, [do: :this, else: :that])\n"
":that\n"
"```"
msgstr ""

msgid "Which, as we have seen above, is the same as:"
msgstr ""

msgid ""
"```iex\n"
"iex> if(false, [{:do, :this}, {:else, :that}])\n"
":that\n"
"```"
msgstr ""

msgid ""
"In general, when the keyword list is the last argument of a function, the squa"
"re brackets are optional."
msgstr ""

msgid ""
"Although we can pattern match on keyword lists, it is rarely done in practice "
"since pattern matching on lists requires the number of items and their order t"
"o match:"
msgstr ""

msgid ""
"```iex\n"
"iex> [a: a] = [a: 1]\n"
"[a: 1]\n"
"iex> a\n"
"1\n"
"iex> [a: a] = [a: 1, b: 2]\n"
"** (MatchError) no match of right hand side value: [a: 1, b: 2]\n"
"iex> [b: b, a: a] = [a: 1, b: 2]\n"
"** (MatchError) no match of right hand side value: [a: 1, b: 2]\n"
"```"
msgstr ""

msgid ""
"In order to manipulate keyword lists, Elixir provides [the `Keyword` module](h"
"ttps://hexdocs.pm/elixir/Keyword.html). Remember, though, keyword lists are si"
"mply lists, and as such they provide the same linear performance characteristi"
"cs as lists. The longer the list, the longer it will take to find a key, to co"
"unt the number of items, and so on. For this reason, keyword lists are used in"
" Elixir mainly for passing optional values. If you need to store many items or"
" guarantee one-key associates with at maximum one-value, you should use maps i"
"nstead."
msgstr ""

msgid "## Maps"
msgstr ""

msgid ""
"Whenever you need a key-value store, maps are the \"go to\" data structure in El"
"ixir. A map is created using the `%{}` syntax:"
msgstr ""

msgid ""
"```iex\n"
"iex> map = %{:a => 1, 2 => :b}\n"
"%{2 => :b, :a => 1}\n"
"iex> map[:a]\n"
"1\n"
"iex> map[2]\n"
":b\n"
"iex> map[:c]\n"
"nil\n"
"```"
msgstr ""

msgid "Compared to keyword lists, we can already see two differences:"
msgstr ""

msgid ""
"  * Maps allow any value as a key.\n"
"  * Maps' keys do not follow any ordering."
msgstr ""

msgid ""
"In contrast to keyword lists, maps are very useful with pattern matching. When"
" a map is used in a pattern, it will always match on a subset of the given val"
"ue:"
msgstr ""

msgid ""
"```iex\n"
"iex> %{} = %{:a => 1, 2 => :b}\n"
"%{2 => :b, :a => 1}\n"
"iex> %{:a => a} = %{:a => 1, 2 => :b}\n"
"%{2 => :b, :a => 1}\n"
"iex> a\n"
"1\n"
"iex> %{:c => c} = %{:a => 1, 2 => :b}\n"
"** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}\n"
"```"
msgstr ""

msgid ""
"As shown above, a map matches as long as the keys in the pattern exist in the "
"given map. Therefore, an empty map matches all maps."
msgstr ""

msgid "Variables can be used when accessing, matching and adding map keys:"
msgstr ""

msgid ""
"```iex\n"
"iex> n = 1\n"
"1\n"
"iex> map = %{n => :one}\n"
"%{1 => :one}\n"
"iex> map[n]\n"
":one\n"
"iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}\n"
"%{1 => :one, 2 => :two, 3 => :three}\n"
"```"
msgstr ""

msgid ""
"[The `Map` module](https://hexdocs.pm/elixir/Map.html) provides a very similar"
" API to the `Keyword` module with convenience functions to manipulate maps:"
msgstr ""

msgid ""
"```iex\n"
"iex> Map.get(%{:a => 1, 2 => :b}, :a)\n"
"1\n"
"iex> Map.put(%{:a => 1, 2 => :b}, :c, 3)\n"
"%{2 => :b, :a => 1, :c => 3}\n"
"iex> Map.to_list(%{:a => 1, 2 => :b})\n"
"[{2, :b}, {:a, 1}]\n"
"```"
msgstr ""

msgid "Maps have the following syntax for updating a key's value:"
msgstr ""

msgid ""
"```iex\n"
"iex> map = %{:a => 1, 2 => :b}\n"
"%{2 => :b, :a => 1}"
msgstr ""

msgid ""
"iex> %{map | 2 => \"two\"}\n"
"%{2 => \"two\", :a => 1}\n"
"iex> %{map | :c => 3}\n"
"** (KeyError) key :c not found in: %{2 => :b, :a => 1}\n"
"```"
msgstr ""

msgid ""
"The syntax above requires the given key to exist. It cannot be used to add new"
" keys. For example, using it with the `:c` key failed because there is no `:c`"
" in the map."
msgstr ""

msgid ""
"When all the keys in a map are atoms, you can use the keyword syntax for conve"
"nience:"
msgstr ""

msgid ""
"```iex\n"
"iex> map = %{a: 1, b: 2}\n"
"%{a: 1, b: 2}\n"
"```"
msgstr ""

msgid ""
"Another interesting property of maps is that they provide their own syntax for"
" accessing atom keys:"
msgstr ""

msgid ""
"iex> map.a\n"
"1\n"
"iex> map.c\n"
"** (KeyError) key :c not found in: %{2 => :b, :a => 1}\n"
"```"
msgstr ""

msgid ""
"Elixir developers typically prefer to use the `map.field` syntax and pattern m"
"atching instead of the functions in the `Map` module when working with maps be"
"cause they lead to an assertive style of programming. [This blog post](http://"
"blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/) provide"
"s insight and examples on how you get more concise and faster software by writ"
"ing assertive code in Elixir."
msgstr ""

msgid ""
"> Note: Maps were recently introduced into the Erlang <abbr title=\"Virtual Mac"
"hine\">VM</abbr> and only from Elixir v1.2 are they capable of holding millions"
" of keys efficiently. Therefore, if you are working with previous Elixir versi"
"ons (v1.0 or v1.1) and you need to support at least hundreds of keys, you may "
"consider using [the `HashDict` module](https://hexdocs.pm/elixir/HashDict.html"
")."
msgstr ""

msgid "## Nested data structures"
msgstr ""

msgid ""
"Often we will have maps inside maps, or even keywords lists inside maps, and s"
"o forth. Elixir provides conveniences for manipulating nested data structures "
"via the `put_in/2`, `update_in/2` and other macros giving the same convenience"
"s you would find in imperative languages while keeping the immutable propertie"
"s of the language."
msgstr ""

msgid "Imagine you have the following structure:"
msgstr ""

msgid ""
"```iex\n"
"iex> users = [\n"
"  john: %{name: \"John\", age: 27, languages: [\"Erlang\", \"Ruby\", \"Elixir\"]},\n"
"  mary: %{name: \"Mary\", age: 29, languages: [\"Elixir\", \"F#\", \"Clojure\"]}\n"
"]\n"
"[john: %{age: 27, languages: [\"Erlang\", \"Ruby\", \"Elixir\"], name: \"John\"},\n"
" mary: %{age: 29, languages: [\"Elixir\", \"F#\", \"Clojure\"], name: \"Mary\"}]\n"
"```"
msgstr ""

msgid ""
"We have a keyword list of users where each value is a map containing the name,"
" age and a list of programming languages each user likes. If we wanted to acce"
"ss the age for john, we could write:"
msgstr ""

msgid ""
"```iex\n"
"iex> users[:john].age\n"
"27\n"
"```"
msgstr ""

msgid "It happens we can also use this same syntax for updating the value:"
msgstr ""

msgid ""
"```iex\n"
"iex> users = put_in users[:john].age, 31\n"
"[john: %{age: 31, languages: [\"Erlang\", \"Ruby\", \"Elixir\"], name: \"John\"},\n"
" mary: %{age: 29, languages: [\"Elixir\", \"F#\", \"Clojure\"], name: \"Mary\"}]\n"
"```"
msgstr ""

msgid ""
"The `update_in/2` macro is similar but allows us to pass a function that contr"
"ols how the value changes. For example, let's remove \"Clojure\" from Mary's lis"
"t of languages:"
msgstr ""

msgid ""
"```iex\n"
"iex> users = update_in users[:mary].languages, fn languages -> List.delete(lan"
"guages, \"Clojure\") end\n"
"[john: %{age: 31, languages: [\"Erlang\", \"Ruby\", \"Elixir\"], name: \"John\"},\n"
" mary: %{age: 29, languages: [\"Elixir\", \"F#\"], name: \"Mary\"}]\n"
"```"
msgstr ""

msgid ""
"There is more to learn about `put_in/2` and `update_in/2`, including the `get_"
"and_update_in/2` that allows us to extract a value and update the data structu"
"re at once. There are also `put_in/3`, `update_in/3` and `get_and_update_in/3`"
" which allow dynamic access into the data structure. [Check their respective d"
"ocumentation in the `Kernel` module for more information](https://hexdocs.pm/e"
"lixir/Kernel.html)."
msgstr ""

msgid ""
"This concludes our introduction to associative data structures in Elixir. You "
"will find out that, given keyword lists and maps, you will always have the rig"
"ht tool to tackle problems that require associative data structures in Elixir."
msgstr ""
