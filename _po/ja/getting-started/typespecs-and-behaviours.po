msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2018-07-27 22:30+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Typespecs and behaviours\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid "## Types and specs"
msgstr ""

msgid ""
"Elixir is a dynamically typed language, so all types in Elixir are inferred by"
" the runtime. Nonetheless, Elixir comes with **typespecs**, which are a notati"
"on used for:"
msgstr ""

msgid ""
"1. declaring typed function signatures (specifications);\n"
"2. declaring custom data types."
msgstr ""

msgid "### Function specifications"
msgstr ""

msgid ""
"By default, Elixir provides some basic types, such as `integer` or `pid`, as w"
"ell as more complex types: for example, the `round/1` function, which rounds a"
" float to its nearest integer, takes a `number` as an argument (an `integer` o"
"r a `float`) and returns an `integer`. As you can see [in its documentation](h"
"ttps://hexdocs.pm/elixir/Kernel.html#round/1), `round/1`'s typed signature is "
"written as:"
msgstr ""

msgid ""
"```elixir\n"
"round(number) :: integer\n"
"```"
msgstr ""

msgid ""
"`::` means that the function on the left side *returns* a value whose type is "
"what's on the right side. Function specs are written with the `@spec` directiv"
"e, placed right before the function definition. The `round/1` function could b"
"e written as:"
msgstr ""

msgid ""
"```elixir\n"
"@spec round(number) :: integer\n"
"def round(number), do: # implementation...\n"
"```"
msgstr ""

msgid ""
"Elixir supports compound types as well. For example, a list of integers has ty"
"pe `[integer]`. You can see all the built-in types provided by Elixir [in the "
"typespecs docs](https://hexdocs.pm/elixir/typespecs.html)."
msgstr ""

msgid "### Defining custom types"
msgstr ""

msgid ""
"While Elixir provides a lot of useful built-in types, it's convenient to defin"
"e custom types when appropriate. This can be done when defining modules throug"
"h the `@type` directive."
msgstr ""

msgid ""
"Say we have a `LousyCalculator` module, which performs the usual arithmetic op"
"erations (sum, product, and so on) but, instead of returning numbers, it retur"
"ns tuples with the result of an operation as the first element and a random re"
"mark as the second element."
msgstr ""

msgid ""
"```elixir\n"
"defmodule LousyCalculator do\n"
"  @spec add(number, number) :: {number, String.t}\n"
"  def add(x, y), do: {x + y, \"You need a calculator to do that?!\"}"
msgstr ""

msgid ""
"  @spec multiply(number, number) :: {number, String.t}\n"
"  def multiply(x, y), do: {x * y, \"Jeez, come on!\"}\n"
"end\n"
"```"
msgstr ""

msgid ""
"As you can see in the example, tuples are a compound type and each tuple is id"
"entified by the types inside it. To understand why `String.t` is not written a"
"s `string`, have another look at the [notes in the typespecs docs](https://hex"
"docs.pm/elixir/typespecs.html#notes)."
msgstr ""

msgid ""
"Defining function specs this way works, but it quickly becomes annoying since "
"we're repeating the type `{number, String.t}` over and over. We can use the `@"
"type` directive in order to declare our own custom type."
msgstr ""

msgid ""
"```elixir\n"
"defmodule LousyCalculator do\n"
"  @typedoc \"\"\"\n"
"  Just a number followed by a string.\n"
"  \"\"\"\n"
"  @type number_with_remark :: {number, String.t}"
msgstr ""

msgid ""
"  @spec add(number, number) :: number_with_remark\n"
"  def add(x, y), do: {x + y, \"You need a calculator to do that?\"}"
msgstr ""

msgid ""
"  @spec multiply(number, number) :: number_with_remark\n"
"  def multiply(x, y), do: {x * y, \"It is like addition on steroids.\"}\n"
"end\n"
"```"
msgstr ""

msgid ""
"The `@typedoc` directive, similarly to the `@doc` and `@moduledoc` directives,"
" is used to document custom types."
msgstr ""

msgid ""
"Custom types defined through `@type` are exported and available outside the mo"
"dule they're defined in:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule QuietCalculator do\n"
"  @spec add(number, number) :: number\n"
"  def add(x, y), do: make_quiet(LousyCalculator.add(x, y))"
msgstr ""

msgid ""
"  @spec make_quiet(LousyCalculator.number_with_remark) :: number\n"
"  defp make_quiet({num, _remark}), do: num\n"
"end\n"
"```"
msgstr ""

msgid ""
"If you want to keep a custom type private, you can use the `@typep` directive "
"instead of `@type`."
msgstr ""

msgid "### Static code analysis"
msgstr ""

msgid ""
"Typespecs are not only useful to developers as additional documentation. The E"
"rlang tool [Dialyzer](http://www.erlang.org/doc/man/dialyzer.html), for exampl"
"e, uses typespecs in order to perform static analysis of code. That's why, in "
"the `QuietCalculator` example, we wrote a spec for the `make_quiet/1` function"
" even though it was defined as a private function."
msgstr ""

msgid "## Behaviours"
msgstr ""

msgid ""
"Many modules share the same public API. Take a look at [Plug](https://github.c"
"om/elixir-lang/plug), which, as its description states, is a **specification**"
" for composable modules in web applications. Each *plug* is a module which **h"
"as to** implement at least two public functions: `init/1` and `call/2`."
msgstr ""

msgid "Behaviours provide a way to:"
msgstr ""

msgid ""
"* define a set of functions that have to be implemented by a module;\n"
"* ensure that a module implements all the functions in that set."
msgstr ""

msgid ""
"If you have to, you can think of behaviours like interfaces in object oriented"
" languages like Java: a set of function signatures that a module has to implem"
"ent."
msgstr ""

msgid "### Defining behaviours"
msgstr ""

msgid ""
"Say we want to implement a bunch of parsers, each parsing structured data: for"
" example, a JSON parser and a MessagePack parser. Each of these two parsers wi"
"ll *behave* the same way: both will provide a `parse/1` function and an `exten"
"sions/0` function. The `parse/1` function will return an Elixir representation"
" of the structured data, while the `extensions/0` function will return a list "
"of file extensions that can be used for each type of data (e.g., `.json` for J"
"SON files)."
msgstr ""

msgid "We can create a `Parser` behaviour:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Parser do\n"
"  @callback parse(String.t) :: {:ok, term} | {:error, String.t}\n"
"  @callback extensions() :: [String.t]\n"
"end\n"
"```"
msgstr ""

msgid ""
"Modules adopting the `Parser` behaviour will have to implement all the functio"
"ns defined with the `@callback` directive. As you can see, `@callback` expects"
" a function name but also a function specification like the ones used with the"
" `@spec` directive we saw above. Also note that the `term` type is used to rep"
"resent the parsed value. In Elixir, the `term` type is a shortcut to represent"
" any type."
msgstr ""

msgid "### Adopting behaviours"
msgstr ""

msgid "Adopting a behaviour is straightforward:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule JSONParser do\n"
"  @behaviour Parser"
msgstr ""

msgid ""
"  def parse(str), do: {:ok, \"some json \" <> str} # ... parse JSON\n"
"  def extensions, do: [\"json\"]\n"
"end\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"defmodule YAMLParser do\n"
"  @behaviour Parser"
msgstr ""

msgid ""
"  def parse(str), do: {:ok, \"some yaml \" <> str} # ... parse YAML\n"
"  def extensions, do: [\"yml\"]\n"
"end\n"
"```"
msgstr ""

msgid ""
"If a module adopting a given behaviour doesn't implement one of the callbacks "
"required by that behaviour, a compile-time warning will be generated."
msgstr ""

msgid "### Dynamic dispatch"
msgstr ""

msgid ""
"Behaviours are frequently used with dynamic dispatching. For example, we could"
" add a `parse!` function to the `Parser` module that dispatches to the given i"
"mplementation and returns the `:ok` result or raises in cases of `:error`:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Parser do\n"
"  @callback parse(String.t) :: {:ok, term} | {:error, String.t}\n"
"  @callback extensions() :: [String.t]"
msgstr ""

msgid ""
"  def parse!(implementation, contents) do\n"
"    case implementation.parse(contents) do\n"
"      {:ok, data} -> data\n"
"      {:error, error} -> raise ArgumentError, \"parsing error: #{error}\"\n"
"    end\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"Note you don't need to define a behaviour in order to dynamically dispatch on "
"a module, but those features often go hand in hand."
msgstr ""
