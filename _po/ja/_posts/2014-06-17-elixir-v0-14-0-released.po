msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: post\n"
"title: Elixir v0.14.0 released\n"
"author: JosÃ© Valim\n"
"category: Releases\n"
"excerpt: \"Elixir v0.14.0 is released and expands the work on structs and bring"
"ing more of OTP right into Elixir and Mix\"\n"
"---"
msgstr ""

msgid "Hello everyone!"
msgstr ""

msgid "We are glad to announce v0.14.0 has been released."
msgstr ""

msgid ""
"Our previous release, [v0.13.0](/blog/2014/04/21/elixir-v0-13-0-released/), br"
"ought important changes to the language. Back then we have introduced a new as"
"sociative data structure, called maps, and presented the concept of structs to"
" replace Elixir records."
msgstr ""

msgid ""
"With v0.14.0 we have expanded on the work started on v0.13.0, replacing record"
"s by structs and integrating OTP behaviours, applications, and configurations "
"into Mix."
msgstr ""

msgid "## @derive"
msgstr ""

msgid "Maps are Elixir's new associative data structure:"
msgstr ""

msgid ""
"```elixir\n"
"%{key: \"value\"}\n"
"```"
msgstr ""

msgid "With maps, Elixir also introduced structs, that are basically raw, named maps:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule User do\n"
"  defstruct name: \"\", age: 0\n"
"end"
msgstr ""

msgid ""
"%User{name: \"jose\"}\n"
"#=> %User{name: \"jose\", age: 0}\n"
"```"
msgstr ""

msgid ""
"Structs allow us to provide default values for a map fields. Structs also vali"
"date, at compilation time, that all fields given during the struct constructio"
"n are valid fields. The following, for example, would fail:"
msgstr ""

msgid ""
"```elixir\n"
"%User{unknown: \"field\"}\n"
"#=> ** (CompileError) iex:2: unknown key :unknown for struct User\n"
"```"
msgstr ""

msgid ""
"We say structs are *raw* because they do not implement any of the protocols th"
"at are implemented for maps  by default. For instance, we can call `Enum.each/"
"2` for a map, which uses the [`Enumerable`](https://hexdocs.pm/elixir/Enumerab"
"le.html) protocol:"
msgstr ""

msgid ""
"```elixir\n"
"Enum.each %{foo: :bar}, fn {k, v} ->\n"
"  IO.puts \"Got #{k}: #{v}\"\n"
"end\n"
"#=> Got foo: bar\n"
"```"
msgstr ""

msgid "But such a call would fail for the User struct:"
msgstr ""

msgid ""
"```elixir\n"
"Enum.each %User{}, fn {k, v} ->\n"
"  IO.puts \"Got #{k}: #{v}\"\n"
"end\n"
"#=> ** (Protocol.UndefinedError) protocol Enumerable not implemented for %User"
"{age: 0, name: \"\"}\n"
"```"
msgstr ""

msgid ""
"However, in many situations, we may want to enumerate the keys and values in a"
" struct. Before this release, it would require us to manually implement the `E"
"numerable` protocol for every struct."
msgstr ""

msgid ""
"Elixir v0.14.0 solves this issue by introducing `@derive` which allows us to d"
"ynamically derive implementations for structs based on the implementation for "
"maps:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule User do\n"
"  @derive [Enumerable]\n"
"  defstruct name: \"\", age: 0\n"
"end"
msgstr ""

msgid ""
"Enum.each %User{name: \"jose\"}, fn {k, v} ->\n"
"  IO.puts \"Got #{k}: #{v}\"\n"
"end\n"
"#=> Got __struct__: Elixir.User\n"
"#=> Got name: jose\n"
"#=> Got age: 0\n"
"```"
msgstr ""

msgid ""
"The deriving functionality can be customized by implementing `PROTOCOL.Map.__d"
"eriving__/3`. For example, a JSON protocol could define a `JSON.Map.__deriving"
"__/3` function that derives specific implementations for every struct. Such im"
"plementations could access the struct fields and generate a JSON template at c"
"ompilation time, avoiding work at runtime."
msgstr ""

msgid "## Protocol consolidation"
msgstr ""

msgid ""
"In the example above, when we called `Enum.each/2`, it invoked the `Enumerable"
"` protocol internally, which then checks if there is an implementation availab"
"le for the `User` struct. This means that dispatching a protocol incurs some o"
"verhead to check if the implementation is available or not."
msgstr ""

msgid ""
"While this behaviour is useful for development, in production all implementati"
"ons for all protocols are usually known up-front, so we could avoid this overh"
"ead by doing a direct dispatch. That's exactly what protocol consolidation doe"
"s."
msgstr ""

msgid ""
"Protocol consolidation checks all code paths in your project, looking for all "
"protocols and all implementions. When all implementations are found it will re"
"compile all protocols to have quick dispatch rules."
msgstr ""

msgid ""
"You can invoke `Protocol.consolidate/2` to manually consolidate protocols. How"
"ever, if you are inside a Mix project, you can consolidate all protocols by si"
"mply invoking `mix compile.protocols`. Type `mix help compile.protocols` in yo"
"ur terminal to get more information. This task should be invoked when deployin"
"g to production and we have opened issues in the Elixir buildpack as well as i"
"n the existing build tools so they automatically consolidade protocols for you"
"."
msgstr ""

msgid "## Nested access"
msgstr ""

msgid ""
"With v0.14.0, Elixir introduced functionality to traverse deeply nested data s"
"tructures. To show this functionality let's imagine we have a gaming applicati"
"on where users can be in different dungeons. Each dungeon may have many rooms "
"and users can talk to each other only if they are in the same room."
msgstr ""

msgid "We can model the game's dungeons with a Dungeon struct:"
msgstr ""

msgid ""
"```elixir\n"
"%Dungeon{name: \"\", rooms: %{}}\n"
"```"
msgstr ""

msgid ""
"The Dungeon can have many rooms and we keep them in a map, with the room id as"
" key, and the Room struct as value:"
msgstr ""

msgid ""
"```elixir\n"
"%Room{id: 0, users: HashDict.new}\n"
"```"
msgstr ""

msgid ""
"A room has users and since we can possibly have hundreds of them, we store the"
"m in a HashDict, with the user id as key. Finally, the user may participate fr"
"om different devices, so we need to keep a set of device codes in each user:"
msgstr ""

msgid ""
"```elixir\n"
"%User{id: 0, username: \"\", device_codes: HashSet.new}\n"
"```"
msgstr ""

msgid ""
"The nested access functionality that ships with Elixir allows us to quickly ac"
"cess or update a nested value. For example, given a dungeon named `dungeon`, w"
"e can access all the device codes for a given user as follow:"
msgstr ""

msgid ""
"```elixir\n"
"dungeon.rooms[room_id].users[user_id].device_codes\n"
"```"
msgstr ""

msgid ""
"With the nested access functionality, we can now update a nested path directly"
" too. For example, if a user changes his name, we can change it directly with:"
msgstr ""

msgid ""
"```elixir\n"
"put_in dungeon.rooms[room_id].users[user_id].username, \"new username\"\n"
"```"
msgstr ""

msgid ""
"If the user signs out from one device, we can delete the code from that partic"
"ular device:"
msgstr ""

msgid ""
"```elixir\n"
"update_in dungeon.rooms[room_id].users[user_id].device_codes, &Set.delete(&1, "
"code)\n"
"```"
msgstr ""

msgid ""
"`put_in/2` and `update_in/2` are macros that work as syntax sugar for the lowe"
"r-level `put_in/3` and `update_in/3`, that expects the whole path to be given "
"as a list:"
msgstr ""

msgid ""
"```elixir\n"
"put_in dungeon, [:rooms, room_id, :users, user_id, :username], \"new username\"\n"
"```"
msgstr ""

msgid ""
"You can read more information about nested access in [the Access protocol docu"
"mentation](https://hexdocs.pm/elixir/Access.html) and in the docs for [`get_in"
"/2`](https://hexdocs.pm/elixir/Kernel.html#get_in/2) and friends."
msgstr ""

msgid "## Mix and OTP"
msgstr ""

msgid ""
"OTP is a set of libraries that ships with Erlang. Erlang developers use OTP to"
" build robust, fault-tolerant applications."
msgstr ""

msgid ""
"In v0.14.0, Elixir closely integrates with OTP by providing modules for buildi"
"ng [servers](https://hexdocs.pm/elixir/GenServer.html), [supervisors](https://"
"hexdocs.pm/elixir/Supervisor.html) and [applications](https://hexdocs.pm/elixi"
"r/Application.html)."
msgstr ""

msgid ""
"We have also introduced the concepts of [agents](https://hexdocs.pm/elixir/Age"
"nt.html) and the idea of [tasks](https://hexdocs.pm/elixir/Task.html), which c"
"an be supervised and distributed. Application configuration has been made firs"
"t class in Mix, allowing developers to configure their dependencies, sometimes"
" even using different configurations per environment (dev, test or prod by def"
"ault)."
msgstr ""

msgid ""
"This functionality is at the core of building applications in Erlang and Elixi"
"r. For this reason we have published a new guide called [Mix and OTP](/getting"
"-started/mix-otp/introduction-to-mix.html) where we build a distributed key-va"
"lue store to help explore all concepts mentioned above. The guide is quite fre"
"sh, so please do submit pull requests for typos and mistakes. Feedback is also"
" welcome!"
msgstr ""

msgid ""
"Note \"Mix and OTP\" is our most advanced guide so far and it expects you to hav"
"e read our introductory guide. In case you haven't yet, you can [get started h"
"ere](/getting-started/introduction.html)."
msgstr ""

msgid "## What's next?"
msgstr ""

msgid ""
"With v0.14.0 we have reached many of the milestones [we have set in the previo"
"us release](/blog/2014/04/21/elixir-v0-13-0-released/#the-next-steps). This br"
"ings us closer to Elixir v1.0 and only a handful of tasks are pending:"
msgstr ""

msgid ""
"* Provide an Elixir logger that knows how to print and format Elixir exception"
"s and stacktraces. Work has already started on this front as Elixir already pr"
"ints errors coming from the application startup nicely;"
msgstr ""

msgid ""
"* Continue the work of cleaning up the [Kernel module](https://hexdocs.pm/elix"
"ir/Kernel.html). In v0.14.0, we added alternatives for conversion functions, l"
"ike `integer_to_binary/1` to `Integer.to_string/1`, now they must be properly "
"deprecated and removed;"
msgstr ""

msgid ""
"* Support mix aliases, allowing developers to easily define Mix shortcuts for "
"their favorite tasks;"
msgstr ""

msgid ""
"* Solve all remaining [open issues](https://github.com/elixir-lang/elixir/issu"
"es?state=open). We have always kept the issues tracker tidy and there is littl"
"e work left to solve the existing issues. Note we have also listed all [upcomi"
"ng backwards incompatible changes](https://github.com/elixir-lang/elixir/issue"
"s?labels=Note%3ABackwards+incompatible&page=1&state=open). Many of those chang"
"es will actually be deprecated first and developers should be able to follow a"
"long without breaking changes in minor releases, but they are breaking changes"
" in the sense they work in v0.14.0 but will work differently by the time v1.0 "
"is released;"
msgstr ""

msgid ""
"That's all for now! Elixir developers can see [a summary of all changes in v0."
"14.0 in the release notes](https://github.com/elixir-lang/elixir/releases/tag/"
"v0.14.0). In case you are new around here, you can get started with Elixir by "
"reading [our Getting Started guide](/getting-started/introduction.html)."
msgstr ""

msgid "We hope to see you all this July at [ElixirConf](http://elixirconf.com/)!"
msgstr ""
