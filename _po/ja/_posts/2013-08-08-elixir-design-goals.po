msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: post\n"
"title: Elixir Design Goals\n"
"author: JosÃ© Valim\n"
"category: Internals\n"
"excerpt: Highlight of Elixir design goals.\n"
"---"
msgstr ""

msgid ""
"During the last year, we have spoken at many conferences spreading the word ab"
"out Elixir. We [usually started with introducing the Erlang VM](https://vimeo."
"com/53221562), then went on to talk about Elixir goals, saving some time at th"
"e end to do a live demo, showing some goodies like exchanging information betw"
"een remote nodes and even hot code swapping."
msgstr ""

msgid ""
"This post is a summary of those talks, focusing on the language goals: compati"
"bility, productivity and extensibility."
msgstr ""

msgid "## Compatibility"
msgstr ""

msgid ""
"Elixir is meant to be compatible with the Erlang VM and the existing ecosystem"
". When we talk about Erlang, we can break it into three parts:"
msgstr ""

msgid ""
"* A functional programming language, called Erlang\n"
"* A set of design principles, called OTP\n"
"* The Erlang Virtual Machine, referred to as EVM or BEAM"
msgstr ""

msgid ""
"Elixir runs in the same virtual machine and is compatible with OTP. Not only t"
"hat, all the tools and libraries available in the Erlang ecosystem are also av"
"ailable in Elixir, simply because there is no conversion cost from calling Erl"
"ang from Elixir and vice-versa."
msgstr ""

msgid "We frequently say that **the Erlang VM is Elixir's strongest asset**."
msgstr ""

msgid ""
"All Elixir code is executed inside light-weight processes (actors), each with "
"its own state, that exchange messages between each other. The Erlang VM multip"
"lexes those processes onto many cores, making it trivial to run code concurren"
"tly."
msgstr ""

msgid ""
"In fact if you compile any Elixir code, including the Elixir source, you will "
"see all cores on your machine being used out of the box. With [technologies li"
"ke Parallella](http://www.parallella.org/board/) becoming more accessible and "
"affordable, it is hard to ignore the power you can get out of the Erlang VM."
msgstr ""

msgid ""
"Finally, the Erlang VM was designed to build systems that run forever, self-he"
"al and scale. Joe Armstrong, one of Erlang's creators, has recently given an e"
"xcellent talk [about the design decisions behind OTP and the VM](http://www.in"
"foq.com/presentations/self-heal-scalable-system)."
msgstr ""

msgid ""
"Nothing that we are describing here is particularly new. Open source projects "
"like CouchDB, Riak, RabbitMQ, Chef11 and companies like Ericsson, Heroku, Bash"
"o, Klarna and Wooga are already enjoying the benefits provided by the Erlang V"
"M, some of them for quite a long time."
msgstr ""

msgid "## Productivity"
msgstr ""

msgid ""
"> Now we need to go meta. We should now think of a language design as being a "
"pattern for language designs. A tool for making more tools of the same kind. ["
"...] A language design can no longer be a thing. It must be a pattern, a patte"
"rn for growth. A pattern for growing a pattern, for defining the patterns that"
" programmers can use for their real work and main goals."
msgstr ""

msgid ""
"- Guy Steele, keynote at the 1998 ACM OOPSLA conference on \"Growing a Language"
"\""
msgstr ""

msgid ""
"Productivity is, in general, a hard goal to measure. A language productive for"
" creating desktop applications may not be productive for mathematical computin"
"g. Productivity depends directly on the field in which you intend to use the l"
"anguage, the available tools in the ecosystem and how easy it is to create and"
" extend those tools."
msgstr ""

msgid ""
"For this reason, we have opted for a small language core. For example, while s"
"ome languages have `if`, `case`, `try` and so on as language keywords, each wi"
"th its own rules in the parser, **in Elixir they are just macros**. This allow"
"s us to implement most of Elixir in Elixir and also allows developers to exten"
"d the language using the same tools we used to build the language itself, ofte"
"n extending the language to the specific domains they are working on."
msgstr ""

msgid ""
"Here is an example of how someone would implement `unless`, which is a keyword"
" in many languages, in Elixir:"
msgstr ""

msgid ""
"```elixir\n"
"defmacro unless(expr, opts) do\n"
"  quote do\n"
"    if(!unquote(expr), unquote(opts))\n"
"  end\n"
"end"
msgstr ""

msgid ""
"unless true do\n"
"  IO.puts \"this will never be seen\"\n"
"end\n"
"```"
msgstr ""

msgid ""
"Since a macro receives the code representation as arguments, we can simply con"
"vert an `unless` into an `if` at compile time."
msgstr ""

msgid ""
"Macros are also the base construct for meta-programming in Elixir: the ability"
" to write code that generates code. Meta-programming allows developers to easi"
"ly get rid of boilerplate and create powerful tools. A common example mentione"
"d in talks is how our test framework uses macros for expressiveness. Let's see"
" an example:"
msgstr ""

msgid ""
"```elixir\n"
"ExUnit.start"
msgstr ""

msgid ""
"defmodule MathTest do\n"
"  use ExUnit.Case, async: true"
msgstr ""

msgid ""
"  test \"adding two numbers\" do\n"
"    assert 1 + 2 == 4\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"The first thing to notice is the `async: true` option. When your tests do not "
"have any side-effects, you can run them concurrently by passing the `async: tr"
"ue` option."
msgstr ""

msgid ""
"Next we define a test case and we do an assertion with the `assert` macro. Sim"
"ply calling `assert` would be a bad practice in many languages as it would pro"
"vide a poor error report. In such languages, functions/methods like `assertEqu"
"al` or `assert_equal` would be the recommended way of performing such assertio"
"n."
msgstr ""

msgid ""
"In Elixir, however, `assert` is a macro and as such it can look into the code "
"being asserted and infer that a comparison is being made. This code is then tr"
"ansformed to provide a detailed error report when the test runs:"
msgstr ""

msgid ""
"```\n"
"1) test adding two numbers (MathTest)\n"
"   ** (ExUnit.ExpectationError)\n"
"                expected: 3\n"
"     to be equal to (==): 4\n"
"   at test.exs:7\n"
"```"
msgstr ""

msgid ""
"This simple example illustrates how a developer can leverage macros to provide"
" a concise but powerful API. Macros have access to the whole compilation envir"
"onment, being able to check the imported functions, macros, defined variables "
"and more."
msgstr ""

msgid ""
"Those examples are just scratching the surface of what can be achieved with ma"
"cros in Elixir. For example, we are currently using macros to compile routes f"
"rom a web application into a bunch of patterns that are highly optimizable by "
"the VM, providing an expressive but heavily optimized routing algorithm."
msgstr ""

msgid ""
"The macro system also caused a huge impact on the syntax, which we will discus"
"s briefly before moving to the last goal."
msgstr ""

msgid "### Syntax"
msgstr ""

msgid ""
"Although syntax is usually one of the first topics that comes up when Elixir i"
"s being discussed, it was never a goal to simply provide a different syntax. S"
"ince we wanted to provide a macro system, we knew that the macro system would "
"only be sane if we could represent Elixir syntax in terms of Elixir's own data"
" structures in a straight-forward fashion. With this goal in mind, we set out "
"to design the first Elixir version, which looked like this:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule(Hello, do: (\n"
"  def(calculate(a, b, c), do: (\n"
"    =(temp, *(a, b))\n"
"    +(temp, c)\n"
"  ))\n"
"))\n"
"```"
msgstr ""

msgid ""
"In the snippet above, we represent everything, except variables, as a function"
" or a macro call. Notice keyword arguments like `do:` have been present since "
"the first version. To this, we slowly added new syntax, making some common pat"
"terns more elegant while keeping the same underlying data representation. We s"
"oon added infix notation for operators:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule(Hello, do: (\n"
"  def(calculate(a, b, c), do: (\n"
"    temp = a * b\n"
"    temp + c\n"
"  ))\n"
"))\n"
"```"
msgstr ""

msgid "The next step was to make parentheses optional:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Hello, do: (\n"
"  def calculate(a, b, c), do: (\n"
"    temp = a * b\n"
"    temp + c\n"
"  )\n"
")\n"
"```"
msgstr ""

msgid ""
"And finally we added `do/end` as convenience for the common `do: (...)` constr"
"uct:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Hello do\n"
"  def calculate(a, b, c) do\n"
"    temp = a * b\n"
"    temp + c\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"Given my previous background in Ruby, it is natural that some of the construct"
"s added were borrowed from Ruby. However, those additions were a by-product, a"
"nd not a language goal."
msgstr ""

msgid ""
"Many language constructs are also inspired by their Erlang counter-parts, like"
" some of the control-flow macros, operators and containers. Notice how some El"
"ixir code:"
msgstr ""

msgid ""
"```elixir\n"
"# A tuple\n"
"tuple = { 1, 2, 3 }"
msgstr ""

msgid ""
"# Adding two lists\n"
"[1, 2, 3] ++ [4, 5, 6]"
msgstr ""

msgid ""
"# Case\n"
"case expr do\n"
"  { x, y } -> x + y\n"
"  other when is_integer(other) -> other\n"
"end\n"
"```"
msgstr ""

msgid "maps to Erlang:"
msgstr ""

msgid ""
"```erlang\n"
"% A tuple\n"
"Tuple = { 1, 2, 3 }."
msgstr ""

msgid ""
"% Adding two lists\n"
"[1, 2, 3] ++ [4, 5, 6]."
msgstr ""

msgid ""
"% Case\n"
"case Expr of\n"
"  { X, Y } -> X + Y;\n"
"  Other when is_integer(Other) -> Other\n"
"end.\n"
"```"
msgstr ""

msgid "## Extensibility"
msgstr ""

msgid ""
"By building on top of a small core, most of the constructs in the language can"
" be replaced and extended as required by developers to target specific domains"
". However, there is a particular domain that Elixir is inherently good at, whi"
"ch is building concurrent, distributed applications, thanks to OTP and the Erl"
"ang VM."
msgstr ""

msgid "Elixir complements this domain by providing a standard library with:"
msgstr ""

msgid ""
"* Unicode strings and unicode operations\n"
"* A powerful unit test framework\n"
"* More data structures like ranges, including novel implementations for sets a"
"nd dictionaries\n"
"* Polymorphic records (in contrast to Erlang's compilation-time only records)\n"
"* Strict and lazy enumeration APIs\n"
"* Convenience functions for scripting, like working with paths and the filesys"
"tem\n"
"* A project management tool to compile and test Elixir code"
msgstr ""

msgid "And much more."
msgstr ""

msgid ""
"Most of the features above provide their own extensibility mechanisms, too. Fo"
"r example, take the `Enum` module. The `Enum` module allow us to enumerate the"
" built-in ranges, lists, sets, etc:"
msgstr ""

msgid ""
"```elixir\n"
"list = [1, 2, 3]\n"
"Enum.map list, fn(x) -> x * 2 end\n"
"#=> [2, 4, 6]"
msgstr ""

msgid ""
"range = 1..3\n"
"Enum.map range, fn(x) -> x * 2 end\n"
"#=> [2, 4, 6]"
msgstr ""

msgid ""
"set = HashSet.new [1, 2, 3]\n"
"Enum.map set, fn(x) -> x * 2 end\n"
"#=> [2, 4, 6]\n"
"```"
msgstr ""

msgid ""
"Not only that, any developer can **extend** the `Enum` module to work with any"
" data type as long as the data type implements [the `Enumerable` protocol](htt"
"ps://hexdocs.pm/elixir/Enumerable.html) (protocols in Elixir are based on Cloj"
"ure's protocol). This is extremely convenient because the developer needs to k"
"now only the `Enum` API for enumeration, instead of memorizing specific APIs f"
"or sets, lists, dicts, etc."
msgstr ""

msgid ""
"There are many other protocols exposed by the language, like [the `Inspect` pr"
"otocol](https://hexdocs.pm/elixir/Inspect.html) for pretty printing data struc"
"tures and [the `Access` protocol](https://hexdocs.pm/elixir/Access.html) for a"
"ccessing key-value data by key. By being extensible, Elixir ensures developers"
" can work **with** the language, instead of **against** the language."
msgstr ""

msgid "## Summing up"
msgstr ""

msgid ""
"The goal of this post was to sumarize the language goals: compatibility, produ"
"ctivity and extensibility. By being compatibile with the Erlang VM, we are pro"
"viding developers another toolset for building concurrent, distributed and fau"
"lt-tolerant systems."
msgstr ""

msgid ""
"We also hope to have clarified what Elixir brings to the Erlang VM, in particu"
"lar, meta-programming through macros, polymorphic constructs for extensibility"
" and a data-focused standard library with extensible and consistent APIs for d"
"iverse types, including strict and lazy enumeration, unicode handling, a test "
"framework and more."
msgstr ""

msgid ""
"Give Elixir a try! You can start with our [getting started guide](/getting-sta"
"rted/introduction.html), or check out our sidebar for other learning resources"
"."
msgstr ""
