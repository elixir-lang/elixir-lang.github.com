msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: post\n"
"title: A peek inside Elixir's Parallel Compiler\n"
"author: JosÃ© Valim\n"
"category: Internals\n"
"excerpt: Today, a parallel compiler just landed in Elixir master. The goal of "
"the parallel compiler is to compile files in parallel, automatically detecting"
" dependencies between files. In this blog post, we are going to take a peek in"
"to the parallel compiler internals and learn more about Erlang and Elixir in t"
"he process.\n"
"---"
msgstr ""

msgid ""
"Today, a parallel compiler just landed in Elixir master. The goal of the paral"
"lel compiler is to compile files in parallel, automatically detecting dependen"
"cies between files. In this blog post, we are going to take a peek into the pa"
"rallel compiler internals and learn more about Erlang and Elixir in the proces"
"s."
msgstr ""

msgid "## Process-based serial compilation"
msgstr ""

msgid ""
"The idea of the parallel compiler is very simple: for each file we want to com"
"pile, we will spawn a new process that will be responsible for its compilation"
". When compilation finishes, the process is going to send a message to the mai"
"n process (the one responsible for coordinating compilation) that compilation "
"finished so a new file can be compiled."
msgstr ""

msgid "In Elixir, we could write this code as follows:"
msgstr ""

msgid ""
"    def spawn_compilers([current | files], output) do\n"
"      parent = Process.self()\n"
"      child  = spawn_link(fn ->\n"
"        :elixir_compiler.file_to_path(current, output)\n"
"        send parent, { :compiled, Process.self() }\n"
"      end)\n"
"      receive do\n"
"        { :compiled, ^child } ->\n"
"          spawn_compilers(files, output)\n"
"        { :EXIT, ^child, { reason, where } } ->\n"
"          :erlang.raise(:error, reason, where)\n"
"      end\n"
"    end"
msgstr ""

msgid ""
"    def spawn_compilers([], _output) do\n"
"      :done\n"
"    end"
msgstr ""

msgid ""
"In the first line, we define a function named `spawn_compilers` that receives "
"two arguments, the first is a list of files to compile and the second is a str"
"ing telling us where to write the compiled file. The first argument is represe"
"nted as a list with head and tail (`[current | files]`) where the top of the l"
"ist is assigned to `current` and the remaining items to `files`. If the list i"
"s empty, the first clause of `spawn_compilers` is not going to match, the clau"
"se `spawn_compilers([], _output)` defined at the end will instead."
msgstr ""

msgid ""
"Inside `spawn_compilers`, we first retrieve the PID of the current process wit"
"h `Process.self` (remember we are talking about Erlang processes/actors and no"
"t OS processes) and then proceed to spawn a new process to execute the given f"
"unction in parallel. Spawning a new process is done with the `spawn_link` func"
"tion."
msgstr ""

msgid ""
"The `spawn_link` function starts a new process and automatically links the cur"
"rent (parent) process with the spawned (child) one, returning the child PID. B"
"y linking the process we ensure that, if the child process dies, a message wil"
"l be sent to the parent process which then can act on it."
msgstr ""

msgid ""
"The function given to `spawn_link` is quite straight-forward. It simply invoke"
"s an Erlang function as `:elixir_compiler.file_to_path` and then proceeds to s"
"end a message to the parent process notifying that compilation finished."
msgstr ""

msgid ""
"After the child process is spawned, we invoke the `receive` macro and start wa"
"iting for messages. At this point, we are expecting two types of messages:"
msgstr ""

msgid ""
"* `{ :compiled, ^child }` - a message sent by the child informing us that comp"
"ilation finished. Note that use of `^` before the variable `child` to tell Eli"
"xir to match the current value of `child` with the one received in the message"
". If compilation succeeds, we move forward and spawn the next child by calling"
" `spawn_compilers` recursively;"
msgstr ""

msgid ""
"* `{ :EXIT, ^child, { reason, where } }` - this is the message sent by the chi"
"ld process in case it dies. This message is only received if the child is star"
"ted via `spawn_link`. In the message, we can find the reason why it failed and"
" the stacktrace. We then proceed to call an Erlang internal function to re-rai"
"se the error in the main process, effectively stopping compilation."
msgstr ""

msgid ""
"With this code, we were able to compile each file inside a different process. "
"However, notice that we are not yet compiling in parallel. Every time we spawn"
" a child process, we wait until it succeeds (or fails) before moving to the ne"
"xt step. We are going to eventually compile files in parallel, but before we r"
"each to this point, let's understand the problem of dependencies between files"
"."
msgstr ""

msgid "## Dependency between files"
msgstr ""

msgid ""
"Imagine that we have two files, `a.ex` and `b.ex`, with the following contents"
":"
msgstr ""

msgid ""
"    # a.ex\n"
"    defmodule A do\n"
"      B.define\n"
"    end"
msgstr ""

msgid ""
"    # b.ex\n"
"    defmodule B do\n"
"      defmacro define do\n"
"        quote do\n"
"          def one, do: 1\n"
"        end\n"
"      end\n"
"    end"
msgstr ""

msgid ""
"In order to compile `A`, we need to ensure that `B` is already compiled and lo"
"aded so we can invoke the `define` macro. This means the file `a.ex` depends o"
"n the file `b.ex`. When compiling files in parallel, we want to be able to det"
"ect such cases and automatically handle them."
msgstr ""

msgid ""
"The way we are going to handle this is by pausing compilation every time a mod"
"ule that was not yet defined is invoked. In this case, when compiling the file"
" `a.ex` and `B.define` is invoked, the process responsible for compiling `a.ex"
"` is going to pause and notify our main process. The main process will then st"
"art the compilation of other files. Whenever the module `B` is compiled, the m"
"ain process is going to tell the process responsible for `a.ex` to resume comp"
"ilation since its dependency `B` is now available."
msgstr ""

msgid ""
"In order to customize this process, we are going to take a look at Erlang's er"
"ror handler."
msgstr ""

msgid "## Custom error handler"
msgstr ""

msgid ""
"By default, Elixir (and Erlang) code is autoloaded. This means that, if we inv"
"oke `List.delete` and the module `List` was not loaded yet, the Erlang VM is g"
"oing to look into the `ebin` directory (the directory where we put compiled fi"
"les) and try to load it. This process is controlled by the [`error_handler` mo"
"dule in Erlang](http://www.erlang.org/doc/man/error_handler.html) via two call"
"back functions: `undefined_function` and `undefined_lambda`."
msgstr ""

msgid ""
"As discussed in the previous section, we want to extend the error handler to a"
"ctually stop the currently running process whenever a module is not found and "
"resume the process only after we ensure the module is compiled. To do that, we"
" can simply define our own error handler and ask Erlang to use it. Our custom "
"error handler is defined as follows:"
msgstr ""

msgid ""
"    defmodule Elixir.ErrorHandler do\n"
"      def undefined_function(module, fun, args) do\n"
"        ensure_loaded(module)\n"
"        :error_handler.undefined_function(module, fun, args)\n"
"      end"
msgstr ""

msgid ""
"      def undefined_lambda(module, fun, args) do\n"
"        ensure_loaded(module)\n"
"        :error_handler.undefined_lambda(module, fun, args)\n"
"      end"
msgstr ""

msgid ""
"      defp ensure_loaded(module) do\n"
"        case Code.ensure_loaded(module) do\n"
"          { :module, _ } ->\n"
"            []\n"
"          { :error, _ } ->\n"
"            parent = Process.get(:elixir_parent_compiler)\n"
"            send parent, { :waiting, Process.self, module }\n"
"            receive do\n"
"              { :release, ^parent } -> ensure_loaded(module)\n"
"            end\n"
"        end\n"
"      end\n"
"    end"
msgstr ""

msgid ""
"Our error handler defines two public functions. Both those functions are callb"
"acks required to be implemented by the error handler. They simply call `ensure"
"_loaded(module)` and then delegate the remaining logic to Erlang's original `e"
"rror_handler`."
msgstr ""

msgid ""
"The private `ensure_loaded` function calls `Code.ensure_loaded(module)` which "
"checks if the given module is loaded and, if not, tries to load it. In case it"
" succeeds, it returns `{ :module, _ }`, which means the module is available an"
"d we don't need to stop the current process. However, if it returns `{ :error,"
" _ }`, it means the module cannot be found and we need to wait until it is com"
"piled. For that, we invoke `Process.get(:elixir_parent_compiler)` to get the P"
"ID of the main process so we can notify it that we are waiting on a given modu"
"le. Then we invoke the macro `receive` as a way to stop the current process un"
"til we receive a message from the parent saying new modules are available, sta"
"rting the flow again."
msgstr ""

msgid ""
"With our error handler code in place, the first thing we need to do is to chan"
"ge the function given to `spawn_link` to use the new error handler:"
msgstr ""

msgid ""
"    spawn_link(fn ->\n"
"      Process.put(:elixir_parent_compiler, parent)\n"
"      Process.flag(:error_handler, Elixir.ErrorHandler)"
msgstr ""

msgid ""
"      :elixir_compiler.file_to_path(current, output)\n"
"      send parent, { :compiled, Process.self() }\n"
"    end)"
msgstr ""

msgid ""
"Notice that we have two small additions. First we store the `:elixir_parent_co"
"mpiler` PID in the process dictionary so we are able to read it from the error"
" handler and then we proceed to configure a flag in our process so our new err"
"or handler is invoked whenever a module or function cannot be found."
msgstr ""

msgid ""
"Second, our main process can now receive a new `{ :waiting, child, module }` m"
"essage, so we need to extend it to account for those messages. Not only that, "
"we need to control which PIDs we have spawned so we can notify them whenever a"
" new module is compiled, forcing us to add a new argument to the `spawn_compil"
"ers` function. `spawn_compilers` would then be rewritten as follows:"
msgstr ""

msgid ""
"    def spawn_compilers([current | files], output, stack) do\n"
"      parent = Process.self()\n"
"      child  = spawn_link(fn ->\n"
"        :elixir_compiler.file_to_path(current, output)\n"
"        send parent, { :compiled, Process.self() }\n"
"      end)\n"
"      wait_for_messages(files, output, [child | stack])\n"
"    end"
msgstr ""

msgid ""
"    # No more files and stack is empty, we are done\n"
"    def spawn_compilers([], _output, []) do\n"
"      :done\n"
"    end"
msgstr ""

msgid ""
"    # No more files and stack is not empty, wait for all messages\n"
"    def spawn_compilers([], output, stack) do\n"
"      wait_for_messages([], output, stack)\n"
"    end"
msgstr ""

msgid ""
"Notice we added an extra clause to `spawn_compilers` so we can properly handle"
" the case where we don't have more files to spawn but we are still waiting for"
" processes in the stack. We have also moved our `receive` logic to a new priva"
"te function called `wait_for_messages`, implemented as follows:"
msgstr ""

msgid ""
"    defp wait_for_messages(files, output, stack) do\n"
"      receive do\n"
"        { :compiled, child } ->\n"
"          new_stack = List.delete(stack, child)\n"
"          Enum.each new_stack, fn(pid) ->\n"
"            send pid, { :release, Process.self }\n"
"          end\n"
"          spawn_compilers(files, output, new_stack)\n"
"        { :waiting, _child, _module } ->\n"
"          spawn_compilers(files, output, stack)\n"
"        { :EXIT, _child, { reason, where } } ->\n"
"          :erlang.raise(:error, reason, where)\n"
"      after\n"
"        10_000 ->\n"
"          raise \"dependency on unexesting module or possible deadlock\"\n"
"      end\n"
"    end"
msgstr ""

msgid "The implementation for `wait_for_messages` is now broken into 4 clauses:"
msgstr ""

msgid ""
"* `{ :compiled, child }` - Similar as before, it is the notification a child p"
"rocessed finished compilation. Every time we receive such notifications, we re"
"move the child PID from the stack and notify the remaining PIDs in the stack t"
"hat new modules are available. Notice that we no longer match on a specific `^"
"child` PID, since now we can receive messages from different children at the s"
"ame time;"
msgstr ""

msgid ""
"* `{ :waiting, _child, _module }` - A message received every time a child proc"
"ess is waiting on a module to be compiled. In this scenario, all we do is spaw"
"n a new process to compile another file, ensuring compilation is never blocked"
";"
msgstr ""

msgid ""
"* `{ :EXIT, _child, { reason, where } }` - The same behaviour as before, it si"
"mply raises an error if any of the child processes fail;"
msgstr ""

msgid ""
"* `after: 10_000` - This clause is going to be invoked whenever the main proce"
"ss does not receive a message for 10 seconds. This means a file depends on a m"
"odule that does not exist (and therefore waits forever) or there is a cyclic d"
"ependency;"
msgstr ""

msgid ""
"And that's all we need to have a basic version of our parallel compilation wor"
"king. Notice we start compiling only one file at a time but, as soon as we dep"
"end on other files, the number of PIDs in the stack starts to grow. If we want"
"ed, we could modify the code to make use of a head start and compile more than"
" one file since the beginning."
msgstr ""

msgid ""
"It is important to notice that this code has room for improvements. First, eve"
"ry time a new module is compiled, we notify all child process that new modules"
" are available. This is a waste of resource if we consider that the child modu"
"les tells us explicitly on which modules they are waiting on. Therefore, the c"
"ode could be modified to store a mapping from each child process to the module"
" it is waiting for so that when a new module is compiled, only the children th"
"at depend on it are notified."
msgstr ""

msgid ""
"Also, if we start storing which module each process is depending on, we are ab"
"le to know whenever we have a deadlock or a dependency on an nonexistent file,"
" allowing us to get rid of the timeout."
msgstr ""

msgid ""
"All those improvements and other goodies like callbacks are implemented in Eli"
"xir source code and we recommend you take a look at both the [Elixir.ParallelC"
"ompiler](https://github.com/elixir-lang/elixir/blob/6182602f1205e2d9fc54666e07"
"21270a27226fbc/lib/elixir/parallel_compiler.ex) and [Elixir.ErrorHandler](http"
"s://github.com/elixir-lang/elixir/blob/6182602f1205e2d9fc54666e0721270a27226fb"
"c/lib/elixir/error_handler.ex) modules to see all the details firsthand."
msgstr ""

msgid "Happy coding!"
msgstr ""
