msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"title: \"Erlang/Elixir Syntax: A Crash Course\"\n"
"section: home\n"
"layout: default\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid ""
"This is a quick introduction to the Elixir syntax for Erlang developers and vi"
"ce-versa. It is the absolute minimum amount of knowledge you need in order to "
"understand Elixir/Erlang code, support interoperability, read the docs, sample"
" code, etc."
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid "## Running code"
msgstr ""

msgid "### Erlang"
msgstr ""

msgid ""
"The fastest way to run some code is to launch the Erlang shell -- `erl`. Many "
"code snippets on this page can be pasted directly into the shell. However, whe"
"n you want to define a named function, Erlang expects it to be inside of a mod"
"ule, and modules have to be compiled. Here's a skeleton for a module:"
msgstr ""

msgid ""
"```erlang\n"
"% module_name.erl\n"
"-module(module_name).  % you may use some other name\n"
"-compile(export_all)."
msgstr ""

msgid ""
"hello() ->\n"
"  io:format(\"~s~n\", [\"Hello world!\"]).\n"
"```"
msgstr ""

msgid ""
"Add your functions to it, save it to disk, run `erl` from the same directory a"
"nd execute the `compile` command:"
msgstr ""

msgid ""
"```erl\n"
"Eshell V5.9  (abort with ^G)\n"
"1> c(module_name).\n"
"ok\n"
"1> module_name:hello().\n"
"Hello world!\n"
"ok\n"
"```"
msgstr ""

msgid ""
"You may keep the shell running while you're editing the file. Just don't forge"
"t to execute `c(module_name)` to load the latest changes. Note that the filena"
"me has to be the same as the one declared in the `-module()` directive, plus a"
"n extension `.erl`."
msgstr ""

msgid "### Elixir"
msgstr ""

msgid ""
"Elixir too has an interactive shell called `iex`. Compiling Elixir code can be"
" done with `elixirc` (which is similar to Erlang's `erlc`). Elixir also provid"
"es an executable named `elixir` to run Elixir code. The module defined above c"
"an be written in Elixir as:"
msgstr ""

msgid ""
"```elixir\n"
"# module_name.ex\n"
"defmodule ModuleName do\n"
"  def hello do\n"
"    IO.puts \"Hello World\"\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid "And compiled from `iex`:"
msgstr ""

msgid ""
"```iex\n"
"Interactive Elixir\n"
"iex> c(\"module_name.ex\")\n"
"[ModuleName]\n"
"iex> ModuleName.hello\n"
"Hello world!\n"
":ok\n"
"```"
msgstr ""

msgid ""
"However notice that in Elixir you don't need to create a file only to create a"
" new module, Elixir modules can be defined directly in the shell:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule MyModule do\n"
"  def hello do\n"
"    IO.puts \"Another Hello\"\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid "## Notable differences"
msgstr ""

msgid ""
"This section goes over some of the syntactic differences between the two langu"
"ages."
msgstr ""

msgid "### Operator names"
msgstr ""

msgid "Some operators are spelled differently."
msgstr ""

msgid ""
"| Erlang         | Elixir         | Meaning                                 |\n"
"|----------------|----------------|-----------------------------------------|\n"
"| and            | NOT AVAILABLE  | Logical 'and', evaluates both arguments |\n"
"| andalso        | and            | Logical 'and', short-circuits           |\n"
"| or             | NOT AVAILABLE  | Logical 'or', evaluates both arguments  |\n"
"| orelse         | or             | Logical 'or', short-circuits            |\n"
"| =:=            | ===            | A match operator                        |\n"
"| =/=            | !==            | A negative match                        |\n"
"| /=             | !=             | Not equals                              |\n"
"| =<             | <=             | Less than or equals                     |"
msgstr ""

msgid "### Delimiters"
msgstr ""

msgid ""
"Erlang expressions are terminated with a dot `.` and comma `,` is used to eval"
"uate multiple expressions within one context (in a function definition, for in"
"stance). In Elixir, expressions are delimited by a line break or a semicolon `"
";`."
msgstr ""

msgid "**Erlang**"
msgstr ""

msgid ""
"```erlang\n"
"X = 2, Y = 3.\n"
"X + Y.\n"
"```"
msgstr ""

msgid "**Elixir**"
msgstr ""

msgid ""
"```elixir\n"
"x = 2; y = 3\n"
"x + y\n"
"```"
msgstr ""

msgid "### Variable names"
msgstr ""

msgid ""
"Variables in Erlang can only be assigned once. The Erlang shell provides a spe"
"cial command `f` that allows you to erase the binding of a variable or all var"
"iables at once."
msgstr ""

msgid ""
"Elixir allows you to assign to a variable more than once. If you want to match"
" against the value of a previously assigned variable, you should use `^`:"
msgstr ""

msgid ""
"```erl\n"
"Eshell V5.9  (abort with ^G)\n"
"1> X = 10.\n"
"10\n"
"2> X = X + 1.\n"
"** exception error: no match of right hand side value 11\n"
"3> X1 = X + 1.\n"
"11\n"
"4> f(X).\n"
"ok\n"
"5> X = X1 * X1.\n"
"121\n"
"6> f().\n"
"ok\n"
"7> X.\n"
"* 1: variable 'X' is unbound\n"
"8> X1.\n"
"* 1: variable 'X1' is unbound\n"
"```"
msgstr ""

msgid ""
"```iex\n"
"iex> a = 1\n"
"1\n"
"iex> a = 2\n"
"2\n"
"iex> ^a = 3\n"
"** (MatchError) no match of right hand side value: 3\n"
"```"
msgstr ""

msgid "### Calling functions"
msgstr ""

msgid ""
"Invoking a function from a module uses different syntax. In Erlang, you would "
"write"
msgstr ""

msgid ""
"```erlang\n"
"lists:last([1, 2]).\n"
"```"
msgstr ""

msgid ""
"to invoke the `last` function from the `List` module. In Elixir, use the dot `"
".` in place of the colon `:`"
msgstr ""

msgid ""
"```elixir\n"
"List.last([1, 2])\n"
"```"
msgstr ""

msgid ""
"**Note**. Since Erlang modules are represented by atoms, you may invoke Erlang"
" functions in Elixir as follows:"
msgstr ""

msgid ""
"```elixir\n"
":lists.sort([3, 2, 1])\n"
"```"
msgstr ""

msgid "All of the Erlang built-ins reside in the `:erlang` module."
msgstr ""

msgid "## Data types"
msgstr ""

msgid ""
"Erlang and Elixir have the same data types for the most part, but there are a "
"number of differences."
msgstr ""

msgid "### Atoms"
msgstr ""

msgid ""
"In Erlang, an `atom` is any identifier that starts with a lowercase letter, e."
"g. `ok`, `tuple`, `donut`. Identifiers that start with a capital letter are al"
"ways treated as variable names. Elixir, on the other hand, uses the former for"
" naming variables, and the latter are treated as atom aliases. Atoms in Elixir"
" always start with a colon `:`."
msgstr ""

msgid ""
"```erlang\n"
"im_an_atom.\n"
"me_too."
msgstr ""

msgid ""
"Im_a_var.\n"
"X = 10.\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
":im_an_atom\n"
":me_too"
msgstr ""

msgid ""
"im_a_var\n"
"x = 10"
msgstr ""

msgid ""
"Module  # this is called an atom alias; it expands to :'Elixir.Module'\n"
"```"
msgstr ""

msgid ""
"It is also possible to create atoms that start with a character other than a l"
"owercase letter. The syntax is different between the two languages:"
msgstr ""

msgid ""
"```erlang\n"
"is_atom(ok).                %=> true\n"
"is_atom('0_ok').            %=> true\n"
"is_atom('Multiple words').  %=> true\n"
"is_atom('').                %=> true\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"is_atom :ok                 #=> true\n"
"is_atom :'ok'               #=> true\n"
"is_atom Ok                  #=> true\n"
"is_atom :\"Multiple words\"   #=> true\n"
"is_atom :\"\"                 #=> true\n"
"```"
msgstr ""

msgid "### Tuples"
msgstr ""

msgid ""
"The syntax for tuples is the same in both languages, but the APIs are differen"
"t. Elixir attempts to normalize Erlang libraries in a way that:"
msgstr ""

msgid ""
"1. The `subject` of the function is always the first argument.\n"
"2. All data structures functions employ zero-based access."
msgstr ""

msgid ""
"That said, Elixir does not import the default `element` and `setelement` funct"
"ions, but instead provides `elem` and `put_elem`:"
msgstr ""

msgid ""
"```erlang\n"
"element(1, {a, b, c}).       %=> a\n"
"setelement(1, {a, b, c}, d). %=> {d, b, c}\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"elem({:a, :b, :c}, 0)         #=> :a\n"
"put_elem({:a, :b, :c}, 0, :d) #=> {:d, :b, :c}\n"
"```"
msgstr ""

msgid "### Lists and binaries"
msgstr ""

msgid "Elixir has a shortcut syntax for binaries:"
msgstr ""

msgid ""
"```erlang\n"
"is_list('Hello').        %=> false\n"
"is_list(\"Hello\").        %=> true\n"
"is_binary(<<\"Hello\">>).  %=> true\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"is_list 'Hello'          #=> true\n"
"is_binary \"Hello\"        #=> true\n"
"is_binary <<\"Hello\">>    #=> true\n"
"<<\"Hello\">> === \"Hello\"  #=> true\n"
"```"
msgstr ""

msgid ""
"In Elixir, the word **string** means a UTF-8 binary and there is a `String` mo"
"dule that works on such data. Elixir also expects your source files to be UTF-"
"8 encoded. On the other hand, **string** in Erlang refers to char lists and th"
"ere is a `:string` module, that's not UTF-8 aware and works mostly with char l"
"ists."
msgstr ""

msgid "Elixir also supports multiline strings (also called *heredocs*):"
msgstr ""

msgid ""
"```elixir\n"
"is_binary \"\"\"\n"
"This is a binary\n"
"spanning several\n"
"lines.\n"
"\"\"\"\n"
"#=> true\n"
"```"
msgstr ""

msgid "### Keyword list"
msgstr ""

msgid ""
"Elixir offers a literal syntax for creating a list of two-item tuples where th"
"e first item in the tuple is an atom and calls them keyword lists:"
msgstr ""

msgid ""
"```erlang\n"
"Proplist = [{another_key, 20}, {key, 10}].\n"
"proplists:get_value(another_key, Proplist).\n"
"%=> 20\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"kw = [another_key: 20, key: 10]\n"
"kw[:another_key]\n"
"#=> 20\n"
"```"
msgstr ""

msgid "### Maps"
msgstr ""

msgid ""
"Erlang R17 introduced maps, a key-value store, with no ordering. Keys and valu"
"es can be any term. Creating, updating and matching maps in both languages is "
"shown below:"
msgstr ""

msgid ""
"```erlang\n"
"Map = #{key => 0}.\n"
"Updated = Map#{key := 1}.\n"
"#{key := Value} = Updated.\n"
"Value =:= 1.\n"
"%=> true\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"map = %{:key => 0}\n"
"map = %{map | :key => 1}\n"
"%{:key => value} = map\n"
"value === 1\n"
"#=> true\n"
"```"
msgstr ""

msgid ""
"If the keys are all atoms, Elixir allows developers to use `key: 0` for defini"
"ng the map as well as using `.key` for accessing fields:"
msgstr ""

msgid ""
"```elixir\n"
"map = %{key: 0}\n"
"map = %{map | key: 1}\n"
"map.key === 1\n"
"```"
msgstr ""

msgid "### Regular expressions"
msgstr ""

msgid ""
"Elixir supports a literal syntax for regular expressions. Such syntax allows r"
"egexes to be compiled at compilation time instead of runtime and does not requ"
"ire you to double escape special regex characters:"
msgstr ""

msgid ""
"```erlang\n"
"{ ok, Pattern } = re:compile(\"abc\\\\s\").\n"
"re:run(\"abc \", Pattern).\n"
"%=> { match, [\"abc \"] }\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"Regex.run ~r/abc\\s/, \"abc \"\n"
"#=> [\"abc \"]\n"
"```"
msgstr ""

msgid ""
"Regexes are also supported in heredocs, which is convenient when defining mult"
"iline regexes:"
msgstr ""

msgid ""
"```elixir\n"
"Regex.regex? ~r\"\"\"\n"
"This is a regex\n"
"spanning several\n"
"lines.\n"
"\"\"\"\n"
"#=> true\n"
"```"
msgstr ""

msgid "## Modules"
msgstr ""

msgid "Each Erlang module lives in its own file which has the following structure:"
msgstr ""

msgid ""
"```erlang\n"
"-module(hello_module).\n"
"-export([some_fun/0, some_fun/1])."
msgstr ""

msgid ""
"% A \"Hello world\" function\n"
"some_fun() ->\n"
"  io:format('~s~n', ['Hello world!'])."
msgstr ""

msgid ""
"% This one works only with lists\n"
"some_fun(List) when is_list(List) ->\n"
"  io:format('~s~n', List)."
msgstr ""

msgid ""
"% Non-exported functions are private\n"
"priv() ->\n"
"  secret_info.\n"
"```"
msgstr ""

msgid ""
"Here we create a module named ``hello_module``. In it we define three function"
"s, the first two are made available for other modules to call via the ``export"
"`` directive at the top. It contains a list of functions, each of which is wri"
"tten in the format ``<function name>/<arity>``. Arity stands for the number of"
" arguments."
msgstr ""

msgid "An Elixir equivalent to the Erlang above:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule HelloModule do\n"
"  # A \"Hello world\" function\n"
"  def some_fun do\n"
"    IO.puts \"Hello world!\"\n"
"  end"
msgstr ""

msgid ""
"  # This one works only with lists\n"
"  def some_fun(list) when is_list(list) do\n"
"    IO.inspect list\n"
"  end"
msgstr ""

msgid ""
"  # A private function\n"
"  defp priv do\n"
"    :secret_info\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"In Elixir, it is also possible to have multiple modules in one file, as well a"
"s nested modules:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule HelloModule do\n"
"  defmodule Utils do\n"
"    def util do\n"
"      IO.puts \"Utilize\"\n"
"    end"
msgstr ""

msgid ""
"    defp priv do\n"
"      :cant_touch_this\n"
"    end\n"
"  end"
msgstr ""

msgid ""
"  def dummy do\n"
"    :ok\n"
"  end\n"
"end"
msgstr ""

msgid ""
"defmodule ByeModule do\n"
"end"
msgstr ""

msgid ""
"HelloModule.dummy\n"
"#=> :ok"
msgstr ""

msgid ""
"HelloModule.Utils.util\n"
"#=> \"Utilize\""
msgstr ""

msgid ""
"HelloModule.Utils.priv\n"
"#=> ** (UndefinedFunctionError) undefined function: HelloModule.Utils.priv/0\n"
"```"
msgstr ""

msgid "## Function syntax"
msgstr ""

msgid ""
"[This chapter][3] from the Erlang book provides a detailed description of patt"
"ern matching and function syntax in Erlang. Here, I'm briefly covering the mai"
"n points and provide sample code both in Erlang and Elixir."
msgstr ""

msgid "[3]: http://learnyousomeerlang.com/syntax-in-functions"
msgstr ""

msgid "### Pattern matching"
msgstr ""

msgid ""
"Pattern matching in Elixir is based on Erlang's implementation and in general "
"is very similar:"
msgstr ""

msgid ""
"```erlang\n"
"loop_through([H | T]) ->\n"
"  io:format('~p~n', [H]),\n"
"  loop_through(T);"
msgstr ""

msgid ""
"loop_through([]) ->\n"
"  ok.\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"def loop_through([h | t]) do\n"
"  IO.inspect h\n"
"  loop_through t\n"
"end"
msgstr ""

msgid ""
"def loop_through([]) do\n"
"  :ok\n"
"end\n"
"```"
msgstr ""

msgid ""
"When defining a function with the same name multiple times, each such definiti"
"on is called a **clause**. In Erlang, clauses always go side by side and are s"
"eparated by a semicolon ``;``. The last clause is terminated by a dot ``.``."
msgstr ""

msgid ""
"Elixir doesn't require punctuation to separate clauses, but they must be group"
"ed together."
msgstr ""

msgid "### Identifying functions"
msgstr ""

msgid ""
"In both Erlang and Elixir, a function is not identified only by its name, but "
"by its name and arity. In both examples below, we are defining four different "
"functions (all named `sum`, but with different arity):"
msgstr ""

msgid ""
"```erlang\n"
"sum() -> 0.\n"
"sum(A) -> A.\n"
"sum(A, B) -> A + B.\n"
"sum(A, B, C) -> A + B + C.\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"def sum, do: 0\n"
"def sum(a), do: a\n"
"def sum(a, b), do: a + b\n"
"def sum(a, b, c), do: a + b + c\n"
"```"
msgstr ""

msgid ""
"Guard expressions provide a concise way to define functions that accept a limi"
"ted set of values based on some condition."
msgstr ""

msgid ""
"```erlang\n"
"sum(A, B) when is_integer(A), is_integer(B) ->\n"
"  A + B;"
msgstr ""

msgid ""
"sum(A, B) when is_list(A), is_list(B) ->\n"
"  A ++ B;"
msgstr ""

msgid ""
"sum(A, B) when is_binary(A), is_binary(B) ->\n"
"  <<A/binary,  B/binary>>."
msgstr ""

msgid ""
"sum(1, 2).\n"
"%=> 3"
msgstr ""

msgid ""
"sum([1], [2]).\n"
"%=> [1, 2]"
msgstr ""

msgid ""
"sum(\"a\", \"b\").\n"
"%=> \"ab\"\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"def sum(a, b) when is_integer(a) and is_integer(b) do\n"
"  a + b\n"
"end"
msgstr ""

msgid ""
"def sum(a, b) when is_list(a) and is_list(b) do\n"
"  a ++ b\n"
"end"
msgstr ""

msgid ""
"def sum(a, b) when is_binary(a) and is_binary(b) do\n"
"  a <> b\n"
"end"
msgstr ""

msgid ""
"sum 1, 2\n"
"#=> 3"
msgstr ""

msgid ""
"sum [1], [2]\n"
"#=> [1, 2]"
msgstr ""

msgid ""
"sum \"a\", \"b\"\n"
"#=> \"ab\"\n"
"```"
msgstr ""

msgid "### Default values"
msgstr ""

msgid ""
"In addition, Elixir allows for default values for arguments, whereas Erlang do"
"es not."
msgstr ""

msgid ""
"```elixir\n"
"def mul_by(x, n \\\\ 2) do\n"
"  x * n\n"
"end"
msgstr ""

msgid ""
"mul_by 4, 3 #=> 12\n"
"mul_by 4    #=> 8\n"
"```"
msgstr ""

msgid "### Anonymous functions"
msgstr ""

msgid "Anonymous functions are defined in the following way:"
msgstr ""

msgid ""
"```erlang\n"
"Sum = fun(A, B) -> A + B end.\n"
"Sum(4, 3).\n"
"%=> 7"
msgstr ""

msgid ""
"Square = fun(X) -> X * X end.\n"
"lists:map(Square, [1, 2, 3, 4]).\n"
"%=> [1, 4, 9, 16]\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"sum = fn(a, b) -> a + b end\n"
"sum.(4, 3)\n"
"#=> 7"
msgstr ""

msgid ""
"square = fn(x) -> x * x end\n"
"Enum.map [1, 2, 3, 4], square\n"
"#=> [1, 4, 9, 16]\n"
"```"
msgstr ""

msgid "It is possible to use pattern matching when defining anonymous functions, too."
msgstr ""

msgid ""
"```erlang\n"
"F = fun(Tuple = {a, b}) ->\n"
"        io:format(\"All your ~p are belong to us~n\", [Tuple]);\n"
"        ([]) ->\n"
"        \"Empty\"\n"
"    end."
msgstr ""

msgid ""
"F([]).\n"
"%=> \"Empty\""
msgstr ""

msgid ""
"F({a, b}).\n"
"%=> \"All your {a, b} are belong to us\"\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"f = fn\n"
"      {:a, :b} = tuple ->\n"
"        IO.puts \"All your #{inspect tuple} are belong to us\"\n"
"      [] ->\n"
"        \"Empty\"\n"
"    end"
msgstr ""

msgid ""
"f.([])\n"
"#=> \"Empty\""
msgstr ""

msgid ""
"f.({:a, :b})\n"
"#=> \"All your {:a, :b} are belong to us\"\n"
"```"
msgstr ""

msgid "### First-class functions"
msgstr ""

msgid ""
"Anonymous functions are first-class values, so they can be passed as arguments"
" to other functions and also can serve as a return value. There is a special s"
"yntax to allow named functions be treated in the same manner."
msgstr ""

msgid ""
"```erlang\n"
"% math.erl\n"
"-module(math).\n"
"-export([square/1])."
msgstr ""

msgid ""
"square(X) -> X * X.\n"
"```"
msgstr ""

msgid ""
"```erl\n"
"Eshell V5.9  (abort with ^G)\n"
"1> c(math).\n"
"{ok,math}\n"
"2> lists:map(fun math:square/1, [1, 2, 3]).\n"
"[1,4,9]\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"defmodule Math do\n"
"  def square(x) do\n"
"    x * x\n"
"  end\n"
"end"
msgstr ""

msgid ""
"Enum.map [1, 2, 3], &Math.square/1\n"
"#=> [1, 4, 9]\n"
"```"
msgstr ""

msgid "### Partials and function captures in Elixir"
msgstr ""

msgid ""
"Elixir supports partial application of functions which can be used to define a"
"nonymous functions in a concise way:"
msgstr ""

msgid ""
"```elixir\n"
"Enum.map [1, 2, 3, 4], &(&1 * 2)\n"
"#=> [2, 4, 6, 8]"
msgstr ""

msgid ""
"List.foldl [1, 2, 3, 4], 0, &(&1 + &2)\n"
"#=> 10\n"
"```"
msgstr ""

msgid ""
"We use the same `&` operator to capture a function, allowing us to pass named "
"functions as arguments."
msgstr ""

msgid "The above would be equivalent to Erlang's `fun math:square/1`."
msgstr ""

msgid "## Control flow"
msgstr ""

msgid ""
"The constructs `if` and `case` are actually expressions in both Erlang and Eli"
"xir, but may be used for control flow as in imperative languages."
msgstr ""

msgid "### Case"
msgstr ""

msgid "The ``case`` construct provides control flow based purely on pattern matching."
msgstr ""

msgid ""
"```erlang\n"
"case {X, Y} of\n"
"  {a, b} -> ok;\n"
"  {b, c} -> good;\n"
"  Else -> Else\n"
"end\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"case {x, y} do\n"
"  {:a, :b} -> :ok\n"
"  {:b, :c} -> :good\n"
"  other -> other\n"
"end\n"
"```"
msgstr ""

msgid "### If"
msgstr ""

msgid ""
"```erlang\n"
"Test_fun = fun (X) ->\n"
"  if X > 10 ->\n"
"       greater_than_ten;\n"
"     X < 10, X > 0 ->\n"
"       less_than_ten_positive;\n"
"     X < 0; X =:= 0 ->\n"
"       zero_or_negative;\n"
"     true ->\n"
"       exactly_ten\n"
"  end\n"
"end."
msgstr ""

msgid ""
"Test_fun(11).\n"
"%=> greater_than_ten"
msgstr ""

msgid ""
"Test_fun(-2).\n"
"%=> zero_or_negative"
msgstr ""

msgid ""
"Test_fun(10).\n"
"%=> exactly_ten\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"test_fun = fn(x) ->\n"
"  cond do\n"
"    x > 10 ->\n"
"      :greater_than_ten\n"
"    x < 10 and x > 0 ->\n"
"      :less_than_ten_positive\n"
"    x < 0 or x === 0 ->\n"
"      :zero_or_negative\n"
"    true ->\n"
"      :exactly_ten\n"
"  end\n"
"end"
msgstr ""

msgid ""
"test_fun.(44)\n"
"#=> :greater_than_ten"
msgstr ""

msgid ""
"test_fun.(0)\n"
"#=> :zero_or_negative"
msgstr ""

msgid ""
"test_fun.(10)\n"
"#=> :exactly_ten\n"
"```"
msgstr ""

msgid "There are two important differences between Elixir's `cond` and Erlang's `if`:"
msgstr ""

msgid ""
"1) `cond` allows any expression on the left side while Erlang allows only guar"
"d clauses;"
msgstr ""

msgid ""
"2) `cond` uses Elixir's concepts of truthy and falsy values (everything is tru"
"thy except `nil` and `false`), Erlang's `if` expects strictly a boolean;"
msgstr ""

msgid ""
"Elixir also provides an `if` function that resembles more imperative languages"
" and is useful when you need to check if one clause is true or false:"
msgstr ""

msgid ""
"```elixir\n"
"if x > 10 do\n"
"  :greater_than_ten\n"
"else\n"
"  :not_greater_than_ten\n"
"end\n"
"```"
msgstr ""

msgid "### Sending and receiving messages"
msgstr ""

msgid ""
"The syntax for sending and receiving differs only slightly between Erlang and "
"Elixir."
msgstr ""

msgid ""
"```erlang\n"
"Pid = self()."
msgstr ""

msgid "Pid ! {hello}."
msgstr ""

msgid ""
"receive\n"
"  {hello} -> ok;\n"
"  Other -> Other\n"
"after\n"
"  10 -> timeout\n"
"end.\n"
"```"
msgstr ""

msgid ""
"```elixir\n"
"pid = Kernel.self"
msgstr ""

msgid "send pid, {:hello}"
msgstr ""

msgid ""
"receive do\n"
"  {:hello} -> :ok\n"
"  other -> other\n"
"after\n"
"  10 -> :timeout\n"
"end\n"
"```"
msgstr ""

msgid "## Adding Elixir to existing Erlang programs"
msgstr ""

msgid ""
"Elixir compiles into BEAM byte code (via Erlang Abstract Format). This means t"
"hat Elixir code can be called from Erlang and vice versa, without the need to "
"write any bindings. All Elixir modules start with the `Elixir.` prefix followe"
"d by the regular Elixir name. For example, here is how to use the UTF-8 aware "
"`String` downcase from Elixir in Erlang:"
msgstr ""

msgid ""
"```erlang\n"
"-module(bstring).\n"
"-export([downcase/1])."
msgstr ""

msgid ""
"downcase(Bin) ->\n"
"  'Elixir.String':downcase(Bin).\n"
"```"
msgstr ""

msgid "### Rebar integration"
msgstr ""

msgid ""
"If you are using rebar, you should be able to include Elixir git repository as"
" a dependency:"
msgstr ""

msgid "    https://github.com/elixir-lang/elixir.git"
msgstr ""

msgid ""
"Elixir is structured similar to Erlang's OTP. It is divided into applications "
"that are placed inside the `lib` directory, as seen in its [source code reposi"
"tory](https://github.com/elixir-lang/elixir). Since rebar does not recognize s"
"uch structure, we need to explicitly add to our `rebar.config` which Elixir ap"
"ps we want to use, for example:"
msgstr ""

msgid ""
"```erlang\n"
"{lib_dirs, [\n"
"  \"deps/elixir/lib\"\n"
"]}.\n"
"```"
msgstr ""

msgid ""
"This should be enough to invoke Elixir functions straight from your Erlang cod"
"e. If you are also going to write Elixir code, you can [install Elixir's rebar"
" plugin for automatic compilation](https://github.com/yrashk/rebar_elixir_plug"
"in)."
msgstr ""

msgid "### Manual integration"
msgstr ""

msgid ""
"If you are not using rebar, the easiest approach to use Elixir in your existin"
"g Erlang software is to install Elixir using one of the different ways specifi"
"ed in the [Getting Started guide](/getting-started/introduction.html) and add "
"the `lib` directory in your checkout to `ERL_LIBS`."
msgstr ""

msgid "## Further reading"
msgstr ""

msgid ""
"Erlang's official documentation site has a nice [collection][4] of programming"
" examples. It can be a good exercise to translate them into Elixir."
msgstr ""

msgid ""
"Elixir also provides a [Getting Started guide][6] and has [documentation avail"
"able online][7]."
msgstr ""

msgid ""
"[4]: http://www.erlang.org/doc/programming_examples/users_guide.html\n"
"[6]: /getting-started/introduction.html\n"
"[7]: /docs.html"
msgstr ""
