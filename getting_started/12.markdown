---
layout: getting_started
title: 12 Module attributes
guide: 12
---

# {{ page.title }}

Module attributes in Elixir serves three purposes:

1. They serve to annotate the module, often with information to be used by the user or the VM;
2. They work as constants;
3. They work as a temporary module storage to be used during compilation;

Let's check each case, one by one.

## 12.1 As annotations

Elixir brings the concept of module attributes from Erlang. For example:

```elixir
defmodule MyServer do
  @vsn 2
end
```

In the example above, we are explicitly setting the version attribute for that module. `@vsn` is used by the code reloading mechanism in the Erlang VM to check if a module has been updated or not. If no version is specified, the version is set to the MD5 checksum of the module functions.

Elixir has a handful of reserved attributes. Here are just a few of them, the most commonly used ones:

* `@moduledoc` - provides documentation for the current module;
* `@doc` - provides documentation for the function or macro that follows the attribute;
* `@behaviour` - (notice the British spelling) used for specifying an OTP or user-defined behaviour;
* `@before_compile` - provides a hook that will be invoked before the module is compiled. This makes it possible to inject functions inside the module exactly before compilation;

`@moduledoc` and `@doc` are by far the most used attributes and we expect you to use them a lot. Elixir treats documentation as first-class and provide many functions to access documentation:

```iex
iex> defmodule MyModule do
...>  @moduledoc "It does **x**"
...>
...>  @doc """
...>  Returns the version
...>  """
...>  def version, do: 1
...> end
{:module, MyModule, <<70, 79, 82, ...>>, {:version, 0}}
iex> h MyModule
* MyModule

It does **x**

iex> h MyModule.version
* def version()

Returns the version

```

Elixir promotes the use of markdown with heredocs to write readable documentation:

```elixir
defmodule Math do
  @moduledoc """
  This module provides mathematical functions
  as sin, cos and constants like pi.

  ## Examples

      Math.pi
      #=> 3.1415...

  """
end
```

We also provide a tool called [ExDoc](https://github.com/elixir-lang/ex_doc) which is used to generate HTML pages with the documentation.

You can take a look at the docs for [Module](/docs/stable/Module.html) for a complete list of supported attributes. Elixir also uses attributes to define [typespecs](/docs/stable/Kernel.Typespec.html), via:

* `@spec` - provides a specification for a function;
* `@callback` - provides a specification for the behavior callback;
* `@type` - defines a type to be used in `@spec`;
* `@typep` - defines a private type to be used in `@spec`;
* `@opaque` - defines an opaque type to be used in `@spec`;

This section covers built-in attributes. However, attributes can also be used by developers or extended by libraries to support custom behaviour.

## 12.2 As constants

Elixir developers will often use module attributes to be used as constants:

```elixir
defmodule MyServer do
  @initial_state %{host: "127.0.0.1", port: 3456}
  IO.inspect @initial_state
end
```

> Note: Unlike Erlang, user defined attributes are not stored in the module by default. The value exists only during compilation time. A developer can configure an attribute to behave closer to Erlang by calling [`Module.register_attribute/3`](/docs/stable/Module.html#register_attribute/3).

Trying to access an attribute that was not previously defined will raise a warning:

```elixir
defmodule MyServer do
  @unknown
end
warning: undefined module attribute @unknown, please remove access to @unknown or explicitly set it to nil before access
```

Finally, attributes can also be read inside functions:

```elixir
defmodule MyServer do
  @my_data 11
  def first_data, do: @my_data
  @my_data 13
  def second_data, do: @my_data
end

MyServer.first_data #=> 11
MyServer.second_data #=> 13
```

Notice that reading an attribute inside a function takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. As we are going to see, this makes attributes useful to be used as storage during the module compilation.

## 12.3 As temporary storage

One of the projects in the Elixir organization is [the `Plug` project](https://github.com/elixir-lang/plug), which is meant to be a common foundation for building web libraries and frameworks in Elixir.

The Plug library also allows developers to define their own plugs which can be run in a web server:

```elixir
defmodule MyPlug do
  use Plug.Builder

  plug :set_header
  plug :send_ok

  def set_header(conn, _opts) do
    put_resp_header(conn, "x-header", "set")
  end

  def send_ok(conn, _opts) do
    send(conn, 200, "ok")
  end
end

IO.puts "Running MyPlug with Cowboy on http://localhost:4000"
Plug.Adapters.Cowboy.http MyPlug, []
```

In the example above, we have used the `plug/1` macro to connect functions that will be invoked when there is a web request. Internally, every time you call `plug/1`, the Plug library stores the given arguments as a list in a `@plugs` attribute. At the end, before the module is compiled, Plug runs a callback (registered via the `@before_compile` module attribute) that will then compile all `@plugs` into actual function calls.

In order to understand the underlying code, we'd need macros, so we will revisit this pattern later on. However, the focus here is exactly on how using module attributes as storage allow developers to create DSLs. Note only they are elegant DSLs but using them with a combination of `@before_compile` callbacks allows developers to generate code that performs well.

Another example comes from the ExUnit framework, that uses module attributes as annotation and storage:

```elixir
defmodule MyTest do
  use ExUnit.Case

  @tag :external
  test "contacts external service" do
    # ...
  end
end
```

Tags in ExUnit are used to annotate tests. Tags can be later used to filter tests, so you don't run external tests by default locally, since they can be slow, while you can leave them enabled in your builds. Internally, those tags are stored in temporary module attributes, associating each test to their respective tags, so it can be later fetched and filtered by the test framework.

We hope this section shows some light on how Elixir supports meta-programming and how module attributes play an important role when doing so. In the next chapters, we will talk about some common modules in Elixir, like `IO` and `Enum`, before finally going into more advanced topics, like macros.
