---
layout: getting_started
title: 5 case, cond and if
guide: 5
---

# {{ page.title }}

In this chapter we will learn about `case`, `cond` and `if` control-flow structures.

## 5.1 case

A `case` allows us to compare a value against many patterns until we find a matching one:

```iex
iex> case {1, 2, 3} do
...>   {4, 5, 6} ->
...>     "This clause won't match"
...>   {1, x, 3} ->
...>     "This clause will match and bind x to 2 in this clause"
...>   _ ->
...>     "This clause would match any value"
...> end
```

If you want to pattern match against an existing variable, you need to use the `^` operator:

```iex
iex> x = 1
1
iex> case 10 do
...>   ^x -> "Won't match"
...>   _  -> "Will match"
...> end
```

Clauses also allow extra conditions to be specified via guards:

```iex
iex> case {1, 2, 3} do
...>   {1, x, 3} when x > 0 ->
...>     "Will match"
...>   _ ->
...>     "Won't match"
...> end
```

The first clause above will only match when `x` is positive. The Erlang VM only allows a limited set of expressions in guards:

* comparison operators (`==`, `!=`, `===`, `!==`, `>`, `<`, `<=`, `>=`);
* boolean operators (`and`, `or`) and negation operators (`not`, `!`);
* arithmetic operators (`+`, `-`, `*`, `/`);
* `<>` and `++` as long as the left side is a literal;
* the `in` operator;
* all the following type check functions:

    * `is_atom/1`
    * `is_binary/1`
    * `is_bitstring/1`
    * `is_boolean/1`
    * `is_float/1`
    * `is_function/1`
    * `is_function/2`
    * `is_integer/1`
    * `is_list/1`
    * `is_map/1`
    * `is_number/1`
    * `is_pid/1`
    * `is_port/1`
    * `is_reference/1`
    * `is_tuple/1`

* plus these functions:

    * `abs(number)`
    * `bit_size(bitstring)`
    * `byte_size(bitstring)`
    * `div(integer, integer)`
    * `elem(tuple, n)`
    * `hd(list)`
    * `length(list)`
    * `map_size(map)`
    * `node()`
    * `node(pid | ref | port)`
    * `rem(integer, integer)`
    * `round(number)`
    * `self()`
    * `size(tuple | bitstring)`
    * `tl(list)`
    * `trunc(number)`
    * `tuple_size(tuple)`

Keep in mind errors in guards do not leak but simply make the guard fail:

```iex
iex> hd(1)
** (ArgumentError) argument error
    :erlang.hd(1)
iex> case 1 do
...>   x when hd(x) -> "Won't match"
...>   x -> "Got: #{x}"
...> end
"Got 1"
```

If none of the clauses match, an error is raised:

```iex
iex> case :ok do
...>   :error -> "Won't match"
...> end
** (CaseClauseError) no case clause matching: :ok
```

Note anonymous functions can also have multiple clauses and guards:

```elixir
iex> f = fn
...>   x, y when x > 0 -> x + y
...>   x, y -> x * y
...> end
#Function<12.71889879/2 in :erl_eval.expr/5>
iex> f.(1, 3)
4
iex> f.(-1, 3)
-3
```

The number of arguments in each anonymous function clause needs to be the same, otherwise an error is raised.

### 5.2 cond

`case` is useful when you need to match against different values. However, in many circumstances, we want to check different conditions and find the first one that evaluates to true. In such cases, one may use `cond`:

```iex
iex> cond do
...>   2 + 2 == 5 ->
...>     "This will not be true"
...>   2 * 2 == 3 ->
...>     "Nor this"
...>   1 + 1 == 2 ->
...>     "But this will"
...> end
"But this will"
```

This is equivalent to `else if` clauses in many imperative languages (although used way less frequently here).

If none of the conditions return true, an error is raised. For this reason, it may be necessary to add a last condition equal to `true`, which will always match:

```iex
iex> cond do
...>   2 + 2 == 5 ->
...>     "This is never true"
...>   2 * 2 == 3 ->
...>     "Nor this"
...>   true ->
...>     "This is always true (equivalent to else)"
...> end
```

Finally, note `cond` considers any value besides `nil` and `false` to be true:

```iex
iex> cond do
...>   hd([1,2,3]) ->
...>     "1 is considered as true"
...> end
"1 is considered as true"
```

### 5.3 if and unless

Besides `case` and `cond`, Elixir also provides the macros `if/2` and `unless/2` which are useful when you need to check for just one condition:

```iex
iex> if true do
...>   "This works!"
...> end
"This works!"
iex> unless true do
...>   "This will never be seen"
...> end
nil
```

If the condition given to `if/2` returns `false` or `nil`, the body given in between `do/end` is not executed and it simply returns `nil`. The opposite happens with `unless/2`.

They also supports `else` blocks:

```iex
iex> if nil do
...>   "This won't be seen"
...> else
...>   "This will"
...> end
"This will"
```

An interesting note regarding `if/2` and `unless/2` is that they are implemented as macros in the language, they are not keywords (as they would be in many languages). You can check the documentation and the source of `if/2` in [the `Kernel` module docs](/docs/stable/Kernel.html). The `Kernel` module is also where operators like `+/2` and functions like `is_function/2` are defined, all automatically imported and available in your code by default.

### 5.4 `do` blocks

At this point, we have learned 4 control structures, `case`, `cond`, `if` and `unless`, and they were all wrapped in `do`/`end` blocks. It happens we could also write `if` as follows:

```iex
iex> if true, do: 1 + 2
3
```

In Elixir, `do`/`end` blocks are a convenience for passing a group of expressions to `do:`. These are equivalent:

```iex
iex> if true do
...>   a = 1 + 2
...>   a + 10
...> end
13
iex> if true, do: (
...>   a = 1 + 2
...>   a + 10
...> )
13
```

We say the second syntax is using **keyword lists**. We can pass `else` using this syntax:

```iex
iex> if false, do: :this, else: :that
:that
```

It is important to keep one small detail in mind when using `do`/`end` blocks: they always bind to the farthest function call. For example, the following expression:

```iex
iex> is_number if true do
...>  1 + 2
...> end
```

Would be parsed as:

```iex
iex> is_number(if true) do
...>  1 + 2
...> end
```

Which leads to an undefined function error, since `do` is being passed to the `is_number` function, which is then called with two arguments while `if` is called with only one. Adding explicit parentheses is enough to resolve the ambiguity:

```iex
iex> is_number(if true do
...>  1 + 2
...> end)
true
```

The same rules regarding `do`/`end` blocks also apply to `case`, `cond`, etc:

```iex
iex> case 1, do: (x -> "Got #{x}")
"Got 1"
```

Although it is rare to use the keyword syntax with `case` and `cond`, we will see keyword lists play an important role in the language and are quite common in many functions and macros. We will explore them a bit more in a future chapter, now it is time to talk about "Binaries, strings and char lists".
