---
layout: getting_started
title: 5. Macros
guide: 5
---

# 5 Macros

Elixir is an homoiconic language. Any Elixir program can be represented using its own data structures. This section describes the Elixir language specification for such data structures.

## 5.1 Building blocks of homoiconicity

The building block of Elixir homoiconicity is a tuple with three elements, for example:

    { :sum, 1, [1, 2, 3] }

The tuple above represents a function call to sum passing 1, 2 and 3 as arguments. The tuple elements are:

    { Tuple | Atom, Integer, List | Atom }

* The first element of the tuple is always an atom or another tuple in the same representation;
* The second element of the tuple is always an integer representing the line number;
* The third element of the tuple is either a list of arguments for the function call or an atom (`nil` or `:quoted`), meaning that the tuple represents a variable, not a function call.

You can get the representation of any expression by using the quote macro:

    iex> quote do: sum(1, 2, 3)
    { :sum, 0, [1, 2, 3] }

Everything in Elixir is a function call and can be represented by such tuples. For example, operators are represented as such:

    iex> quote do: 1 + 2
    { :"+", 0, [1, 2] }

Even a tuple is represented as a call to `{}`:

    iex> quote do: { 1, 2, 3 }
    { :"{}", 0, [1, 2, 3] }

The only exception to this rule are the five Elixir literals below. Literals are data types that when quoted return themselves. They are:

    :sum         #=> Atoms
    1.0          #=> Numbers
    [1,2]        #=> Lists
    "binaries"   #=> Binaries
    {key, value} #=> Tuples with two elements

With those basic structures in mind, we are ready to define our own macro.

## 5.2 Defining our own macro

A macro can be defined using `defmacro`. For instance, in just a few lines of code we can define a macro called `unless` which works the same way Ruby's `unless` does:

    defmodule MyMacro do
      defmacro unless(clause, options) do
        quote do: if(!unquote(clause), unquote(options))
      end
    end

Similarly to `if`, `unless` expects two arguments: a `clause` and `options`:

    require MyMacro
    MyMacro.unless var, do: IO.puts "false"

However, since `unless` is a macro, its arguments are not evaluated when it's invoked but are instead passed literally. For example, if one calls:

    unless 2 + 2 == 5, do: call_function()

our `unless` macro will receive the following:

    unless({:==, 1, [{:+, 1, [2, 2]}, 5]}, { :call_function, 1, [] })

Then our `unless` macro will call `quote`, to return a tree representation of the `if` clause. This means we are transforming our `unless` into an `if`!

There is a common mistake when quoting expressions which is that developers usually forget to `unquote` the proper expression. In order to understand what `unquote` does, let's simply remove it:

    defmacro unless(clause, options) do
      quote do: if(!clause, options)
    end

When called as `unless 2 + 2 == 5, do: call_function()`, our `unless` would then literally return:

    if(!clause, options)

Which would fail because the clause and options variables are not defined in the current scope. If we add `unquote` back:

    defmacro unless(clause, options) do
      quote do: if(!unquote(clause), unquote(options))
    end

`unless` will then return:

    if(!(2 + 2 == 5), do: call_function())

In other words, unquote is a mechanism to inject expressions into the tree being quoted and it is an essential tool for meta-programming. Elixir also provides `unquote_splicing` allowing us to inject many expressions at once.

We can define any macro we want, including ones that override the built-in macros provided by Elixir. The only exceptions are Elixir special forms that cannot be overridden, [the full list of special forms is available in `Elixir.SpecialForms`](https://github.com/elixir-lang/elixir/tree/master/lib/elixir/special_forms.ex).

## 5.3 Macros hygiene

Elixir macros follow Scheme conventions and are hygienic. This means a variable defined inside a macro won't conflict with a variable defined in the context the macro is inserted. For example:

    defmodule Hygiene do
      defmacro no_interference do
        quote do: a = 1
      end
    end

    defmodule HygieneTest do
      def go do
        require Hygiene
        a = 13
        Hygiene.no_interference
        a
      end
    end

    HygieneTest.go
    # => 13

In the example above, even if the macro injects `a = 1`, it does not affect the variable `a`. In case the macro wants to explicitly affect the context, it can use `var!`:

    defmodule Hygiene do
      defmacro interference do
        quote do: var!(a) = 1
      end
    end

    defmodule HygieneTest do
      def go do
        require Hygiene
        a = 13
        Hygiene.interference
        a
      end
    end

    HygieneTest.go
    # => 1

Macros hygiene only works because Elixir marks a variable as coming from the quote. For example, consider this:

    iex> quote do: x
    { :x, 0, :quoted }

Notice that the third element is `:quoted`. It means that x may be a function call with 0 arguments or a variable coming from a quote. On the other hand, an unquoted variable would have the third element equal to nil. Let's consider this final example:

    defmodule Hygiene do
      defmacro quoted(x) do
        quote do
          { unquote(x), x, x() }
        end
      end
    end

In the example above, we have defined a macro called `quoted` that returns an unquoted variable, a quoted variable and a function call. Calling this macro will return:

    require Hygiene

    Hygiene.quoted(x)
    #=> {
      { :x, 1, nil },
      { :x, 1, :quoted },
      { :x, 1, [] }
    }

Summing up: if the third element is a list, it is certainly a function call. If not, it may be a variable (coming from a quote or not) or a function call.

## 5.4 Local functions and macros

In order to support recursion, macros cannot be called locally. For example, one cannot write:

    defmodule MyMacros
      defmacro delegate([h|t], to: target) do
        # ...
      end

      # Call the macro delegate just defined above
      delegate [values: 1], to: List
    end

In order for us to access the macro, it needs to be defined in an outer module:

    defmodule MyMacros.Support
      defmacro delegate([h|t], to: target) do
        # ...
      end
    end

    defmodule MyMacros
      require MyMacros.Support, import: true
      delegate [values: 1], to: List
    end

With this note, we finish our introduction to macros. Next, let's move to the next chapter which will discuss several topics such as native code compilation, partial application and others.
