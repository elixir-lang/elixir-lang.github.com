---
layout: getting_started
title: 2 Basic types
guide: 2
---

# {{ page.title }}

In this chapter we will learn more about Elixir basic types: integers, floats, atoms, lists and strings. Some basic types are:

```iex
iex> 1          # integer
iex> 0x1F       # integer
iex> 1.0        # float
iex> :atom      # atom / symbol
iex> "elixir"   # string
iex> [1, 2, 3]  # list
iex> {1, 2, 3}  # tuple
```

## 2.1 Basic arithmetic

Open up `iex`  and type the following expressions:

```iex
iex> 1 + 2
3
iex> 5 * 5
25
iex> 10 / 2
5.0
```

Notice `10 / 2` returned a float `5.0` instead of an integer. This is expected. In Elixir the operator `/` always returns a float. If you want to do integer division or get the division remainder, you can invoke the `div` and `rem` functions:

```iex
iex> div(10, 2)
5
iex> div 10, 2
5
iex> rem 10, 3
1
```

Notice that parentheses are not required in order to invoke a function.

Elixir also supports shorcut notations for entering binaries, octals and hexadecimal numbers:

```iex
iex> 0x1F
31
iex> 0777
511
iex> 0b1010
10
```

Float numbers require a dot followed by at least one digit and also support `e` for the exponent number:

```iex
iex> 1.0
1.0
iex> 1.0e-10
1.0e-10
```

Floats in Elixir are double precision, accurate up to 16 digits.

## 2.2 Booleans

Elixir supports `true` and `false` as booleans.

```iex
iex> true
true
iex> true == false
false
```

Elixir provides a bunch of predicate functions to check for a value type. For example, the `is_boolean/1` function can be used to check if a value is a boolean or not:

```iex
iex> is_boolean(true)
true
iex> is_boolean(1)
false
```

Throughout this tutorial and in Elixir documentation, you will see functions mentioned in the format `is_boolean/1`. The first part is the function name and the number is its arity, i.e. the number of arguments the function expects.

You can also use `is_integer/1`, `is_float/1` or `is_number/1` to check if an argument is an integer, float or any of them.

## 2.3 Atoms

Atoms are constants where their name is their own value. Some other languages call them symbols.

```iex
iex> :hello
:hello
iex> :hello == :world
false
```

The booleans `true` and `false` are, in fact, atoms:

```iex
iex> true == :true
true
iex> is_atom(false)
true
```

## 2.4 Strings

Strings in Elixir are inserted in between double quotes and they are encoded in UTF-8:

```iex
iex> "hellö"
"hellö"
```

Elixir also supports string interpolation:

```iex
iex> "hellö #{:world}"
"hellö world"
```

Strings can have line breaks in them or introduce them using escape sequences:

```iex
iex> "hello
...> world"
"hello\nworld"
iex> "hello\nworld"
"hello\nworld"
```

You can print a string using the `IO.puts/1` function from the `IO` module:

```iex
iex> IO.puts "hello\nworld"
hello
world
:ok
```

Notice the `IO.puts/1` function returns the atom `:ok` as result after printing.

Strings in Elixir are represented internally by binaries (i.e. a sequence of bytes):

```iex
iex> is_binary("hellö")
true
```

We can also get the number of bytes in a string:

```iex
iex> byte_size("hellö")
6
```

Notice the number of bytes in that string is 6, even though it has 5 characters. That's because the character "ö" takes 2 bytes to be represented in UTF-8. We can get the actual length of the string, based on the number of characters, by using the `String.length/1` function:

```iex
iex> String.length("hellö")
5
```

The [String module](http://elixir-lang.org/docs/stable/String.html) contains a bunch of functions that operate on strings as defined in the Unicode standard:

```iex
iex> String.upcase("hellö")
"HELLÖ"
```

Keep in mind `single-quoted` and `double-quoted` strings are not equivalent in Elixir as they are represented by different types:

```iex
iex> 'hellö' == "hellö"
true
```

We will talk more about Unicode support and the difference in between single and double-quoted strings in the "Binaries, strings and char lists" chapter.

## 2.5 Anonymous functions

Functions are delimited by the keywords `fn` and `end`:

```iex
iex> add = fn a, b -> a + b end
#Function<12.71889879/2 in :erl_eval.expr/5>
iex> is_function(add)
true
iex> is_function(add, 2)
true
iex> is_function(add, 1)
false
iex> add.(1, 2)
3
```

Functions can be passed as argument to other functions. In the example, we have passed the function in the variable `add` to the `is_function/1` function which correctly returned true. We can also check the arity of the function by calling `is_function/2`. Note a dot (`.`) in between the variable and parenthesis is required to invoke an anonymous function.

Anonymous functions are closures and as such they can access variables defined prior to the function definition:

```iex
iex> add_two = fn a -> add(a, 2) end
#Function<6.71889879/1 in :erl_eval.expr/5>
iex> add_two.(2)
4
```

Keep in mind that a variable defined inside the function does not affect its surroundings:

```iex
iex> x = 42
42
iex> (fn -> x = 0 end).()
0
iex> x
42
```

## 2.6 (Linked) Lists

Elixir uses square brackets to specify a list of values. Values can be of any type:

```iex
iex> [1, 2, true, 3]
[1, 2, true, 3]
iex> length [1, 2, 3]
3
```

Two lists can be concatenated and subtracted using the `++/2` and `--/2` operators:

```iex
iex> [1, 2, 3] ++ [4, 5, 6]
[1, 2, 3, 4, 5, 6]
iex> [1, true, 2, false, 3, true] -- [true, false]
[1, 2, 3, true]
```

Throughout the tutorial, we will talk a lot about head and tail of a list. A head is the first element of a list and tail is the remaining of a list. They can be retrieved with the functions `hd/1` and `tl/1`. Let's assign a list to a variable and retrieve its head and tail:

```iex
iex> list = [1,2,3]
iex> hd(list)
1
iex> tl(list)
[2, 3]
```

Asking a head or a tail of an empty list leads to an error:

```iex
iex> hd []
** (ArgumentError) argument error
```

Oops!

We will revisit lists a couple times in the following chapters. If you want to look ahead, the "Pattern matching", "Binaries, strings and char lists" and "Enumerables" chapters are particularly interesting.

## 2.7 Tuples

Elixir uses curly brackets to define tuples. As lists, tuples can hold any value:

```iex
iex> {:ok, "hello"}
{:ok, "hello"}
iex> size {:ok, "hello"}
2
```

The `elem/2` and `set_elem/3` functions can be used to read or set a value in a tuple:

```iex
iex> tuple = {:ok, "hello"}
{:ok, "hello"}
iex> elem(tuple, 1)
"hello"
iex> set_elem(tuple, 1, "world")
{:ok, "world"}
iex> tuple
{:ok, "hello"}
```

Notice that `set_elem/3` returned a new tuple. The original tuple stored in the `tuple` variable was not modified. This is true for all language data types because Elixir is an immutable language. By being immutable, Elixir reduces the amount mutable shared state in your code, which eliminates many problems when writing code concurrently or when building fault-tolerant applications.

## 2.8 Lists or tuples?

You are probably wondering: what is the difference in between a list and a tuple?

That's an excellent question. Tuples are useful when you have a fixed number of fields or when you usually access those items by position. Lists, on the other hand, are useful when the items need to be enumerated.

One very common use case for tuples is to use them to return extra information from a function. For example, we can use the `File.read/1` function to read a file:

```iex
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}
iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

If the path given to `File.read/1` exists, it returns a tuple with the atom `:ok` as first element and the contents as second. Otherwise, it returns `:error` and the error reason.

The difference in between tuples and lists is important because it reflects on the operations you will perform on them. Tuples are fast when you need to get its size or access one element in a particular position. On the other hand, those operations are linear on lists: if you need to access the nth-item of a list, Elixir needs to go item by item until we retrieve the desired one.

This is the reason there is a `elem/2` function to access a tuple item but there is no builtin equivalent for lists:

```iex
iex> tuple = {:ok, "hello"}
{:ok, "hello"}
iex> size(tuple)
2
iex> elem(tuple, 1)
"hello"
```

Finally, notice we have used 4 counting functions so far: `byte_size/1` (for the number of bytes in a string), `size/1` (for the tuple size), `length/1` (for the list length) and `String.length/1` (for the number of characters in a string). Their naming is not arbitrary.

`length` is used when the number of elements needs to be calculated. For example, calling `length` will iterate the whole list to find the number of elements in that list. `size` is the opposite, it means the value is pre-calculated and stored somewhere, therefore retrieving it is a cheap operation. That said, we use `byte_size` to get the number of bytes in a string, which is cheap, but retrieving the number of unicode characters uses `String.length`, since the whole string needs to be iterated.

Elixir also provides `Port`, `Reference`s and `PID`s as data types (usually used in process communication), and we will take a quick look at them when talking about processes. For now, let's take a look at some of the basic operator to use with our basic types.
