---
layout: getting_started
title: 9 Doctests and configuration
guide: 9
---

# {{ page.title }}

  <div class="toc"></div>

In this chapter, we will implement the code that parses the commands we have first described in the first chapter:

```
CREATE shopping
OK

PUT shopping milk 1
OK

PUT shopping eggs 3
OK

GET shopping milk
1
OK

DELETE shopping eggs
OK
```

After the parsing is done, we will update our server to parse and run the commands directly againt the `:kv` application we have built in previous chapters.

## 9.1 Doctests

On the language homepage, we mention how Elixir makes documentation a first-class citizen in the language. We have explored this chapter many times throughout this guide, be it via `mix help` or by typing `h Enum` or another module in the terminal.

In this section, we will implement the parse functionality using doctests, which allows us to write tests directly from our documentation, which helps provide documentation with accurate code samples.

Let's create our command parser at `lib/kv_server/command.ex` and start with the doctest:

```elixir
defmodule KVServer.Command do
  @doc ~S"""
  Parses the given `line` into a command.

  ## Examples

      iex> KVServer.Command.parse "CREATE shopping\r\n"
      {:ok, {:create, "shopping"}}

  """
  def parse(line) do
    :not_implemented
  end
end
```

Doctests are specified by four spaces in the documentation followed by the `iex>` prompt. If a command spawns multiple lines, you can use `...>`, as in IEx. The expected result should start at the next line after `iex>` or `...>` line(s) and is terminated either by a newline or a new `iex>` prefix.

Also note that we started the documentation string using `@doc ~S"""`. We have used `~S` so the `\r\n` characters inside the doctest are preserved as is.

In order to run our doctests, create a file at `test/kv_server/command_test.exs` and simply call `doctest KVServer.Command` in the test case:

```elixir
defmodule KVServer.CommandTest do
  use ExUnit.Case, async: true
  doctest KVServer.Command
end
```

Run the test suite and the doctest should fail:

    1) test doc at KVServer.Command.parse/1 (1) (KVServer.CommandTest)
       test/kv_server/command_test.exs:3
       Doctest failed
       code: KVServer.Command.parse "CREATE shopping\r\n" === {:ok, {:create, "shopping"}}
       lhs:  :not_implemented
       stacktrace:
         lib/kv_server/command.ex:11: KVServer.Command (module)

Excellent!

Now it is just a matter of making the doctest pass. Let's implement the `parse/1` function:

```elixir
def parse(line) do
  case String.split(line) do
    ["CREATE", bucket] -> {:ok, {:create, bucket}}
  end
end
```

Our implementation simply splits the line on every whitespace and then matches the commands directly in the list. This means that our commands are actually white-space insensitive. Let's add some new doctests to test this behaviour and the new commands:

```elixir
@doc ~S"""
Parses the given `line` into a command.

## Examples

    iex> KVServer.Command.parse "CREATE shopping\r\n"
    {:ok, {:create, "shopping"}}

    iex> KVServer.Command.parse "CREATE  shopping  \r\n"
    {:ok, {:create, "shopping"}}

    iex> KVServer.Command.parse "PUT shopping milk 1\r\n"
    {:ok, {:put, "shopping", "milk", "1"}}

    iex> KVServer.Command.parse "GET shopping milk\r\n"
    {:ok, {:get, "shopping", "milk"}}

    iex> KVServer.Command.parse "DELETE shopping eggs\r\n"
    {:ok, {:delete, "shopping", "eggs"}}

Unknown commands or commands with the wrong number of
arguments return an error:

    iex> KVServer.Command.parse "UNKNOWN shopping eggs\r\n"
    {:error, :unknown_command}

    iex> KVServer.Command.parse "GET shopping\r\n"
    {:error, :unknown_command}

"""
```

With doctests is hand, it is your turn to make tests pass! Once you ready, you can compare with our solution below:

```elixir
def parse(line) do
  case String.split(line) do
    ["CREATE", bucket] -> {:ok, {:create, bucket}}
    ["GET", bucket, key] -> {:ok, {:get, bucket, key}}
    ["PUT", bucket, key, value] -> {:ok, {:put, bucket, key, value}}
    ["DELETE", bucket, key] -> {:ok, {:delete, bucket, key}}
    _ -> {:error, :unknown_command}
  end
end
```

Notice how we were able to elegantly parse the commands without adding a bunch of `if/else` clauses that checks the list command and length!

Finally, you may have noticed that each doctest was considered to be a different test in our test case. That is because the tests were separated by new lines. In other words, ExUnit considers this two different tests:

```iex
iex> KVServer.Command.parse "UNKNOWN shopping eggs\r\n"
{:error, :unknown_command}

iex> KVServer.Command.parse "GET shopping\r\n"
{:error, :unknown_command}
```

But the one below is compiled into a single test:

```iex
iex> KVServer.Command.parse "UNKNOWN shopping eggs\r\n"
{:error, :unknown_command}
iex> KVServer.Command.parse "GET shopping\r\n"
{:error, :unknown_command}
```

You can read more about doctests in [the `ExUnit.DocTest` docs](/docs/stable/ex_unit/ExUnit.DocTest.html).

## 9.2 Pipelines

With our command parser in hand, we can finally start implementing the logic that runs the commands. Let's add a stub definition for this function for now:

```elixir
defmodule KVServer.Command do
  @doc """
  Runs the given command.
  """
  def run(command) do
    {:ok, "OK\r\n"}
  end
end
```

Before we implement this function, let's change our server to start using both `parse/1` and `run/1` functions. Remember our `read_line/1` function was also crashing when the client closed the socket, so let's take the opportunity to fix it too. Open up `lib/kv_server.ex` and replace the existing server definition:

```elixir
defp serve(socket) do
  socket
  |> read_line()
  |> write_line(socket)

  serve(socket)
end

defp read_line(socket) do
  :inet.setopts(socket, [:binary, packet: :line, active: false])
  {:ok, data} = :gen_tcp.recv(socket, 0)
  data
end

defp write_line(line, socket) do
  :gen_tcp.send(socket, line)
end
```

by the following:

```elixir
defp serve(socket) do
  msg =
    case read_line(socket) do
      {:ok, data} ->
        case KVServer.Command.parse(data) do
          {:ok, command} ->
            KVServer.Command.run(command)
          {:error, _} = err ->
            err
        end
      {:error, _} = err ->
        err
    end

  write_line(socket, msg)
  serve(socket)
end

defp read_line(socket) do
  :inet.setopts(socket, [:binary, packet: :line, active: false])
  :gen_tcp.recv(socket, 0)
end

defp write_line(socket, msg) do
  :gen_tcp.send(socket, format_msg(msg))
end

defp format_msg({:ok, text}), do: text
defp format_msg({:error, :unknown_command}), do: "UNKNOWN COMMAND\r\n"
defp format_msg({:error, _}), do: "ERROR\r\n"
```

If we start our server, we can know send commands to it. For now we can get two different responses:

    $ telnet 127.0.0.1 4040
    Trying 127.0.0.1...
    Connected to localhost.
    Escape character is '^]'.
    CREATE shopping
    OK
    HELLO
    UNKNOWN COMMAND

This means our implementation is going in the correct direction, but it doesn't look very pretty, does it?

The previous implementation used pipes which would made the information flow straight-forward to understand:

```elixir
read_line(socket) |> KVServer.Command.parse |> KVServer.Command.run()
```

But now, since we may have failures along the way, we need to match along each step and abort in case there is a failure. Wouldn't it be great if instead we could say: "pipe those functions while the response is ok" or "pipe those functions while the response matches the `{:ok, _}` tuple"?

Actually there is a project called [elixir-pipes](https://github.com/batate/elixir-pipes) that provides exactly this functionality! Let's give it a try. Open up your `apps/kv_server/mix.exs` file and change both `application/0` and `deps/0` functions to the following:

```elixir
def application do
  [applications: [:pipe, :kv],
   mod: {KVServer, []}]
end

defp deps do
  [{:kv, in_umbrella: true},
   {:pipes, github: "batate/elixir-pipes"}]
end
```

Run `mix deps.get` to get the dependency and rewrite `serve/1` function to use the `pipe_matching/3` functionality from the [elixir-pipes](https://github.com/batate/elixir-pipes) project:

```elixir
defp serve(socket) do
  import Pipe

  msg =
    pipe_matching x, {:ok, x},
      read_line(socket)
      |> KVServer.Command.parse()
      |> KVServer.Command.run()

  write_line(socket, msg)
  serve(socket)
end
```

With `pipe_matching/3` we can ask Elixir to pipe the value `x` in each step that matches `{:ok, x}`. We do so by basically converting each expression given to `case/2` as a step in the pipeline. As soon as any of the steps return something that does not match `{:ok, x}`, the pipeline aborts.

Excellent! Feel free to read the [elixir-pipes](https://github.com/batate/elixir-pipes) project documentation to learn about other options for expressing pipelines. Let's continue moving forward with our server implementation.

