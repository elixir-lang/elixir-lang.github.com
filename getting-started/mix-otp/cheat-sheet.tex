\documentclass[a4paper]{article}
\usepackage{framed}
\usepackage{tikz}
\usepackage{amsmath,bm,times}
%%%<
\usepackage{verbatim}
\usepackage[margin=1cm]{geometry}% for screen preview
%%%>
\usetikzlibrary{shapes,arrows,calc,backgrounds,shapes.geometric}
% Define a background layer, in which the parchment shape is drawn
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}

\tikzset{normal border/.style={orange!30!black!10}}

% Macro to draw the shape behind the text, when it fits completly in the
% page
\def\parchmentframe#1{
\tikz{
  \node[inner sep=2em] (A) {#1};  % Draw the text of the node
  \begin{pgfonlayer}{background}  % Draw the shape behind
  \filldraw[normal border,rounded corners,color=blue!10!yellow!5,draw=blue!25!yellow,dashed] 
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east);
  \end{pgfonlayer}}}

% Macro to draw the shape, when the text will continue in next page
\def\parchmentframetop#1{
\tikz{
  \node[inner sep=2em] (A) {#1};    % Draw the text of the node
  \begin{pgfonlayer}{background}    
  \filldraw[normal border,rounded corners,color=blue!10!yellow!5,draw=blue!25!yellow,dashed] 
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east);
  \end{pgfonlayer}}}

% Macro to draw the shape, when the text continues from previous page
\def\parchmentframebottom#1{
\tikz{
  \node[inner sep=2em] (A) {#1};   % Draw the text of the node
  \begin{pgfonlayer}{background}   
  \filldraw[normal border,rounded corners,color=blue!10!yellow!5,draw=blue!25!yellow,dashed] 
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east);
  \end{pgfonlayer}}}

% Macro to draw the shape, when both the text continues from previous page
% and it will continue in next page
\def\parchmentframemiddle#1{
\tikz{
  \node[inner sep=2em] (A) {#1};   % Draw the text of the node
  \begin{pgfonlayer}{background}   
  \filldraw[normal border,rounded corners,color=blue!10!yellow!5,draw=blue!25!yellow,dashed] 
        (A.south east) -- (A.south west) -- 
        (A.north west) -- (A.north east);
  \end{pgfonlayer}}}

% Define the environment which puts the frame
% In this case, the environment also accepts an argument with an optional
% title (which defaults to ``Example'', which is typeset in a box overlaid
% on the top border
\newenvironment{parchment}[1][Example]{%
  \def\FrameCommand{\parchmentframe}%
  \def\FirstFrameCommand{\parchmentframetop}%
  \def\LastFrameCommand{\parchmentframebottom}%
  \def\MidFrameCommand{\parchmentframemiddle}%
  \vskip\baselineskip
  \MakeFramed {\FrameRestore}
  \noindent\tikz\node[rounded corners, inner sep=2ex, draw=blue!25!yellow, fill=white, dashed, anchor=west, overlay] at (0em, 2em) {\sffamily#1};\par}%
{\endMakeFramed}

% Main document, example of usage
\pagestyle{empty}
\begin{document}

% We need layers to draw the block diagram
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

% Define a few styles and constants
\tikzstyle{left-title}=[draw, fill=blue!20, text width=1em, minimum height=5em]
\tikzstyle{naveqs} = [left-title, text width=28em, inner sep=8pt, fill=red!10, 
  minimum height=5em, rounded corners]

\begin{parchment}[initialization]
\begin{tikzpicture}
  \node (client) [naveqs] {
    \vspace*{-\baselineskip}
\begin{verbatim}
def start_link(opts \\ []) do
  GenServer.start_link(__MODULE__, :ok, opts)
end
\end{verbatim}
};
\path (client.180)+(-1em,0) node (gyros) [left-title] {\rotatebox{90}{client}};

\path (client.north east)+(3em,0) node (returns) [naveqs,anchor=north west] {
    \vspace*{-\baselineskip}
\begin{verbatim}
{:ok, pid}
\end{verbatim}
};
  \path (returns.180)+(-1em,0) node (gyros) [left-title] {\rotatebox{90}{immediate}};

\path (client.south west)+(0,-1em) node (callback) [naveqs,anchor=north west] {
    \vspace*{-\baselineskip}
\begin{verbatim}
def init(:ok) do
  state = init_state()
  return_value
end
\end{verbatim}
};
  \path (callback.180)+(-1em,0) node (gyros) [left-title] {\rotatebox{90}{callback}};

  \path (callback.south west)+(0,-1em) node (return-value) [naveqs,anchor=north west] {
    \vspace*{-\baselineskip}
\begin{verbatim}
{:ok, state}
{:ok, state, 5_000}
{:ok, state, :hibernate}
{:stop, reason * }
:ignore!
\end{verbatim}
};
\path (return-value.180)+(-1em,0) node (gyros) [left-title] {\rotatebox{90}{\^{}return\_value = }};
\end{tikzpicture}
\end{parchment}

\begin{parchment}[synchronous operation]
\begin{tikzpicture}
  \node (client) [naveqs] {
    \vspace*{-\baselineskip}
\begin{verbatim}
def sync_op(pid, args) do
  GenServer.call(pid, {:sync_op, args})
end
\end{verbatim}
};
  \path (client.180)+(-1em,0) node (gyros) [left-title] {\rotatebox{90}{client}};

\path (client.north east)+(3em,0) node (returns) [naveqs,anchor=north west] {
  waits for callback and returns \texttt{reply} if returned value from callback matches \texttt{\{:reply, reply, \_\}}
};
  \path (returns.180)+(-1em,0) node (gyros) [left-title] {\rotatebox{90}{immediate}};

  \path (client.south west)+(0,-1em) node (callback) [naveqs,anchor=north west] {
    \vspace*{-\baselineskip}
\begin{verbatim}
def handle_call({:sync_op, args}, from, state) do
  new_state = f(state, args)
  return_value
end
\end{verbatim}
};
  \path (callback.180)+(-1em,0) node (gyros) [left-title] {\rotatebox{90}{callback}};

  \path (callback.south west)+(0,-1em) node (returns) [naveqs,anchor=north west] {
    \vspace*{-\baselineskip}
\begin{verbatim}
{:reply, reply, new_state}
{:reply, reply, new_state, 5_000}
{:reply, reply, new_state, :hibernate}

{:noreply, new_state}
{:noreply, new_state, 5_000}
{:noreply, new_state, :hibernate}

{:stop, reason * , reply, new_state}
{:stop, reason * , new_state}
\end{verbatim}
};
  \path (returns.180)+(-1em,0) node (gyros) [left-title] {\rotatebox{90}{\^{}return\_value =}};
\end{tikzpicture}

\end{parchment}

\begin{parchment}[asynchronous operation]
\begin{tikzpicture}
  \node (client) [naveqs] {
    \vspace*{-\baselineskip}
\begin{verbatim}
def sync_op(pid, args) do
  GenServer.cast(pid, {:async_op, args})
end
\end{verbatim}
};
  \path (client.180)+(-1em,0) node (gyros) [left-title] {\rotatebox{90}{client}};

\path (client.north east)+(3em,0) node (returns) [naveqs,anchor=north west] {
    \vspace*{-\baselineskip}
\begin{verbatim}
:ok
\end{verbatim}
};
  \path (returns.180)+(-1em,0) node (gyros) [left-title] {\rotatebox{90}{immediate}};

  \path (client.south west)+(0,-1em) node (callback) [naveqs,anchor=north west] {
    \vspace*{-\baselineskip}
\begin{verbatim}
def handle_cast({:sync_op, args}, state) do
  new_state = f(state, args)
  return_value
end
\end{verbatim}
};
  \path (callback.180)+(-1em,0) node (gyros) [left-title] {\rotatebox{90}{callback}};

  \path (callback.south west)+(0,-1em) node (returns) [naveqs,anchor=north west] {
    \vspace*{-\baselineskip}
\begin{verbatim}
{:noreply, new_state}
{:noreply, new_state, 5_000}
{:noreply, new_state, :hibernate}

{:stop, reason * , new_state}
\end{verbatim}
};
  \path (returns.180)+(-1em,0) node (gyros) [left-title] {\rotatebox{90}{\^{}return\_value =}};
\end{tikzpicture}
\end{parchment}

\begin{parchment}[handling information messages]
\begin{verbatim}
def handle_info(msg, state) do
new_state = f(state, msg)
{:noreply, new_state}
end

{:noreply, new_state}
{:noreply, new_state, 5_000}
{:noreply, new_state, :hibernate}
{:stop, reason * , new_state}
\end{verbatim}
\end{parchment}

\begin{parchment}[termination]
\begin{verbatim}
def stop(pid, reason \\ :normal, timeout \\ :infinity) do
GenServer.stop(pid, reason, timeout)
end
def terminate(reason, state) do
# Perform cleanup here
# ...
end

:normal
:shutdown
{:shutdown, term}
term
\end{verbatim}
  
\end{parchment}
\end{document}
