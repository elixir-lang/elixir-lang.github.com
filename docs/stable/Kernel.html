<!DOCTYPE html>
<html>
  <head>
    <title>Kernel</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <h1>
        Kernel
        
      </h1>

      
        <div id="moduledoc" class="docstring">
          <p><code>Kernel</code> provides the default macros and functions
Elixir imports into your environment. These macros and functions
can be skipped or cherry-picked via the <code>import</code> macro. For
instance, if you want to tell Elixir not to import the <code>case</code>
macro, you can do:</p>

<pre><code>import Kernel, except: [case: 2]
</code></pre>

<p>Elixir also has special forms that are always imported and
cannot be skipped. These are described in <code>Kernel.SpecialForms</code>.</p>

<p>Some of the functions described in this module are simply
a proxy to their Erlang counterpart. Although they are documented
here for convenience, you can access their original documentation
at <a href="http://www.erlang.org/doc/man/erlang.html">http://www.erlang.org/doc/man/erlang.html</a>.</p>

        </div>
      

      <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1" target="_blank" class="view_source">Source</a>

      

      
        <h2 id="functions_summary">Functions summary</h2>
        <table class="summary">
          <tr>
  <td class="summary_signature"><a href="#!/1">!arg</a></td>
  
    <td class="summary_synopsis"><p>Receives any argument and returns <code>true</code> if it is <code>false</code>
or <code>nil</code>. Returns <code>false</code> otherwise. Not allowed in guard
clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#!=/2">left != right</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if the two items are not equal.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#!==/2">left !== right</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if the two items are strictly not equal.
Like Erlang, Elixir can compare any term. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#*/2">left * right</a></td>
  
    <td class="summary_synopsis"><p>Arithmetic multiplication. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#+/1">+value</a></td>
  
    <td class="summary_synopsis"><p>Arithmetic unary plus. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#+/2">left + right</a></td>
  
    <td class="summary_synopsis"><p>Arithmetic plus. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#++/2">left ++ right</a></td>
  
    <td class="summary_synopsis"><p>Concatenates two lists. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#-/1">-value</a></td>
  
    <td class="summary_synopsis"><p>Arithmetic unary minus. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#-/2">left - right</a></td>
  
    <td class="summary_synopsis"><p>Arithmetic minus. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#--/2">left -- right</a></td>
  
    <td class="summary_synopsis"><p>Removes the first occurrence of an item on the left
for each item on the right. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#//2">left / right</a></td>
  
    <td class="summary_synopsis"><p>Arithmetic division. Unlike other languages,
the result is always a float. Use <code>div</code> and <code>rem</code> if you want
a natural division or the remainder. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#&lt;/2">left &lt; right</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if left is less than right.
Like Erlang, Elixir can compare any term. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#&lt;-/2">pid &lt;- msg</a></td>
  
    <td class="summary_synopsis"><p>Sends a message to the process identified on the left.
A process can be identified by its PID or, if it is registered,
by an atom.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#&lt;=/2">left &lt;= right</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if left is less than or equal to right.
Like Erlang, Elixir can compare any term. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#==/2">left == right</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if the two items are equal.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#===/2">left === right</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if the two items are strictly equal.
Like Erlang, Elixir can compare any term. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#=~/2">left =~ right</a></td>
  
    <td class="summary_synopsis"><p>Matches the term on the left against the regular expression or string on the
right. Returns true if <code>left</code> matches <code>right</code> (if it&#39;s a regular expression)
or contains <code>right</code> (if it&#39;s a string).</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#&gt;/2">left &gt; right</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if left is more than right.
Like Erlang, Elixir can compare any term. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#&gt;=/2">left &gt;= right</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if left is more than or equal to right.
Like Erlang, Elixir can compare any term. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#abs/1">abs(number)</a></td>
  
    <td class="summary_synopsis"><p>Returns an integer or float which is the arithmetical absolute value of <code>number</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#apply/2">apply(fun, args)</a></td>
  
    <td class="summary_synopsis"><p>Invokes the given <code>fun</code> with the array of arguments <code>args</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#apply/3">apply(module, fun, args)</a></td>
  
    <td class="summary_synopsis"><p>Invokes the given <code>fun</code> from <code>module</code> with the array of arguments <code>args</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#atom_to_list/1">atom_to_list(atom)</a></td>
  
    <td class="summary_synopsis"><p>Returns a string which corresponds to the text representation of <code>atom</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#binary_part/3">binary_part(binary, start, length)</a></td>
  
    <td class="summary_synopsis"><p>Extracts the part of the binary starting at <code>start</code> with length <code>length</code>.
Binaries are zero-indexed.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#binary_to_float/1">binary_to_float(some_binary)</a></td>
  
    <td class="summary_synopsis"><p>Returns a float whose text representation is <code>some_binary</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#binary_to_integer/1">binary_to_integer(some_binary)</a></td>
  
    <td class="summary_synopsis"><p>Returns a integer whose text representation is <code>some_binary</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#binary_to_integer/2">binary_to_integer(some_binary, base)</a></td>
  
    <td class="summary_synopsis"><p>Returns an integer whose text representation in base <code>base</code>
is <code>some_binary</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#binary_to_term/1">binary_to_term(binary)</a></td>
  
    <td class="summary_synopsis"><p>Returns an Erlang term which is the result of decoding the binary
object <code>binary</code>, which must be encoded according to the Erlang external
term format.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#binary_to_term/2">binary_to_term(binary, options)</a></td>
  
    <td class="summary_synopsis"><p>As <a href="#binary_to_term/1"><code>binary_to_term/1</code></a>, but accepts a safe option useful when receiving
binaries from an untrusted source.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#bit_size/1">bit_size(bitstring)</a></td>
  
    <td class="summary_synopsis"><p>Returns an integer which is the size in bits of <code>bitstring</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#bitstring_to_list/1">bitstring_to_list(bitstring)</a></td>
  
    <td class="summary_synopsis"><p>Returns a list of integers which correspond to the bytes of <code>bitstring</code>. If the
number of bits in the binary is not divisible by 8, the last element of the list will
be a bitstring containing the remaining bits (1 up to 7 bits).</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#byte_size/1">byte_size(bitstring)</a></td>
  
    <td class="summary_synopsis"><p>Returns an integer which is the number of bytes needed to contain <code>bitstring</code>.
(That is, if the number of bits in <code>bitstring</code> is not divisible by 8, the resulting
number of bytes will be rounded up.)</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#exit/1">exit(reason)</a></td>
  
    <td class="summary_synopsis"><p>Stops the execution of the calling process with the given reason.
Since evaluating this function causes the process to terminate,
it has no return value.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#float_to_binary/1">float_to_binary(some_float)</a></td>
  
    <td class="summary_synopsis"><p>Returns a binary which corresponds to the text representation
of <code>some_float</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#float_to_binary/2">float_to_binary(float, options)</a></td>
  
    <td class="summary_synopsis"><p>Returns a binary which corresponds to the text representation
of <code>float</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#float_to_list/1">float_to_list(number)</a></td>
  
    <td class="summary_synopsis"><p>Returns a char list which corresponds to the text representation of the given float.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#float_to_list/2">float_to_list(float, options)</a></td>
  
    <td class="summary_synopsis"><p>Returns a list which corresponds to the text representation
of <code>float</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#function_exported?/3">function_exported?(module, function, arity)</a></td>
  
    <td class="summary_synopsis"><p>Returns true if the <code>module</code> is loaded and contains a
public <code>function</code> with the given <code>arity</code>, otherwise false.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#hd/1">hd(list)</a></td>
  
    <td class="summary_synopsis"><p>Returns the head of a list, raises <code>badarg</code> if the list is empty.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#inspect/2">inspect(arg, opts // [])</a></td>
  
    <td class="summary_synopsis"><p>Inspect the given argument according to the <code>Inspect</code> protocol.
The second argument is a keywords list with options to control
inspection.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#integer_to_binary/1">integer_to_binary(some_integer)</a></td>
  
    <td class="summary_synopsis"><p>Returns a binary which corresponds to the text representation
of <code>some_integer</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#integer_to_binary/2">integer_to_binary(some_integer, base)</a></td>
  
    <td class="summary_synopsis"><p>Returns a binary which corresponds to the text representation
of <code>some_integer</code> in base <code>base</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#integer_to_list/1">integer_to_list(number)</a></td>
  
    <td class="summary_synopsis"><p>Returns a char list which corresponds to the text representation of the given integer.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#integer_to_list/2">integer_to_list(number, base)</a></td>
  
    <td class="summary_synopsis"><p>Returns a char list which corresponds to the text representation of the
given integer in the given case.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#iolist_size/1">iolist_size(item)</a></td>
  
    <td class="summary_synopsis"><p>Returns the size of an iolist.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#iolist_to_binary/1">iolist_to_binary(item)</a></td>
  
    <td class="summary_synopsis"><p>Returns a binary which is made from the integers and binaries in iolist.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_alive/0">is_alive()</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if the local node is alive; that is,
if the node can be part of a distributed system.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_atom/1">is_atom(term)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>term</code> is an atom; otherwise returns <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_binary/1">is_binary(term)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>term</code> is a binary; otherwise returns <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_bitstring/1">is_bitstring(term)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>term</code> is a bitstring (including a binary); otherwise returns <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_boolean/1">is_boolean(term)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>term</code> is either the atom <code>true</code> or the atom <code>false</code> (i.e. a boolean);
otherwise returns false.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_float/1">is_float(term)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>term</code> is a floating point number; otherwise returns <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_function/1">is_function(term)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>term</code> is a function; otherwise returns <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_function/2">is_function(term, arity)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>term</code> is a function that can be applied with <code>arity</code> number of arguments;
otherwise returns <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_integer/1">is_integer(term)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>term</code> is an integer; otherwise returns <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_list/1">is_list(term)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>term</code> is a list with zero or more elements; otherwise returns <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_number/1">is_number(term)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>term</code> is either an integer or a floating point number;
otherwise returns <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_pid/1">is_pid(term)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>term</code> is a pid (process identifier); otherwise returns <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_port/1">is_port(term)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>term</code> is a port identifier; otherwise returns <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_reference/1">is_reference(term)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>term</code> is a reference; otherwise returns <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_tuple/1">is_tuple(term)</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if <code>term</code> is a tuple; otherwise returns <code>false</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#length/1">length(list)</a></td>
  
    <td class="summary_synopsis"><p>Returns the length of <code>list</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#list_to_atom/1">list_to_atom(list)</a></td>
  
    <td class="summary_synopsis"><p>Returns the atom whose text representation is <code>list</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#list_to_bitstring/1">list_to_bitstring(bitstring_list)</a></td>
  
    <td class="summary_synopsis"><p>Returns a bitstring which is made from the integers and bitstrings in <code>bitstring_list</code>.
(the last tail in <code>bitstring_list</code> is allowed to be a bitstring.)</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#list_to_existing_atom/1">list_to_existing_atom(list)</a></td>
  
    <td class="summary_synopsis"><p>Returns the atom whose text representation is <code>list</code>,
but only if there already exists such atom.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#list_to_float/1">list_to_float(list)</a></td>
  
    <td class="summary_synopsis"><p>Returns the float whose text representation is <code>list</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#list_to_integer/1">list_to_integer(list)</a></td>
  
    <td class="summary_synopsis"><p>Returns an integer whose text representation is <code>list</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#list_to_integer/2">list_to_integer(list, base)</a></td>
  
    <td class="summary_synopsis"><p>Returns an integer whose text representation in base <code>base</code> is <code>list</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#list_to_tuple/1">list_to_tuple(list)</a></td>
  
    <td class="summary_synopsis"><p>Returns a tuple which corresponds to <code>list</code>. <code>list</code> can contain any Erlang terms.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#macro_exported?/3">macro_exported?(module, macro, arity)</a></td>
  
    <td class="summary_synopsis"><p>Returns true if the <code>module</code> is loaded and contains a
public <code>macro</code> with the given <code>arity</code>, otherwise false.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#make_ref/0">make_ref()</a></td>
  
    <td class="summary_synopsis"><p>Returns an almost unique reference.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#max/2">max(first, second)</a></td>
  
    <td class="summary_synopsis"><p>Return the biggest of the two given terms according to
Erlang&#39;s term ordering. If the terms compare equal, the
first one is returned.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#min/2">min(first, second)</a></td>
  
    <td class="summary_synopsis"><p>Return the smallest of the two given terms according to
Erlang&#39;s term ordering. If the terms compare equal, the
first one is returned.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#node/0">node()</a></td>
  
    <td class="summary_synopsis"><p>Returns an atom representing the name of the local node.
If the node is not alive, <code>nonode@nohost</code> is returned instead.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#node/1">node(arg)</a></td>
  
    <td class="summary_synopsis"><p>Returns the node where the given argument is located.
The argument can be a pid, a reference, or a port.
If the local node is not alive, <code>nonode@nohost</code> is returned.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#not/1">not arg</a></td>
  
    <td class="summary_synopsis"><p>Boolean not. Argument must be a boolean.
Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#raise/3">raise(exception, args, stacktrace)</a></td>
  
    <td class="summary_synopsis"><p>Re-raises an exception with the given stacktrace.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#round/1">round(number)</a></td>
  
    <td class="summary_synopsis"><p>Returns an integer by rounding the given number.
Allowed in guard tests.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#self/0">self()</a></td>
  
    <td class="summary_synopsis"><p>Returns the pid (process identifier) of the calling process.
Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#size/1">size(arg)</a></td>
  
    <td class="summary_synopsis"><p>Returns the size of the given argument, which must be a tuple
or a binary. If possible, please use <code>tuple_size</code> or <code>byte_size</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#spawn/1">spawn(fun)</a></td>
  
    <td class="summary_synopsis"><p>Spawns the given function and returns its pid.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#spawn/3">spawn(module, fun, args)</a></td>
  
    <td class="summary_synopsis"><p>Spawns the given module and function passing the given args
and returns its pid.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#spawn_link/1">spawn_link(fun)</a></td>
  
    <td class="summary_synopsis"><p>Spawns the given function, links it to the current process and returns its pid.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#spawn_link/3">spawn_link(module, fun, args)</a></td>
  
    <td class="summary_synopsis"><p>Spawns the given module and function passing the given args,
links it to the current process and returns its pid.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#term_to_binary/1">term_to_binary(term)</a></td>
  
    <td class="summary_synopsis"><p>Returns a binary which is the result of encoding the given <code>term</code>
according to the Erlang external term format.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#term_to_binary/2">term_to_binary(term, opts)</a></td>
  
    <td class="summary_synopsis"><p>The same as <a href="#term_to_binary/1"><code>term_to_binary/1</code></a> but also supports two options:</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#throw/1">throw(term)</a></td>
  
    <td class="summary_synopsis"><p>A non-local return from a function. Check <code>try/2</code> for more information.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#tl/1">tl(list)</a></td>
  
    <td class="summary_synopsis"><p>Returns the tail of a list. Raises <code>ArgumentError</code> if the list is empty.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#trunc/1">trunc(number)</a></td>
  
    <td class="summary_synopsis"><p>Returns an integer by truncating the given number.
Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#tuple_size/1">tuple_size(tuple)</a></td>
  
    <td class="summary_synopsis"><p>Returns the size of a tuple.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#tuple_to_list/1">tuple_to_list(tuple)</a></td>
  
    <td class="summary_synopsis"><p>Converts a tuple to a list.</p>
</td>
  
</tr>

        </table>
      

      
        <h2 id="macros_summary">Macros summary</h2>
        <table class="summary">
          <tr>
  <td class="summary_signature"><a href="#&amp;&amp;/2">left &amp;&amp; right</a></td>
  
    <td class="summary_synopsis"><p>Provides a short-circuit operator that evaluates and returns
the second expression only if the first one evaluates to true
(i.e. it is not nil nor false). Returns the first expression
otherwise.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#../2">first .. last</a></td>
  
    <td class="summary_synopsis"><p>Returns a range with the specified start and end.
Includes both ends.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#&lt;&gt;/2">left &lt;&gt; right</a></td>
  
    <td class="summary_synopsis"><p>Concatenates two binaries.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#@/1">@expr</a></td>
  
    <td class="summary_synopsis"><p>This macro is a shortcut to read and add attributes to the module
being compiled. Elixir module attributes are similar to Erlang&#39;s with
some differences. The canonical example for attributes is annotating
that a module implements the OTP behavior called <code>gen_server</code>:</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#access/2">access(element, args)</a></td>
  
    <td class="summary_synopsis"><p>Access the given element using the qualifier according
to the <code>Access</code> protocol. All calls in the form <code>foo[bar]</code>
are translated to <code>access(foo, bar)</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#and/2">left and right</a></td>
  
    <td class="summary_synopsis"><p>Boolean and. Requires only the first argument to be a
boolean since it short-circuits. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#atom_to_binary/1">atom_to_binary(some_atom)</a></td>
  
    <td class="summary_synopsis"><p>Returns a binary which corresponds to the text representation
of <code>some_atom</code> in UTF8 encoding.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#binary_to_atom/1">binary_to_atom(some_binary)</a></td>
  
    <td class="summary_synopsis"><p>Returns the atom whose text representation is <code>some_binary</code> in
UTF8 encoding.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#binary_to_existing_atom/1">binary_to_existing_atom(some_binary)</a></td>
  
    <td class="summary_synopsis"><p>Works like <a href="#binary_to_atom/1"><code>binary_to_atom/1</code></a> but the atom must exist.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#binding/0">binding()</a></td>
  
    <td class="summary_synopsis"><p>Returns the binding as a keyword list where the variable name
is the key and the variable value is the value.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#binding/1">binding(list)</a></td>
  
    <td class="summary_synopsis"><p>Receives a list of atoms at compilation time and returns the
binding of the given variables as a keyword list where the
variable name is the key and the variable value is the value.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#binding/2">binding(list, context)</a></td>
  
    <td class="summary_synopsis"><p>Receives a list of atoms at compilation time and returns the
binding of the given variables in the given context as a keyword
list where the variable name is the key and the variable value
is the value.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#case/2">case(condition, blocks)</a></td>
  
    <td class="summary_synopsis"><p>Matches the given expression against the match clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#cond/1">cond(list1)</a></td>
  
    <td class="summary_synopsis"><p>Evaluates the expression corresponding to the first clause that
evaluates to true. Raises an error if all conditions evaluate to
to falsy values (nil or false).</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#def/2">def(name, list2)</a></td>
  
    <td class="summary_synopsis"><p>Defines a function with the given name and contents.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#defdelegate/2">defdelegate(funs, opts)</a></td>
  
    <td class="summary_synopsis"><p>Defines the given functions in the current module that will
delegate to the given <code>target</code>. Functions defined with
<code>defdelegate</code> are public and are allowed to be invoked
from external. If you find yourself wishing to define a
delegation as private, you should likely use import
instead.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#defexception/3">defexception(name, fields, do_block // [])</a></td>
  
    <td class="summary_synopsis"><p>Defines an exception.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#defimpl/3">defimpl(name, opts, do_block // [])</a></td>
  
    <td class="summary_synopsis"><p>Defines an implementation for the given protocol. See
<a href="#defprotocol/2"><code>defprotocol/2</code></a> for examples.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#defmacro/2">defmacro(name, list2)</a></td>
  
    <td class="summary_synopsis"><p>Defines a macro with the given name and contents.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#defmacrop/2">defmacrop(name, list2)</a></td>
  
    <td class="summary_synopsis"><p>Defines a macro that is private. Private macros are
only accessible from the same module in which they are defined.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#defmodule/2">defmodule(name, list2)</a></td>
  
    <td class="summary_synopsis"><p>Defines a module given by name with the given contents.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#defoverridable/1">defoverridable(tuples)</a></td>
  
    <td class="summary_synopsis"><p>Makes the given functions in the current module overridable. An overridable
function is lazily defined, allowing a developer to customize it.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#defp/2">defp(name, list2)</a></td>
  
    <td class="summary_synopsis"><p>Defines a function that is private. Private functions are
only accessible from within the module in which they are defined.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#defprotocol/2">defprotocol(name, list2)</a></td>
  
    <td class="summary_synopsis"><p>Defines a module as a protocol and specifies the API that
should be defined by its implementations.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#defrecord/3">defrecord(name, fields, do_block // [])</a></td>
  
    <td class="summary_synopsis"><p>Exports a module with a record definition and runtime operations.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#defrecordp/3">defrecordp(name, tag // nil, fields)</a></td>
  
    <td class="summary_synopsis"><p>Defines a set of private macros to manipulate a record definition.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#destructure/2">destructure(left, right)</a></td>
  
    <td class="summary_synopsis"><p>Allows you to destructure two lists, assigning each term in the right to the
matching term in the left. Unlike pattern matching via <code>=</code>, if the sizes of
the left and right lists don&#39;t match, destructuring simply stops instead of
raising an error.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#div/2">div(left, right)</a></td>
  
    <td class="summary_synopsis"><p>Provides an integer division macro according to Erlang semantics.
Raises an error if one of the arguments is not an integer.
Can be used in guard tests.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#elem/2">elem(tuple, index)</a></td>
  
    <td class="summary_synopsis"><p>Get the element at the zero-based <code>index</code> in <code>tuple</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#if/2">if(condition, clauses)</a></td>
  
    <td class="summary_synopsis"><p>Provides an <code>if</code> macro. This macro expects the first argument to
be a condition and the rest are keyword arguments.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#in/2">left in right</a></td>
  
    <td class="summary_synopsis"><p>Returns <code>true</code> if the element on the left is equal (==) to
any of the items on the right.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_exception/1">is_exception(thing)</a></td>
  
    <td class="summary_synopsis"><p>Checks if the given structure is an exception.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_range/1">is_range(thing)</a></td>
  
    <td class="summary_synopsis"><p>Checks if the given argument is a range.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_record/1">is_record(thing)</a></td>
  
    <td class="summary_synopsis"><p>Checks if the given argument is a record.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_record/2">is_record(thing, kind)</a></td>
  
    <td class="summary_synopsis"><p>Checks if the given structure is a record. It is basically
a convenient macro that checks the structure is a tuple and
the first element matches the given kind.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#is_regex/1">is_regex(thing)</a></td>
  
    <td class="summary_synopsis"><p>Checks if the given argument is a regex.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#match?/2">match?(pattern, expr)</a></td>
  
    <td class="summary_synopsis"><p>A convenient macro that checks if the right side matches
the left side. The left side is allowed to be a match pattern.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#nil?/1">nil?(x)</a></td>
  
    <td class="summary_synopsis"><p>Checks if the given argument is nil or not.
Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#or/2">left or right</a></td>
  
    <td class="summary_synopsis"><p>Boolean or. Requires only the first argument to be a
boolean since it short-circuits. Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#raise/1">raise(msg)</a></td>
  
    <td class="summary_synopsis"><p>Raises an error.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#raise/2">raise(exception, args // [])</a></td>
  
    <td class="summary_synopsis"><p>Raises an error.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#receive/1">receive(args)</a></td>
  
    <td class="summary_synopsis"><p>The current process will hang until it receives a message
from other processes that matches the given clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#rem/2">rem(left, right)</a></td>
  
    <td class="summary_synopsis"><p>Provides an integer remainder macro according to Erlang semantics.
Raises an error if one of the arguments is not an integer.
Can be used in guard tests.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#set_elem/3">set_elem(tuple, index, value)</a></td>
  
    <td class="summary_synopsis"><p>Sets the element in <code>tuple</code> at the zero-based <code>index</code> to the given <code>value</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#sigil_C/2">sigil_C(arg1, list2)</a></td>
  
    <td class="summary_synopsis"><p>Handles the sigil %C. It simply returns a char list
without escaping characters and without interpolations.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#sigil_R/2">sigil_R(arg1, options)</a></td>
  
    <td class="summary_synopsis"><p>Handles the sigil %R. It returns a Regex pattern without escaping
nor interpreting interpolations.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#sigil_S/2">sigil_S(string, list2)</a></td>
  
    <td class="summary_synopsis"><p>Handles the sigil %S. It simples returns a string
without escaping characters and without interpolations.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#sigil_W/2">sigil_W(arg1, modifiers)</a></td>
  
    <td class="summary_synopsis"><p>Handles the sigil %W. It returns a list of &quot;words&quot; split by whitespace
without escaping nor interpreting interpolations.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#sigil_c/2">sigil_c(arg1, list2)</a></td>
  
    <td class="summary_synopsis"><p>Handles the sigil %c. It returns a char list as if it was a single
quoted string, unescaping characters and replacing interpolations.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#sigil_r/2">sigil_r(arg1, options)</a></td>
  
    <td class="summary_synopsis"><p>Handles the sigil %r. It returns a Regex pattern.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#sigil_s/2">sigil_s(arg1, list2)</a></td>
  
    <td class="summary_synopsis"><p>Handles the sigil %s. It returns a string as if it was double quoted
string, unescaping characters and replacing interpolations.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#sigil_w/2">sigil_w(arg1, modifiers)</a></td>
  
    <td class="summary_synopsis"><p>Handles the sigil %w. It returns a list of &quot;words&quot; split by whitespace.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#to_char_list/1">to_char_list(arg)</a></td>
  
    <td class="summary_synopsis"><p>Convert the argument to a list according to the List.Chars protocol.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#to_string/1">to_string(arg)</a></td>
  
    <td class="summary_synopsis"><p>Converts the argument to a string according to the String.Chars protocol.
This is the function invoked when there is string interpolation.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#try/1">try(args)</a></td>
  
    <td class="summary_synopsis"><p>Evaluate the given expressions and catch any error, exit
or throw that may have happened.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#unless/2">unless(clause, options)</a></td>
  
    <td class="summary_synopsis"><p>Evaluates and returns the do-block passed in as a second argument
unless clause evaluates to true.
Returns nil otherwise.
See also <code>if</code>.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#use/2">use(module, args // [])</a></td>
  
    <td class="summary_synopsis"><p><code>use</code> is a simple mechanism for using a given module into
the current context.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#xor/2">left xor right</a></td>
  
    <td class="summary_synopsis"><p>Boolean exclusive-or. Arguments must be booleans.
Returns <code>true</code> if and only if both arguments are different.
Allowed in guard clauses.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#|&gt;/2">left |&gt; right</a></td>
  
    <td class="summary_synopsis"><p><code>|&gt;</code> is called the pipeline operator as it is useful
to write pipeline style expressions. This operator
introduces the expression on the left as the first
argument to the function call on the right.</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#||/2">left || right</a></td>
  
    <td class="summary_synopsis"><p>Provides a short-circuit operator that evaluates and returns the second
expression only if the first one does not evaluate to true (i.e. it
is either nil or false). Returns the first expression otherwise.</p>
</td>
  
</tr>

        </table>
      

      

      

      
        <div id="functions_details" class="details_list">
          <h2>Functions</h2>
          <div class="detail">
  <p class="signature" id="!/1">
    <strong>!arg</strong>
  </p>
  
  <div class="docstring"><p>Receives any argument and returns <code>true</code> if it is <code>false</code>
or <code>nil</code>. Returns <code>false</code> otherwise. Not allowed in guard
clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; !1
false
iex&gt; ![1, 2, 3]
false
iex&gt; !false
true
iex&gt; !nil
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L220" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="!=/2">
    <strong>left != right</strong>
  </p>
  
  <div class="docstring"><p>Returns <code>true</code> if the two items are not equal.</p>

<p>This operator considers 1 and 1.0 to be equal. For strict
comparison, use <code>!==</code> instead.</p>

<p>Like Erlang, Elixir can compare any term. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; 1 != 2
true
iex&gt; 1 != 1.0
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L317" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="!==/2">
    <strong>left !== right</strong>
  </p>
  
  <div class="docstring"><p>Returns <code>true</code> if the two items are strictly not equal.
Like Erlang, Elixir can compare any term. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; 1 !== 2
true

iex&gt; 1 !== 1.0
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L351" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="*/2">
    <strong>left * right</strong>
  </p>
  
  <div class="docstring"><p>Arithmetic multiplication. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; 1 * 2
2
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L81" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="+/1">
    <strong>+value</strong>
  </p>
  
  <div class="docstring"><p>Arithmetic unary plus. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; +1
1
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L55" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="+/2">
    <strong>left + right</strong>
  </p>
  
  <div class="docstring"><p>Arithmetic plus. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; 1 + 2
3
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L29" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="++/2">
    <strong>left ++ right</strong>
  </p>
  
  <div class="docstring"><p>Concatenates two lists. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; [1] ++ [2, 3]
[1,2,3]

iex&gt; &#39;foo&#39; ++ &#39;bar&#39;
&#39;foobar&#39;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L129" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="-/1">
    <strong>-value</strong>
  </p>
  
  <div class="docstring"><p>Arithmetic unary minus. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; -2
-2
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L68" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="-/2">
    <strong>left - right</strong>
  </p>
  
  <div class="docstring"><p>Arithmetic minus. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; 1 - 2
-1
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L42" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="--/2">
    <strong>left -- right</strong>
  </p>
  
  <div class="docstring"><p>Removes the first occurrence of an item on the left
for each item on the right. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; [1, 2, 3] -- [1, 2]
[3]

iex&gt; [1, 2, 3, 2, 1] -- [1, 2, 2]
[3,1]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L146" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="//2">
    <strong>left / right</strong>
  </p>
  
  <div class="docstring"><p>Arithmetic division. Unlike other languages,
the result is always a float. Use <code>div</code> and <code>rem</code> if you want
a natural division or the remainder. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; 1 / 2
0.5
iex&gt; 2 / 1
2.0
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L98" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="&lt;/2">
    <strong>left &lt; right</strong>
  </p>
  
  <div class="docstring"><p>Returns <code>true</code> if left is less than right.
Like Erlang, Elixir can compare any term. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; 1 &lt; 2
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L234" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="&lt;-/2">
    <strong>pid &lt;- msg</strong>
  </p>
  
  <div class="docstring"><p>Sends a message to the process identified on the left.
A process can be identified by its PID or, if it is registered,
by an atom.</p>

<h2>Examples</h2>

<pre><code>process = Kernel.self
process &lt;- { :ok, &quot;Sending myself a message&quot; }
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L113" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="&lt;=/2">
    <strong>left &lt;= right</strong>
  </p>
  
  <div class="docstring"><p>Returns <code>true</code> if left is less than or equal to right.
Like Erlang, Elixir can compare any term. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; 1 &lt;= 2
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L262" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="==/2">
    <strong>left == right</strong>
  </p>
  
  <div class="docstring"><p>Returns <code>true</code> if the two items are equal.</p>

<p>This operator considers 1 and 1.0 to be equal. For strict
comparison, use <code>===</code> instead.</p>

<p>Like Erlang, Elixir can compare any term. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; 1 == 2
false

iex&gt; 1 == 1.0
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L297" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="===/2">
    <strong>left === right</strong>
  </p>
  
  <div class="docstring"><p>Returns <code>true</code> if the two items are strictly equal.
Like Erlang, Elixir can compare any term. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; 1 === 2
false

iex&gt; 1 === 1.0
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L334" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="=~/2">
    <strong>left =~ right</strong>
  </p>
  
  <div class="docstring"><p>Matches the term on the left against the regular expression or string on the
right. Returns true if <code>left</code> matches <code>right</code> (if it&#39;s a regular expression)
or contains <code>right</code> (if it&#39;s a string).</p>

<h2>Examples</h2>

<pre><code>iex&gt; &quot;abcd&quot; =~ %r/c(d)/
true

iex&gt; &quot;abcd&quot; =~ %r/e/
false

iex&gt; &quot;abcd&quot; =~ &quot;bc&quot;
true

iex&gt; &quot;abcd&quot; =~ &quot;ad&quot;
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1671" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="&gt;/2">
    <strong>left &gt; right</strong>
  </p>
  
  <div class="docstring"><p>Returns <code>true</code> if left is more than right.
Like Erlang, Elixir can compare any term. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; 1 &gt; 2
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L248" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="&gt;=/2">
    <strong>left &gt;= right</strong>
  </p>
  
  <div class="docstring"><p>Returns <code>true</code> if left is more than or equal to right.
Like Erlang, Elixir can compare any term. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; 1 &gt;= 2
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L276" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="abs/1">
    <strong>abs(number)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>abs(number) :: number</li>
      
    </ul>
  
  <div class="docstring"><p>Returns an integer or float which is the arithmetical absolute value of <code>number</code>.</p>

<p>Allowed in guard tests.</p>

<h2>Examples</h2>

<pre><code>iex&gt; abs(-3.33)
3.33
iex&gt; abs(-3)
3
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L394" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="apply/2">
    <strong>apply(fun, args)</strong>
  </p>
  
  <div class="docstring"><p>Invokes the given <code>fun</code> with the array of arguments <code>args</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; apply(fn x -&gt; x * 2 end, [2])
4
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L364" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="apply/3">
    <strong>apply(module, fun, args)</strong>
  </p>
  
  <div class="docstring"><p>Invokes the given <code>fun</code> from <code>module</code> with the array of arguments <code>args</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; apply(Enum, :reverse, [[1, 2, 3]])
[3,2,1]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L377" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="atom_to_list/1">
    <strong>atom_to_list(atom)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>atom_to_list(atom) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a string which corresponds to the text representation of <code>atom</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; atom_to_list(:elixir)
&#39;elixir&#39;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L408" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="binary_part/3">
    <strong>binary_part(binary, start, length)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>binary_part(binary, pos_integer, integer) :: binary</li>
      
    </ul>
  
  <div class="docstring"><p>Extracts the part of the binary starting at <code>start</code> with length <code>length</code>.
Binaries are zero-indexed.</p>

<p>If start or length references in any way outside the binary, an
<code>ArgumentError</code> exception is raised.</p>

<p>Allowed in guard tests.</p>

<h2>Examples</h2>

<pre><code>iex&gt; binary_part(&quot;foo&quot;, 1, 2)
&quot;oo&quot;
</code></pre>

<p>A negative length can be used to extract bytes at the end of a binary:</p>

<pre><code>iex&gt; binary_part(&quot;foo&quot;, 3, -1)
&quot;o&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L433" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="binary_to_float/1">
    <strong>binary_to_float(some_binary)</strong>
  </p>
  
  <div class="docstring"><p>Returns a float whose text representation is <code>some_binary</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; binary_to_float(&quot;2.2017764e+0&quot;)
2.2017764
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2747" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="binary_to_integer/1">
    <strong>binary_to_integer(some_binary)</strong>
  </p>
  
  <div class="docstring"><p>Returns a integer whose text representation is <code>some_binary</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; binary_to_integer(&quot;123&quot;)
123
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2720" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="binary_to_integer/2">
    <strong>binary_to_integer(some_binary, base)</strong>
  </p>
  
  <div class="docstring"><p>Returns an integer whose text representation in base <code>base</code>
is <code>some_binary</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; binary_to_integer(&quot;3FF&quot;, 16)
1023
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2734" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="binary_to_term/1">
    <strong>binary_to_term(binary)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>binary_to_term(binary) :: term</li>
      
    </ul>
  
  <div class="docstring"><p>Returns an Erlang term which is the result of decoding the binary
object <code>binary</code>, which must be encoded according to the Erlang external
term format.</p>

<h2>Examples</h2>

<pre><code>iex&gt; binary_to_term(term_to_binary(&quot;foo&quot;))
&quot;foo&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L449" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="binary_to_term/2">
    <strong>binary_to_term(binary, options)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>binary_to_term(binary, nil | [:safe]) :: term</li>
      
    </ul>
  
  <div class="docstring"><p>As <a href="#binary_to_term/1"><code>binary_to_term/1</code></a>, but accepts a safe option useful when receiving
binaries from an untrusted source.</p>

<p>When enabled, it prevents decoding data that may be used to attack the
Erlang system. In the event of receiving unsafe data, decoding fails
with a badarg error.</p>

<p>Currently, this prevents creation of new atoms directly, creation of
new atoms indirectly (as they are embedded in certain structures like pids,
refs, funs, etc), and creation of new external function references. None
of those resources are currently garbage collected, so unchecked creation
of them can exhaust available memory.</p>

<h2>Examples</h2>

<pre><code>iex&gt; binary_to_term(term_to_binary(&quot;foo&quot;), [:safe])
&quot;foo&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L474" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="bit_size/1">
    <strong>bit_size(bitstring)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>bit_size(bitstring) :: non_neg_integer</li>
      
    </ul>
  
  <div class="docstring"><p>Returns an integer which is the size in bits of <code>bitstring</code>.</p>

<p>Allowed in guard tests.</p>

<h2>Examples</h2>

<pre><code>iex&gt; bit_size(&lt;&lt;433::16, 3::3&gt;&gt;)
19
iex&gt; bit_size(&lt;&lt;1, 2, 3&gt;&gt;)
24
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L492" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="bitstring_to_list/1">
    <strong>bitstring_to_list(bitstring)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>bitstring_to_list(bitstring) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a list of integers which correspond to the bytes of <code>bitstring</code>. If the
number of bits in the binary is not divisible by 8, the last element of the list will
be a bitstring containing the remaining bits (1 up to 7 bits).</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L502" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="byte_size/1">
    <strong>byte_size(bitstring)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>byte_size(bitstring) :: non_neg_integer</li>
      
    </ul>
  
  <div class="docstring"><p>Returns an integer which is the number of bytes needed to contain <code>bitstring</code>.
(That is, if the number of bits in <code>bitstring</code> is not divisible by 8, the resulting
number of bytes will be rounded up.)</p>

<p>Allowed in guard tests.</p>

<h2>Examples</h2>

<pre><code>iex&gt; byte_size(&lt;&lt;433::16, 3::3&gt;&gt;)
3
iex&gt; byte_size(&lt;&lt;1, 2, 3&gt;&gt;)
3
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L522" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="exit/1">
    <strong>exit(reason)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>exit(term) :: no_return</li>
      
    </ul>
  
  <div class="docstring"><p>Stops the execution of the calling process with the given reason.
Since evaluating this function causes the process to terminate,
it has no return value.</p>

<h2>Examples</h2>

<pre><code>exit(:normal)
exit(:seems_bad)
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L538" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="float_to_binary/1">
    <strong>float_to_binary(some_float)</strong>
  </p>
  
  <div class="docstring"><p>Returns a binary which corresponds to the text representation
of <code>some_float</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; float_to_binary(7.0)
&quot;7.00000000000000000000e+00&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2789" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="float_to_binary/2">
    <strong>float_to_binary(float, options)</strong>
  </p>
  
  <div class="docstring"><p>Returns a binary which corresponds to the text representation
of <code>float</code>.</p>

<h2>Options</h2>

<ul>
<li><code>:decimals</code>  number of decimal points to show</li>
<li><code>:scientific</code>  number of decimal points to show, in scientific format</li>
<li><code>:compact</code>  If true, use the most compact representation (ignored with the <code>scientific</code> option)</li>
</ul>

<h2>Examples</h2>

<pre><code>float_to_binary 7.1, [decimals: 2, compact: true] #=&gt; &quot;7.1&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2808" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="float_to_list/1">
    <strong>float_to_list(number)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>float_to_list(number) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a char list which corresponds to the text representation of the given float.</p>

<h2>Examples</h2>

<pre><code>iex&gt; float_to_list(7.0)
&#39;7.00000000000000000000e+00&#39;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L552" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="float_to_list/2">
    <strong>float_to_list(float, options)</strong>
  </p>
  
  <div class="docstring"><p>Returns a list which corresponds to the text representation
of <code>float</code>.</p>

<h2>Options</h2>

<ul>
<li><code>:decimals</code>  number of decimal points to show</li>
<li><code>:scientific</code>  number of decimal points to show, in scientific format</li>
<li><code>:compact</code>  If true, use the most compact representation (ignored with the <code>scientific</code> option)</li>
</ul>

<h2>Examples</h2>

<pre><code>float_to_list 7.1, [decimals: 2, compact: true] #=&gt; &#39;7.1&#39;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2827" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="function_exported?/3">
    <strong>function_exported?(module, function, arity)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>function_exported?(atom | {}, atom, integer) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns true if the <code>module</code> is loaded and contains a
public <code>function</code> with the given <code>arity</code>, otherwise false.</p>

<p>In case a tuple module is given, the <code>arity</code> is automatically
increased by one.</p>

<p>Notice that this function does not load the module in case
it is not loaded. Check <a href="Code.html#ensure_loaded/1"><code>Code.ensure_loaded/1</code></a> for more
information.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3189" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="hd/1">
    <strong>hd(list)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>hd([]) :: term</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the head of a list, raises <code>badarg</code> if the list is empty.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L560" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="inspect/2">
    <strong>inspect(arg, opts // [])</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>inspect(<a href="Inspect.html#t:t/0">Inspect.t</a>, <a href="Keyword.html#t:t/0">Keyword.t</a>) :: <a href="String.html#t:t/0">String.t</a></li>
      
        <li>inspect(<a href="Inspect.html#t:t/0">Inspect.t</a>, <a href="http://elixir-lang.org/docs/master/Inspect.Opts.html#t:t/0">Inspect.Opts.t</a>) :: <a href="Inspect.Algebra.html#t:t/0">Inspect.Algebra.t</a></li>
      
    </ul>
  
  <div class="docstring"><p>Inspect the given argument according to the <code>Inspect</code> protocol.
The second argument is a keywords list with options to control
inspection.</p>

<p>The second argument may also be an instance of the <code>Inspect.Opts</code>
record and, in such cases, instead of returning a string, it
returns an algebra document which can be converted to a string
via <code>Inspect.Algebra</code>.</p>

<h2>Options</h2>

<p>The following options are supported:</p>

<ul>
<li><p><code>:raw</code>   - when true, record tuples are not formatted by the inspect protocol,
         but are printed as just tuples, defaults to false;</p></li>
<li><p><code>:limit</code> - limits the number of items that are printed for tuples, bitstrings,
         and lists, does not apply to strings nor char lists, defaults to 50;</p></li>
<li><p><code>:pretty</code> - if set to true enables pretty printing, defaults to false;</p></li>
<li><p><code>:width</code> - the width avaliable for inspect to lay out the data structure
         representation. Defaults to the least of 80 and terminal width;</p></li>
</ul>

<h2>Examples</h2>

<pre><code>iex&gt; inspect(:foo)
&quot;:foo&quot;

iex&gt; inspect [1, 2, 3, 4, 5], limit: 3
&quot;[1, 2, 3, ...]&quot;

iex&gt; inspect(ArgumentError[])
&quot;ArgumentError[message: \&quot;argument error\&quot;]&quot;

iex&gt; inspect(ArgumentError[], raw: true)
&quot;{ArgumentError, :__exception__, \&quot;argument error\&quot;}&quot;
</code></pre>

<p>Note that the inspect protocol does not necessarily return a valid
representation of an Elixir term. In such cases, the inspected result
must start with <code>#</code>. For example, inspecting a function will return:</p>

<pre><code>inspect &amp;(&amp;1 + &amp;2)
#=&gt; #Function&lt;...&gt;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1970" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="integer_to_binary/1">
    <strong>integer_to_binary(some_integer)</strong>
  </p>
  
  <div class="docstring"><p>Returns a binary which corresponds to the text representation
of <code>some_integer</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; integer_to_binary(123)
&quot;123&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2761" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="integer_to_binary/2">
    <strong>integer_to_binary(some_integer, base)</strong>
  </p>
  
  <div class="docstring"><p>Returns a binary which corresponds to the text representation
of <code>some_integer</code> in base <code>base</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; integer_to_binary(100, 16)
&quot;64&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2775" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="integer_to_list/1">
    <strong>integer_to_list(number)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>integer_to_list(integer) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a char list which corresponds to the text representation of the given integer.</p>

<h2>Examples</h2>

<pre><code>iex&gt; integer_to_list(7)
&#39;7&#39;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L574" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="integer_to_list/2">
    <strong>integer_to_list(number, base)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>integer_to_list(integer, pos_integer) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a char list which corresponds to the text representation of the
given integer in the given case.</p>

<h2>Examples</h2>

<pre><code>iex&gt; integer_to_list(1023, 16)
&#39;3FF&#39;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L589" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="iolist_size/1">
    <strong>iolist_size(item)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>iolist_size(iolist) :: non_neg_integer</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the size of an iolist.</p>

<h2>Examples</h2>

<pre><code>iex&gt; iolist_size([1, 2|&lt;&lt;3, 4&gt;&gt;])
4
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L603" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="iolist_to_binary/1">
    <strong>iolist_to_binary(item)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>iolist_to_binary(iolist | binary) :: binary</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a binary which is made from the integers and binaries in iolist.</p>

<p>Notice that this function treats lists of integers as raw bytes
and does not perform any kind of encoding conversion. If you want to convert
from a char list to a string (both utf-8 encoded), please use
<a href="String.html#from_char_list!/1"><code>String.from_char_list!/1</code></a> instead.</p>

<p>If this function receives a binary, the same binary is returned.</p>

<h2>Examples</h2>

<pre><code>iex&gt; bin1 = &lt;&lt;1, 2, 3&gt;&gt;
...&gt; bin2 = &lt;&lt;4, 5&gt;&gt;
...&gt; bin3 = &lt;&lt;6&gt;&gt;
...&gt; iolist_to_binary([bin1, 1, [2, 3, bin2], 4|bin3])
&lt;&lt;1,2,3,1,2,3,4,5,4,6&gt;&gt;

iex&gt; bin = &lt;&lt;1, 2, 3&gt;&gt;
...&gt; iolist_to_binary(bin)
&lt;&lt;1,2,3&gt;&gt;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L631" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_alive/0">
    <strong>is_alive()</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_alive :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if the local node is alive; that is,
if the node can be part of a distributed system.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L640" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_atom/1">
    <strong>is_atom(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_atom(term) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>term</code> is an atom; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L650" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_binary/1">
    <strong>is_binary(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_binary(term) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>term</code> is a binary; otherwise returns <code>false</code>.</p>

<p>A binary always contains a complete number of bytes.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L662" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_bitstring/1">
    <strong>is_bitstring(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_bitstring(term) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>term</code> is a bitstring (including a binary); otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L672" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_boolean/1">
    <strong>is_boolean(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_boolean(term) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>term</code> is either the atom <code>true</code> or the atom <code>false</code> (i.e. a boolean);
otherwise returns false.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L683" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_float/1">
    <strong>is_float(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_float(term) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>term</code> is a floating point number; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L693" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_function/1">
    <strong>is_function(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_function(term) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>term</code> is a function; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L703" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_function/2">
    <strong>is_function(term, arity)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_function(term, non_neg_integer) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>term</code> is a function that can be applied with <code>arity</code> number of arguments;
otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L714" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_integer/1">
    <strong>is_integer(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_integer(term) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>term</code> is an integer; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L724" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_list/1">
    <strong>is_list(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_list(term) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>term</code> is a list with zero or more elements; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L734" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_number/1">
    <strong>is_number(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_number(term) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>term</code> is either an integer or a floating point number;
otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L745" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_pid/1">
    <strong>is_pid(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_pid(term) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>term</code> is a pid (process identifier); otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L755" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_port/1">
    <strong>is_port(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_port(term) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>term</code> is a port identifier; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L765" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_reference/1">
    <strong>is_reference(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_reference(term) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>term</code> is a reference; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L775" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_tuple/1">
    <strong>is_tuple(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>is_tuple(term) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns <code>true</code> if <code>term</code> is a tuple; otherwise returns <code>false</code>.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L785" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="length/1">
    <strong>length(list)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>length([]) :: non_neg_integer</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the length of <code>list</code>.</p>

<p>Allowed in guard tests.</p>

<h2>Examples</h2>

<pre><code>iex&gt; length([1, 2, 3, 4, 5, 6, 7, 8, 9])
9
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L800" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="list_to_atom/1">
    <strong>list_to_atom(list)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>list_to_atom([]) :: atom</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the atom whose text representation is <code>list</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; list_to_atom(&#39;elixir&#39;)
:elixir
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L813" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="list_to_bitstring/1">
    <strong>list_to_bitstring(bitstring_list)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>list_to_bitstring(maybe_improper_list(char | binary | iolist | bitstring, binary | bitstring | nil)) :: bitstring</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a bitstring which is made from the integers and bitstrings in <code>bitstring_list</code>.
(the last tail in <code>bitstring_list</code> is allowed to be a bitstring.)</p>

<h2>Examples</h2>

<pre><code>iex&gt; bin1 = &lt;&lt;1, 2, 3&gt;&gt;
...&gt; bin2 = &lt;&lt;4, 5&gt;&gt;
...&gt; bin3 = &lt;&lt;6, 7::4&gt;&gt;
...&gt; list_to_bitstring([bin1, 1, [2, 3, bin2], 4|bin3])
&lt;&lt;1,2,3,1,2,3,4,5,4,6,7::size(4)&gt;&gt;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L831" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="list_to_existing_atom/1">
    <strong>list_to_existing_atom(list)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>list_to_existing_atom([]) :: atom</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the atom whose text representation is <code>list</code>,
but only if there already exists such atom.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L840" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="list_to_float/1">
    <strong>list_to_float(list)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>list_to_float([]) :: float</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the float whose text representation is <code>list</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; list_to_float(&#39;2.2017764e+0&#39;)
2.2017764
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L853" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="list_to_integer/1">
    <strong>list_to_integer(list)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>list_to_integer([]) :: integer</li>
      
    </ul>
  
  <div class="docstring"><p>Returns an integer whose text representation is <code>list</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; list_to_integer(&#39;123&#39;)
123
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L866" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="list_to_integer/2">
    <strong>list_to_integer(list, base)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>list_to_integer([], non_neg_integer) :: integer</li>
      
    </ul>
  
  <div class="docstring"><p>Returns an integer whose text representation in base <code>base</code> is <code>list</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; list_to_integer(&#39;3FF&#39;, 16)
1023
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L879" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="list_to_tuple/1">
    <strong>list_to_tuple(list)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>list_to_tuple([]) :: {}</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a tuple which corresponds to <code>list</code>. <code>list</code> can contain any Erlang terms.</p>

<h2>Examples</h2>

<pre><code>iex&gt; list_to_tuple([:share, [:elixir, 163]])
{:share, [:elixir, 163]}
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L892" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="macro_exported?/3">
    <strong>macro_exported?(module, macro, arity)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>macro_exported?(atom, atom, integer) :: boolean</li>
      
    </ul>
  
  <div class="docstring"><p>Returns true if the <code>module</code> is loaded and contains a
public <code>macro</code> with the given <code>arity</code>, otherwise false.</p>

<p>Notice that this function does not load the module in case
it is not loaded. Check <a href="Code.html#ensure_loaded/1"><code>Code.ensure_loaded/1</code></a> for more
information.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3207" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="make_ref/0">
    <strong>make_ref()</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>make_ref :: reference</li>
      
    </ul>
  
  <div class="docstring"><p>Returns an almost unique reference.</p>

<p>The returned reference will re-occur after approximately 2^82 calls;
therefore it is unique enough for practical purposes.</p>

<h2>Examples</h2>

<pre><code>make_ref() #=&gt; #Reference&lt;0.0.0.135&gt;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L908" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="max/2">
    <strong>max(first, second)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>max(term, term) :: term</li>
      
    </ul>
  
  <div class="docstring"><p>Return the biggest of the two given terms according to
Erlang&#39;s term ordering. If the terms compare equal, the
first one is returned.</p>

<h2>Examples</h2>

<pre><code>iex&gt; max(1, 2)
2
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L924" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="min/2">
    <strong>min(first, second)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>min(term, term) :: term</li>
      
    </ul>
  
  <div class="docstring"><p>Return the smallest of the two given terms according to
Erlang&#39;s term ordering. If the terms compare equal, the
first one is returned.</p>

<h2>Examples</h2>

<pre><code>iex&gt; min(1, 2)
1
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L940" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="node/0">
    <strong>node()</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>node :: node</li>
      
    </ul>
  
  <div class="docstring"><p>Returns an atom representing the name of the local node.
If the node is not alive, <code>nonode@nohost</code> is returned instead.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L951" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="node/1">
    <strong>node(arg)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>node(pid | reference | port) :: node</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the node where the given argument is located.
The argument can be a pid, a reference, or a port.
If the local node is not alive, <code>nonode@nohost</code> is returned.</p>

<p>Allowed in guard tests.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L963" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="not/1">
    <strong>not arg</strong>
  </p>
  
  <div class="docstring"><p>Boolean not. Argument must be a boolean.
Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; not false
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L199" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="raise/3">
    <strong>raise(exception, args, stacktrace)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>raise({} | atom, [], []) :: no_return</li>
      
    </ul>
  
  <div class="docstring"><p>Re-raises an exception with the given stacktrace.</p>

<h2>Examples</h2>

<pre><code>try do
  raise &quot;Oops&quot;
rescue
  exception -&gt;
    stacktrace = System.stacktrace
    if exception.message == &quot;Oops&quot; do
      raise exception, [], stacktrace
    end
end
</code></pre>

<p>Notice that <code>System.stacktrace</code> returns the stacktrace
of the last exception. That said, it is common to assign
the stacktrace as the first expression inside a <code>rescue</code>
clause as any other exception potentially raised (and
rescued) in between the rescue clause and the raise call
may change the <code>System.stacktrace</code> value.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3173" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="round/1">
    <strong>round(number)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>round(number) :: integer</li>
      
    </ul>
  
  <div class="docstring"><p>Returns an integer by rounding the given number.
Allowed in guard tests.</p>

<h2>Examples</h2>

<pre><code>iex&gt; round(5.5)
6
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L978" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="self/0">
    <strong>self()</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>self :: pid</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the pid (process identifier) of the calling process.
Allowed in guard clauses.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L987" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="size/1">
    <strong>size(arg)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>size({} | binary) :: non_neg_integer</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the size of the given argument, which must be a tuple
or a binary. If possible, please use <code>tuple_size</code> or <code>byte_size</code>.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L996" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="spawn/1">
    <strong>spawn(fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>spawn((() -> any)) :: pid</li>
      
    </ul>
  
  <div class="docstring"><p>Spawns the given function and returns its pid.</p>

<p>Check the modules <code>Process</code> and <code>Node</code> for other functions
to handle processes, including spawning functions in nodes.</p>

<h2>Examples</h2>

<pre><code>current = Kernel.self
child   = spawn(fn -&gt; current &lt;- { Kernel.self, 1 + 2 } end)

receive do
  { ^child, 3 } -&gt; IO.puts &quot;Received 3 back&quot;
end
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1017" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="spawn/3">
    <strong>spawn(module, fun, args)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>spawn(module, atom, []) :: pid</li>
      
    </ul>
  
  <div class="docstring"><p>Spawns the given module and function passing the given args
and returns its pid.</p>

<p>Check the modules <code>Process</code> and <code>Node</code> for other functions
to handle processes, including spawning functions in nodes.</p>

<h2>Examples</h2>

<pre><code>spawn(SomeModule, :function, [1, 2, 3])
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1034" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="spawn_link/1">
    <strong>spawn_link(fun)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>spawn_link((() -> any)) :: pid</li>
      
    </ul>
  
  <div class="docstring"><p>Spawns the given function, links it to the current process and returns its pid.</p>

<p>Check the modules <code>Process</code> and <code>Node</code> for other functions
to handle processes, including spawning functions in nodes.</p>

<h2>Examples</h2>

<pre><code>current = Kernel.self
child   = spawn_link(fn -&gt; current &lt;- { Kernel.self, 1 + 2 } end)

receive do
  { ^child, 3 } -&gt; IO.puts &quot;Received 3 back&quot;
end
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1055" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="spawn_link/3">
    <strong>spawn_link(module, fun, args)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>spawn_link(module, atom, []) :: pid</li>
      
    </ul>
  
  <div class="docstring"><p>Spawns the given module and function passing the given args,
links it to the current process and returns its pid.</p>

<p>Check the modules <code>Process</code> and <code>Node</code> for other functions
to handle processes, including spawning functions in nodes.</p>

<h2>Examples</h2>

<pre><code>spawn_link(SomeModule, :function, [1, 2, 3])
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1072" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="term_to_binary/1">
    <strong>term_to_binary(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>term_to_binary(term) :: binary</li>
      
    </ul>
  
  <div class="docstring"><p>Returns a binary which is the result of encoding the given <code>term</code>
according to the Erlang external term format.</p>

<p>This can be used for a variety of purposes, for example, writing a term
to a file in an efficient way, or sending an Erlang term to some type
of communications channel not supported by distributed.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1085" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="term_to_binary/2">
    <strong>term_to_binary(term, opts)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>term_to_binary(term, [{:compressed, 0 .. 9} | {:minor_version, 0} | {:minor_version, 1}]) :: binary</li>
      
    </ul>
  
  <div class="docstring"><p>The same as <a href="#term_to_binary/1"><code>term_to_binary/1</code></a> but also supports two options:</p>

<ul>
<li><code>compressed</code>: the level of compression to be used from 0 to 9;</li>
<li><code>minor_version</code>: used to control the details of encoding. Can be 0 or 1,
please read <a href="http://www.erlang.org/doc/man/erlang.html#term_to_binary-2">http://www.erlang.org/doc/man/erlang.html#term_to_binary-2</a>
for more details</li>
</ul>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1099" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="throw/1">
    <strong>throw(term)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>throw(term) :: no_return</li>
      
    </ul>
  
  <div class="docstring"><p>A non-local return from a function. Check <code>try/2</code> for more information.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1107" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="tl/1">
    <strong>tl(list)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>tl(maybe_improper_list) :: maybe_improper_list</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the tail of a list. Raises <code>ArgumentError</code> if the list is empty.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1115" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="trunc/1">
    <strong>trunc(number)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>trunc(number) :: integer</li>
      
    </ul>
  
  <div class="docstring"><p>Returns an integer by truncating the given number.
Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; trunc(5.5)
5
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1130" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="tuple_size/1">
    <strong>tuple_size(tuple)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>tuple_size({}) :: non_neg_integer</li>
      
    </ul>
  
  <div class="docstring"><p>Returns the size of a tuple.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1138" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="tuple_to_list/1">
    <strong>tuple_to_list(tuple)</strong>
  </p>
  
    <p>Specs:</p>
    <ul class="spec">
      
        <li>tuple_to_list({}) :: []</li>
      
    </ul>
  
  <div class="docstring"><p>Converts a tuple to a list.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1146" target="_blank" class="view_source">Source</a>
  
</div>

        </div>
      

      
        <div id="macros_details" class="details_list">
          <h2>Macros</h2>
          <div class="detail">
  <p class="signature" id="&amp;&amp;/2">
    <strong>left &amp;&amp; right</strong>
  </p>
  
  <div class="docstring"><p>Provides a short-circuit operator that evaluates and returns
the second expression only if the first one evaluates to true
(i.e. it is not nil nor false). Returns the first expression
otherwise.</p>

<h2>Examples</h2>

<pre><code>iex&gt; true &amp;&amp; true
true
iex&gt; nil &amp;&amp; true
nil
iex&gt; true &amp;&amp; 1
1
iex&gt; false &amp;&amp; throw(:bad)
false
</code></pre>

<p>Notice that, unlike Erlang&#39;s <code>and</code> operator,
this operator accepts any expression as an argument,
not only booleans, however it is not allowed in guards.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2950" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="../2">
    <strong>first .. last</strong>
  </p>
  
  <div class="docstring"><p>Returns a range with the specified start and end.
Includes both ends.</p>

<h2>Examples</h2>

<pre><code>iex&gt; 0 in 1..3
false
iex&gt; 1 in 1..3
true
iex&gt; 2 in 1..3
true
iex&gt; 3 in 1..3
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2925" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="&lt;&gt;/2">
    <strong>left &lt;&gt; right</strong>
  </p>
  
  <div class="docstring"><p>Concatenates two binaries.</p>

<h2>Examples</h2>

<pre><code>iex&gt; &quot;foo&quot; &lt;&gt; &quot;bar&quot;
&quot;foobar&quot;
</code></pre>

<p>The <code>&lt;&gt;</code> operator can also be used in guard clauses as
long as the first part is a literal binary:</p>

<pre><code>iex&gt; &quot;foo&quot; &lt;&gt; x = &quot;foobar&quot;
...&gt; x
&quot;bar&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2904" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="@/1">
    <strong>@expr</strong>
  </p>
  
  <div class="docstring"><p>This macro is a shortcut to read and add attributes to the module
being compiled. Elixir module attributes are similar to Erlang&#39;s with
some differences. The canonical example for attributes is annotating
that a module implements the OTP behavior called <code>gen_server</code>:</p>

<pre><code>defmodule MyServer do
  @behavior :gen_server
  # ... callbacks ...
end
</code></pre>

<p>By default Elixir supports all Erlang module attributes, but any developer
can also add custom attributes:</p>

<pre><code>defmodule MyServer do
  @my_data 13
  IO.inspect @my_data #=&gt; 13
end
</code></pre>

<p>Unlike Erlang, such attributes are not stored in the module by
default since it is common in Elixir to use such attributes to store
temporary data. A developer can configure an attribute to behave closer
to Erlang by calling <a href="Module.html#register_attribute/3"><code>Module.register_attribute/3</code></a>.</p>

<p>Finally, notice that attributes can also be read inside functions:</p>

<pre><code>defmodule MyServer do
  @my_data 11
  def first_data, do: @my_data
  @my_data 13
  def second_data, do: @my_data
end

MyServer.first_data #=&gt; 11
MyServer.second_data #=&gt; 13
</code></pre>

<p>It is important to note that reading an attribute takes a snapshot of
its current value. In other words, the value is read at compilation
time and not at runtime. Check the module <code>Module</code> for other functions
to manipulate module attributes.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2475" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="access/2">
    <strong>access(element, args)</strong>
  </p>
  
  <div class="docstring"><p>Access the given element using the qualifier according
to the <code>Access</code> protocol. All calls in the form <code>foo[bar]</code>
are translated to <code>access(foo, bar)</code>.</p>

<p>The usage of this protocol is to access a raw value in a
keyword list.</p>

<pre><code>sample = [a: 1, b: 2, c: 3]
sample[:b] #=&gt; 2
</code></pre>

<h2>Aliases</h2>

<p>Whenever invoked on an alias or an atom, the access protocol is
expanded at compilation time rather than on runtime. This feature
is used by records to allow a developer to match against an specific
part of a record:</p>

<pre><code>def increment(State[counter: counter, other: 13] = state) do
  state.counter(counter + 1)
end
</code></pre>

<p>In the example above, we use the Access protocol to match the
counter field in the record <code>State</code>. Considering the record
definition is as follows:</p>

<pre><code>defrecord State, counter: 0, other: nil
</code></pre>

<p>The clause above is translated to:</p>

<pre><code>def increment({ State, counter, 13 } = state) do
  state.counter(counter + 1)
end
</code></pre>

<p>The same pattern can be used to create a new record:</p>

<pre><code>def new_state(counter) do
  State[counter: counter]
end
</code></pre>

<p>The example above is faster than <code>State.new(counter: :counter)</code> because
the record is expanded at compilation time and not at runtime. If a field
is not specified on creation, it will have its default value.</p>

<p>Finally, as in Erlang, Elixir also allows the following syntax:</p>

<pre><code>new_uri = State[_: 1]
</code></pre>

<p>In this case <strong>all</strong> fields will be set to <code>1</code>. Notice that,
as in Erlang, in case an expression is given, it will be
evaluated multiple times:</p>

<pre><code>new_uri = State[_: IO.puts &quot;Hello&quot;]
</code></pre>

<p>In this case, <code>&quot;Hello&quot;</code> will be printed twice (one per each field).</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3267" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="and/2">
    <strong>left and right</strong>
  </p>
  
  <div class="docstring"><p>Boolean and. Requires only the first argument to be a
boolean since it short-circuits. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; true and false
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L172" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="atom_to_binary/1">
    <strong>atom_to_binary(some_atom)</strong>
  </p>
  
  <div class="docstring"><p>Returns a binary which corresponds to the text representation
of <code>some_atom</code> in UTF8 encoding.</p>

<h2>Examples</h2>

<pre><code>iex&gt; atom_to_binary(:my_atom)
&quot;my_atom&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2882" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="binary_to_atom/1">
    <strong>binary_to_atom(some_binary)</strong>
  </p>
  
  <div class="docstring"><p>Returns the atom whose text representation is <code>some_binary</code> in
UTF8 encoding.</p>

<p>Currently Elixir does not support conversions for binaries which
contains Unicode characters greater than 16#FF.</p>

<h2>Examples</h2>

<pre><code>iex&gt; binary_to_atom(&quot;my_atom&quot;)
:my_atom
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2844" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="binary_to_existing_atom/1">
    <strong>binary_to_existing_atom(some_binary)</strong>
  </p>
  
  <div class="docstring"><p>Works like <a href="#binary_to_atom/1"><code>binary_to_atom/1</code></a> but the atom must exist.</p>

<p>Currently Elixir does not support conversions for binaries which
contains Unicode characters greater than 16#FF.</p>

<h2>Examples</h2>

<pre><code>iex&gt; :my_atom
...&gt; binary_to_existing_atom(&quot;my_atom&quot;)
:my_atom

iex&gt; binary_to_existing_atom(&quot;this_atom_will_never_exist&quot;)
** (ArgumentError) argument error
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2866" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="binding/0">
    <strong>binding()</strong>
  </p>
  
  <div class="docstring"><p>Returns the binding as a keyword list where the variable name
is the key and the variable value is the value.</p>

<h2>Examples</h2>

<pre><code>iex&gt; x = 1
iex&gt; binding()
[x: 1]
iex&gt; x = 2
iex&gt; binding()
[x: 2]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2491" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="binding/1">
    <strong>binding(list)</strong>
  </p>
  
  <div class="docstring"><p>Receives a list of atoms at compilation time and returns the
binding of the given variables as a keyword list where the
variable name is the key and the variable value is the value.</p>

<p>In case a variable in the list does not exist in the binding,
it is not included in the returned result.</p>

<h2>Examples</h2>

<pre><code>iex&gt; x = 1
iex&gt; binding([:x, :y])
[x: 1]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2510" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="binding/2">
    <strong>binding(list, context)</strong>
  </p>
  
  <div class="docstring"><p>Receives a list of atoms at compilation time and returns the
binding of the given variables in the given context as a keyword
list where the variable name is the key and the variable value
is the value.</p>

<p>In case a variable in the list does not exist in the binding,
it is not included in the returned result.</p>

<h2>Examples</h2>

<pre><code>iex&gt; var!(x, :foo) = 1
iex&gt; binding([:x, :y])
[]
iex&gt; binding([:x, :y], :foo)
[x: 1]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2536" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="case/2">
    <strong>case(condition, blocks)</strong>
  </p>
  
  <div class="docstring"><p>Matches the given expression against the match clauses.</p>

<h2>Examples</h2>

<pre><code>case thing do
  { :selector, i, value } when is_integer(i) -&gt;
    value
  value -&gt; value
end
</code></pre>

<p>In the example above, we compare <code>thing</code> with each given match
clause and evaluate the expression corresponding to the first clause
that matches. If no clause matches, an error is raised.</p>

<p>Since Elixir variables can be assigned more than once, variables
in a match clause will always be assigned instead of matching with
its previous values. For example:</p>

<pre><code>i = 1
case 10 do
  i -&gt; i * 2
end
</code></pre>

<p>The example above will return 20, because <code>i</code> is assigned to 10
and then multiplied by 2. If you desire to match the value of <code>i</code>
against the given condition, you need to use the <code>^</code> operator:</p>

<pre><code>i = 1
case 10 do
  ^i -&gt; i * 2
end
</code></pre>

<p>The example above will actually fail because 10 does not match 1.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2197" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="cond/1">
    <strong>cond(list1)</strong>
  </p>
  
  <div class="docstring"><p>Evaluates the expression corresponding to the first clause that
evaluates to true. Raises an error if all conditions evaluate to
to falsy values (nil or false).</p>

<h2>Examples</h2>

<pre><code>cond do
  1 + 1 == 1 -&gt;
    &quot;This will never match&quot;
  2 * 2 != 4 -&gt;
    &quot;Nor this&quot;
  true -&gt;
    &quot;This will&quot;
end
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2624" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="def/2">
    <strong>def(name, list2)</strong>
  </p>
  
  <div class="docstring"><p>Defines a function with the given name and contents.</p>

<h2>Examples</h2>

<pre><code>defmodule Foo do
  def bar, do: :baz
end

Foo.bar #=&gt; :baz
</code></pre>

<p>A function that expects arguments can be defined as follow:</p>

<pre><code>defmodule Foo do
  def sum(a, b) do
    a + b
  end
end
</code></pre>

<p>In the example above, we defined a function <code>sum</code> that receives
two arguments and sums them.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1220" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="defdelegate/2">
    <strong>defdelegate(funs, opts)</strong>
  </p>
  
  <div class="docstring"><p>Defines the given functions in the current module that will
delegate to the given <code>target</code>. Functions defined with
<code>defdelegate</code> are public and are allowed to be invoked
from external. If you find yourself wishing to define a
delegation as private, you should likely use import
instead.</p>

<p>Delegation only works with functions, delegating to macros
is not supported.</p>

<h2>Options</h2>

<ul>
<li><p><code>:to</code> - The expression to delegate to. Any expression
is allowed and its results will be calculated on runtime;</p></li>
<li><p><code>:as</code> - The function to call on the target given in <code>:to</code>.
This parameter is optional and defaults to the name being
delegated.</p></li>
<li><p><code>:append_first</code> - If true, when delegated, first argument
passed to the delegate will be relocated to the end of the
arguments when dispatched to the target. The motivation behind
this is because Elixir normalizes the &quot;handle&quot; as a first
argument and some Erlang modules expect it as last argument.</p></li>
</ul>

<h2>Examples</h2>

<pre><code>defmodule MyList do
  defdelegate reverse(list), to: :lists
  defdelegate [reverse(list), map(callback, list)], to: :lists
  defdelegate other_reverse(list), to: :lists, as: :reverse
end

MyList.reverse([1, 2, 3])
#=&gt; [3,2,1]

MyList.other_reverse([1, 2, 3])
#=&gt; [3,2,1]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3347" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="defexception/3">
    <strong>defexception(name, fields, do_block // [])</strong>
  </p>
  
  <div class="docstring"><p>Defines an exception.</p>

<p>Exceptions are simply records and therefore <a href="#defexception/3"><code>defexception/3</code></a> has
the same API and similar behavior to <a href="#defrecord/3"><code>defrecord/3</code></a> with two notable
differences:</p>

<p>1) Unlike records, exceptions are documented by default;</p>

<p>2) Exceptions <strong>must</strong> implement <code>message/1</code> -- a function that returns a
   string;</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1488" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="defimpl/3">
    <strong>defimpl(name, opts, do_block // [])</strong>
  </p>
  
  <div class="docstring"><p>Defines an implementation for the given protocol. See
<a href="#defprotocol/2"><code>defprotocol/2</code></a> for examples.</p>

<p>Inside an implementation, the name of the protocol can be accessed
via <code>@protocol</code> and the current target as <code>@for</code>.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1834" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="defmacro/2">
    <strong>defmacro(name, list2)</strong>
  </p>
  
  <div class="docstring"><p>Defines a macro with the given name and contents.</p>

<h2>Examples</h2>

<pre><code>defmodule MyLogic do
  defmacro unless(expr, opts) do
    quote do
      if !unquote(expr), unquote(opts)
    end
  end
end

require MyLogic
MyLogic.unless false do
  IO.puts &quot;It works&quot;
end
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1268" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="defmacrop/2">
    <strong>defmacrop(name, list2)</strong>
  </p>
  
  <div class="docstring"><p>Defines a macro that is private. Private macros are
only accessible from the same module in which they are defined.</p>

<p>Check <a href="#defmacro/2"><code>defmacro/2</code></a> for more information</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1279" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="defmodule/2">
    <strong>defmodule(name, list2)</strong>
  </p>
  
  <div class="docstring"><p>Defines a module given by name with the given contents.</p>

<p>It returns the module name, the module binary and the
block contents result.</p>

<h2>Examples</h2>

<pre><code>defmodule Foo do
  def bar, do: :baz
end

Foo.bar #=&gt; :baz
</code></pre>

<h2>Nesting</h2>

<p>Nesting a module inside another module affects its name:</p>

<pre><code>defmodule Foo do
  defmodule Bar do
  end
end
</code></pre>

<p>In the example above, two modules <code>Foo</code> and <code>Foo.Bar</code> are created.
When nesting, Elixir automatically creates an alias, allowing the
second module <code>Foo.Bar</code> to be accessed as <code>Bar</code> in the same lexical
scope.</p>

<p>This means that, if the module <code>Bar</code> is moved to another file,
the references to <code>Bar</code> needs to be updated or an alias needs to
be explicitly set with the help of <a href="Kernel.SpecialForms.html#alias/2"><code>Kernel.SpecialForms.alias/2</code></a>.</p>

<h2>Dynamic names</h2>

<p>Elixir module names can be dynamically generated. This is very
useful for macros. For instance, one could write:</p>

<pre><code>defmodule binary_to_atom(&quot;Foo#{1}&quot;) do
  # contents ...
end
</code></pre>

<p>Elixir will accept any module name as long as the expression
returns an atom. Note that, when a dynamic name is used, an
alias is not automatically created, even when nested.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1195" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="defoverridable/1">
    <strong>defoverridable(tuples)</strong>
  </p>
  
  <div class="docstring"><p>Makes the given functions in the current module overridable. An overridable
function is lazily defined, allowing a developer to customize it.</p>

<h2>Example</h2>

<pre><code>defmodule DefaultMod do
  defmacro __using__(_opts) do
    quote do
      def test(x, y) do
        x + y
      end

      defoverridable [test: 2]
    end
  end
end

defmodule InheritMod do
  use DefaultMod

  def test(x, y) do
    x * y + super(x, y)
  end
end
</code></pre>

<p>As seen as in the example <code>super</code> can be used to call the default
implementation.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1869" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="defp/2">
    <strong>defp(name, list2)</strong>
  </p>
  
  <div class="docstring"><p>Defines a function that is private. Private functions are
only accessible from within the module in which they are defined.</p>

<p>Check <a href="#def/2"><code>def/2</code></a> for more information</p>

<h2>Examples</h2>

<pre><code>defmodule Foo do
  def bar do
    sum(1, 2)
  end

  defp sum(a, b), do: a + b
end
</code></pre>

<p>In the example above, <code>sum</code> is private and accessing it
through <code>Foo.sum</code> will raise an error.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1244" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="defprotocol/2">
    <strong>defprotocol(name, list2)</strong>
  </p>
  
  <div class="docstring"><p>Defines a module as a protocol and specifies the API that
should be defined by its implementations.</p>

<h2>Examples</h2>

<p>In Elixir, only <code>false</code> and <code>nil</code> are considered falsy values.
Everything else evaluates to true in <code>if</code> clauses. Depending
on the application, it may be important to specify a <code>blank?</code>
protocol that returns a boolean for other data types that should
be considered <code>blank?</code>. For instance, an empty list or an empty
binary could be considered blanks.</p>

<p>We could implement this protocol as follow:</p>

<pre><code>defprotocol Blank do
  @doc &quot;Returns true if data is considered blank/empty&quot;
  def blank?(data)
end
</code></pre>

<p>Now that the protocol is defined, we can implement it. We need
to implement the protocol for each Elixir type. For example:</p>

<pre><code># Integers are never blank
defimpl Blank, for: Integer do
  def blank?(number), do: false
end

# Just empty list is blank
defimpl Blank, for: List do
  def blank?([]), do: true
  def blank?(_),  do: false
end

# Just the atoms false and nil are blank
defimpl Blank, for: Atom do
  def blank?(false), do: true
  def blank?(nil),   do: true
  def blank?(_),     do: false
end
</code></pre>

<p>And we would have to define the implementation for all types.
The supported types available are:</p>

<ul>
<li>Record (see below)</li>
<li>Tuple</li>
<li>Atom</li>
<li>List</li>
<li>BitString</li>
<li>Integer</li>
<li>Float</li>
<li>Function</li>
<li>PID</li>
<li>Port</li>
<li>Reference</li>
<li>Any (see below)</li>
</ul>

<h2>Protocols + Records</h2>

<p>The real benefit of protocols comes when mixed with records.
For instance, Elixir ships with many data types implemented as
records, like <code>HashDict</code> and <code>HashSet</code>. We can implement the
<code>Blank</code> protocol for those types as well:</p>

<pre><code>defimpl Blank, for: HashDict do
  def blank?(dict), do: Dict.empty?(dict)
end
</code></pre>

<p>Since records are tuples, if a protocol is not found a given
type, it will fallback to <code>Tuple</code>.</p>

<h2>Fallback to any</h2>

<p>In some cases, it may be convenient to provide a default
implementation for all types. This can be achieved by
setting <code>@fallback_to_any</code> to <code>true</code> in the protocol
definition:</p>

<pre><code>defprotocol Blank do
  @fallback_to_any true
  def blank?(data)
end
</code></pre>

<p>Which can now be implemented as:</p>

<pre><code>defimpl Blank, for: Any do
  def blank?(_), do: true
end
</code></pre>

<p>One may wonder why such fallback is not true by default.</p>

<p>It is two-fold: first, the majority of protocols cannot
implement an action in a generic way for all types. In fact,
providing a default implementation may be harmful, because users
may rely on the default implementation instead of providing a
specialized one.</p>

<p>Second, falling back to <code>Any</code> adds an extra lookup to all types,
which is unecessary overhead unless an implementation for Any is
required.</p>

<h2>Types</h2>

<p>As in records, defining a protocol automatically defines a type
named <code>t</code>, which can be used as:</p>

<pre><code>@spec present?(Blank.t) :: boolean
def present?(blank) do
  not Blank.blank?(blank)
end
</code></pre>

<p>The <code>@spec</code> above expresses that all types allowed to implement the
given protocol are valid argument types for the given function.</p>

<h2>Reflection</h2>

<p>Any protocol module contains three extra functions:</p>

<ul>
<li><p><code>__protocol__/1</code> - returns the protocol name when :name is given,
                 and a keyword list with the protocol functions
                 when :functions is given;</p></li>
<li><p><code>impl_for/1</code> - receives a structure and returns the module that implements
             the protocol for the structure, nil otherwise;</p></li>
<li><p><code>impl_for!/1</code> - same as above but raises an error if an implementation is not found</p></li>
</ul>

<h2>Consolidation</h2>

<p>In order to cope with code loading in development, protocols in
Elixir provide a slow implementation of protocol dispatching in
development.</p>

<p>In order to speed up dispatching in production environments, where
all implementations are now up-front, Elixir provides a feature
called protocol consolidation. For this reason, all protocols are
compiled with <code>debug_info</code> set to true, regardless of the option
set by <code>elixirc</code> compiler.</p>

<p>For more information on how to apply protocol consolidation to
a given project, please check the <code>mix compile.protocols</code> task.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1823" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="defrecord/3">
    <strong>defrecord(name, fields, do_block // [])</strong>
  </p>
  
  <div class="docstring"><p>Exports a module with a record definition and runtime operations.</p>

<p>Please see the <code>Record</code> module&#39;s documentation for an introduction
to records in Elixir. The following sections are going into details
specific to <code>defrecord</code>.</p>

<h2>Examples</h2>

<pre><code>defrecord User, name: nil, age: 0
</code></pre>

<p>The following line defines a module that exports information
about a record. The definition above provides a shortcut
syntax for creating and updating the record at compilation
time:</p>

<pre><code>user = User[]
#=&gt; User[name: nil, age: 0]

User[name: &quot;Jos&quot;, age: 25]
#=&gt; User[name: &quot;Jos&quot;, age: 25]
</code></pre>

<p>And also a set of functions for working with the record
at runtime:</p>

<pre><code>user = User.new(age: 25)
user.name          #=&gt; Returns the value of name
user.name(&quot;Jos&quot;)  #=&gt; Updates the value of name

# Update multiple attributes at once:
user.update(name: &quot;Other&quot;, age: 25)

# Obtain the keywords representation of a record:
user.to_keywords #=&gt; [name: &quot;Jos&quot;, age: 25]
</code></pre>

<p>Since a record is simply a tuple where the first element is
the record name, we can get the raw record representation as
follows:</p>

<pre><code>inspect User.new, raw: true
#=&gt; { User, nil, 0 }
</code></pre>

<p>In addition to defining readers and writers for each attribute, Elixir also
defines an <code>update_#{attribute}</code> function to update the value. Such
functions expect a function as an argument that receives the current
value and must return the new one. For example, every time the file
is accessed, the accesses counter can be incremented with:</p>

<pre><code>user.update_age(fn(old) -&gt; old + 1 end)
</code></pre>

<h2>Types</h2>

<p>Every record defines a type named <code>t</code> that can be accessed in typespecs.
Those types can be specified inside the record definition:</p>

<pre><code>defrecord User do
  record_type name: string, age: integer
end
</code></pre>

<p>All fields without a specified type are assumed to have type <code>term</code>.</p>

<p>Assuming the <code>User</code> record defined above, it could be used in typespecs
as follow:</p>

<pre><code>@spec handle_user(User.t) :: boolean()
</code></pre>

<h2>Runtime introspection</h2>

<p>At runtime, developers can use <code>__record__</code> to get information
about the given record:</p>

<pre><code>User.__record__(:name)
#=&gt; User

User.__record__(:fields)
#=&gt; [name: nil, age: 0]
</code></pre>

<p>In order to quickly access the index of a field, one can use
the <code>__record__</code> function with <code>:index</code> as the first argument:</p>

<pre><code>User.__record__(:index, :age)
#=&gt; 2

User.__record__(:index, :unknown)
#=&gt; nil
</code></pre>

<h2>Compile-time introspection</h2>

<p>At compile time, one can access the following information about the record
from within the record module:</p>

<ul>
<li><code>@record_fields</code>  a keyword list of record fields with defaults</li>
<li><code>@record_types</code>  a keyword list of record fields with types</li>
</ul>

<p>For example:</p>

<pre><code>defrecord Foo, bar: nil do
  record_type bar: nil | integer
  IO.inspect @record_fields
  IO.inspect @record_types
end
</code></pre>

<p>Prints out:</p>

<pre><code> [bar: nil]
 [bar: {:|,[line: ...],[nil,{:integer,[line: ...],nil}]}]
</code></pre>

<p>Where the last line is a quoted representation of</p>

<pre><code> [bar: nil | integer]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1396" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="defrecordp/3">
    <strong>defrecordp(name, tag // nil, fields)</strong>
  </p>
  
  <div class="docstring"><p>Defines a set of private macros to manipulate a record definition.</p>

<p>This macro defines a set of macros private to the current module to
manipulate the record exclusively at compilation time.</p>

<p>Please see the <code>Record</code> module&#39;s documentation for an introduction
to records in Elixir.</p>

<h2>Examples</h2>

<pre><code>defmodule User do
  defrecordp :user, [name: &quot;Jos&quot;, age: &quot;25&quot;]
end
</code></pre>

<p>In the example above, a set of macros named <code>user</code> but with different
arities will be defined to manipulate the underlying record:</p>

<pre><code># To create records
user()        #=&gt; { :user, &quot;Jos&quot;, 25 }
user(age: 26) #=&gt; { :user, &quot;Jos&quot;, 26 }

# To get a field from the record
user(record, :name) #=&gt; &quot;Jos&quot;

# To get many fields from the record
user(record, [:name, :age]) #=&gt; [&quot;Jos&quot;, 25]

# To update the record
user(record, age: 26) #=&gt; { :user, &quot;Jos&quot;, 26 }

# To convert the record to keywords
user(record) #=&gt; [name: &quot;Jos&quot;, age: 25]

# To match against the record
user(name: name) = record
name #=&gt; &quot;Jos&quot;
</code></pre>

<p>By default, Elixir uses the record name as the first element of the tuple.
In some cases though, this might be undesirable and one can explicitly
define what the first element of the record should be:</p>

<pre><code>defmodule MyServer do
  defrecordp :state, MyServer, data: nil
end
</code></pre>

<p>This way, the record created will have <code>MyServer</code> as the first element,
not <code>:state</code>:</p>

<pre><code>state() #=&gt; { MyServer, nil }
</code></pre>

<h2>Types</h2>

<p><code>defrecordp</code> allows a developer to generate a type
automatically by simply providing a type to its fields.
The following definition:</p>

<pre><code>defrecordp :user,
  name: &quot;Jos&quot; :: binary,
  age: 25 :: integer
</code></pre>

<p>Will generate the following type:</p>

<pre><code>@typep user_t :: { :user, binary, integer }
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1471" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="destructure/2">
    <strong>destructure(left, right)</strong>
  </p>
  
  <div class="docstring"><p>Allows you to destructure two lists, assigning each term in the right to the
matching term in the left. Unlike pattern matching via <code>=</code>, if the sizes of
the left and right lists don&#39;t match, destructuring simply stops instead of
raising an error.</p>

<h2>Examples</h2>

<pre><code>iex&gt; destructure([x, y, z], [1, 2, 3, 4, 5])
...&gt; {x, y, z}
{1, 2, 3}
</code></pre>

<p>Notice in the example above, even though the right
size has more entries than the left, destructuring works
fine. If the right size is smaller, the remaining items
are simply assigned to nil:</p>

<pre><code>iex&gt; destructure([x, y, z], [1])
...&gt; {x, y, z}
{1, nil, nil}
</code></pre>

<p>The left side supports any expression you would use
on the left side of a match:</p>

<pre><code>x = 1
destructure([^x, y, z], [1, 2, 3])
</code></pre>

<p>The example above will only work if x matches
the first value from the right side. Otherwise,
it will raise a CaseClauseError.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2698" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="div/2">
    <strong>div(left, right)</strong>
  </p>
  
  <div class="docstring"><p>Provides an integer division macro according to Erlang semantics.
Raises an error if one of the arguments is not an integer.
Can be used in guard tests.</p>

<h2>Examples</h2>

<pre><code>iex&gt; div(5, 2)
2
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2030" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="elem/2">
    <strong>elem(tuple, index)</strong>
  </p>
  
  <div class="docstring"><p>Get the element at the zero-based <code>index</code> in <code>tuple</code>.</p>

<p>Implemented as a macro so it can be used in guards.</p>

<h2>Example</h2>

<pre><code>iex&gt; tuple = { :foo, :bar, 3 }
...&gt; elem(tuple, 1)
:bar
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1532" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="if/2">
    <strong>if(condition, clauses)</strong>
  </p>
  
  <div class="docstring"><p>Provides an <code>if</code> macro. This macro expects the first argument to
be a condition and the rest are keyword arguments.</p>

<h2>One-liner examples</h2>

<pre><code>if(foo, do: bar)
</code></pre>

<p>In the example above, <code>bar</code> will be returned if <code>foo</code> evaluates to
<code>true</code> (i.e. it is neither <code>false</code> nor <code>nil</code>). Otherwise, <code>nil</code> will be returned.</p>

<p>An <code>else</code> option can be given to specify the opposite:</p>

<pre><code>if(foo, do: bar, else: baz)
</code></pre>

<h2>Blocks examples</h2>

<p>Elixir also allows you to pass a block to the <code>if</code> macro. The first
example above would be translated to:</p>

<pre><code>if foo do
  bar
end
</code></pre>

<p>Notice that <code>do/end</code> becomes delimiters. The second example would
then translate to:</p>

<pre><code>if foo do
  bar
else
  baz
end
</code></pre>

<p>If you want to compare more than two clauses, you can use the <a href="#cond/1"><code>cond/1</code></a>
macro.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2596" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="in/2">
    <strong>left in right</strong>
  </p>
  
  <div class="docstring"><p>Returns <code>true</code> if the element on the left is equal (==) to
any of the items on the right.</p>

<h2>Examples</h2>

<pre><code>iex&gt; x = 1
...&gt; x in [1, 2, 3]
true
</code></pre>

<p>This macro simply translates the expression above to:</p>

<pre><code>x == 1 or x == 2 or x == 3
</code></pre>

<p>with the exception that the expression on the left of <code>in</code>
is evaluated only once.</p>

<h2>Clauses</h2>

<p>Whenever used inside a function or a case clause, you can
optionally omit the variable declaration, for example:</p>

<pre><code>case 3 do
  x when x in [1, 2] -&gt; x * 2
  _ -&gt; 0
end
</code></pre>

<p>Could be rewritten as:</p>

<pre><code>case 3 do
  x in [1, 2] -&gt; x * 2
  _ -&gt; 0
end
</code></pre>

<p>In this case, Elixir will automatically expand it and define
the variable for us.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3029" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_exception/1">
    <strong>is_exception(thing)</strong>
  </p>
  
  <div class="docstring"><p>Checks if the given structure is an exception.</p>

<h2>Examples</h2>

<pre><code>iex&gt; is_exception((fn -&gt; ArithmeticError.new end).())
true
iex&gt; is_exception((fn -&gt; 1 end).())
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1569" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_range/1">
    <strong>is_range(thing)</strong>
  </p>
  
  <div class="docstring"><p>Checks if the given argument is a range.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1645" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_record/1">
    <strong>is_record(thing)</strong>
  </p>
  
  <div class="docstring"><p>Checks if the given argument is a record.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1617" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_record/2">
    <strong>is_record(thing, kind)</strong>
  </p>
  
  <div class="docstring"><p>Checks if the given structure is a record. It is basically
a convenient macro that checks the structure is a tuple and
the first element matches the given kind.</p>

<h2>Examples</h2>

<pre><code>defrecord Config, sample: nil

is_record(Config.new, Config) #=&gt; true
is_record(Config.new, List)   #=&gt; false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1598" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="is_regex/1">
    <strong>is_regex(thing)</strong>
  </p>
  
  <div class="docstring"><p>Checks if the given argument is a regex.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1636" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="match?/2">
    <strong>match?(pattern, expr)</strong>
  </p>
  
  <div class="docstring"><p>A convenient macro that checks if the right side matches
the left side. The left side is allowed to be a match pattern.</p>

<h2>Examples</h2>

<pre><code>iex&gt; match?(1, 1)
true
iex&gt; match?(1, 2)
false
iex&gt; match?({1, _}, {1, 2})
true
</code></pre>

<p>Match can also be used to filter or find a value in an enumerable:</p>

<pre><code>list = [{:a, 1}, {:b, 2}, {:a, 3}]
Enum.filter list, &amp;match?({:a, _}, &amp;1)
</code></pre>

<p>Guard clauses can also be given to the match:</p>

<pre><code>list = [{:a, 1}, {:b, 2}, {:a, 3}]
Enum.filter list, &amp;match?({:a, x } when x &lt; 2, &amp;1)
</code></pre>

<p>However, variables assigned in the match will not be available
outside of the function call:</p>

<pre><code>iex&gt; match?(x, 1)
true
iex&gt; binding([:x]) == []
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2097" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="nil?/1">
    <strong>nil?(x)</strong>
  </p>
  
  <div class="docstring"><p>Checks if the given argument is nil or not.
Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; nil?(1)
false
iex&gt; nil?(nil)
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2061" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="or/2">
    <strong>left or right</strong>
  </p>
  
  <div class="docstring"><p>Boolean or. Requires only the first argument to be a
boolean since it short-circuits. Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; true or false
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L160" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="raise/1">
    <strong>raise(msg)</strong>
  </p>
  
  <div class="docstring"><p>Raises an error.</p>

<p>If the argument is a binary, it raises <code>RuntimeError</code>
using the given argument as message.</p>

<p>If anything else, becomes a call to <code>raise(argument, [])</code>.</p>

<h2>Examples</h2>

<pre><code>raise &quot;Given values do not match&quot;

try do
  1 + :foo
rescue
  x in [ArithmeticError] -&gt;
    IO.puts &quot;that was expected&quot;
    raise x
end
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3088" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="raise/2">
    <strong>raise(exception, args // [])</strong>
  </p>
  
  <div class="docstring"><p>Raises an error.</p>

<p>It calls <code>.exception</code> on the given argument passing
the args in order to retrieve the appropriate exception
structure.</p>

<p>Any module defined via <code>defexception</code> automatically
defines both <code>exception(args)</code> and <code>exception(args, current)</code>
that creates a new and updates the given exception.</p>

<h2>Examples</h2>

<pre><code>iex&gt; raise(ArgumentError, message: &quot;Sample&quot;)
** (ArgumentError) Sample
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3118" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="receive/1">
    <strong>receive(args)</strong>
  </p>
  
  <div class="docstring"><p>The current process will hang until it receives a message
from other processes that matches the given clauses.</p>

<h2>Examples</h2>

<pre><code>receive do
  { :selector, i, value } when is_integer(i) -&gt;
    value
  value when is_atom(value) -&gt;
    value
  _ -&gt;
    IO.puts :stderr, &quot;Unexpected message received&quot;
end
</code></pre>

<p>The match clauses above follows the same rules as <a href="#case/2"><code>case/2</code></a>.</p>

<p>An optional after clause can be given in case the message was not
received after the specified period of time:</p>

<pre><code>receive do
  { :selector, i, value } when is_integer(i) -&gt;
    value
  value when is_atom(value) -&gt;
    value
  _ -&gt;
    IO.puts :stderr, &quot;Unexpected message received&quot;
after
  5000 -&gt;
    IO.puts :stderr, &quot;No message in 5 seconds&quot;
end
</code></pre>

<p>The <code>after</code> clause can be specified even if there are no match clauses.
There are two special cases for the timout value given to after</p>

<ul>
<li><p><code>:infinity</code> - The process should wait indefinitely for a matching
message, this is the same as not using a timeout.</p></li>
<li><p>0 - if there is no matching message in the mailbox, the timeout
will occur immediately.</p></li>
</ul>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2432" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="rem/2">
    <strong>rem(left, right)</strong>
  </p>
  
  <div class="docstring"><p>Provides an integer remainder macro according to Erlang semantics.
Raises an error if one of the arguments is not an integer.
Can be used in guard tests.</p>

<h2>Examples</h2>

<pre><code>iex&gt; rem(5, 2)
1
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2045" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="set_elem/3">
    <strong>set_elem(tuple, index, value)</strong>
  </p>
  
  <div class="docstring"><p>Sets the element in <code>tuple</code> at the zero-based <code>index</code> to the given <code>value</code>.</p>

<h2>Example</h2>

<pre><code>iex&gt; tuple = { :foo, :bar, 3 }
...&gt; set_elem(tuple, 0, :baz)
{ :baz, :bar, 3 }
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1550" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="sigil_C/2">
    <strong>sigil_C(arg1, list2)</strong>
  </p>
  
  <div class="docstring"><p>Handles the sigil %C. It simply returns a char list
without escaping characters and without interpolations.</p>

<h2>Examples</h2>

<pre><code>iex&gt; %C(foo)
&#39;foo&#39;
iex&gt; %C(f#{o}o)
&#39;f\#{o}o&#39;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3420" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="sigil_R/2">
    <strong>sigil_R(arg1, options)</strong>
  </p>
  
  <div class="docstring"><p>Handles the sigil %R. It returns a Regex pattern without escaping
nor interpreting interpolations.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Regex.match?(%R(f#{1,3}o), &quot;f#o&quot;)
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3478" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="sigil_S/2">
    <strong>sigil_S(string, list2)</strong>
  </p>
  
  <div class="docstring"><p>Handles the sigil %S. It simples returns a string
without escaping characters and without interpolations.</p>

<h2>Examples</h2>

<pre><code>iex&gt; %S(foo)
&quot;foo&quot;
iex&gt; %S(f#{o}o)
&quot;f\#{o}o&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3388" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="sigil_W/2">
    <strong>sigil_W(arg1, modifiers)</strong>
  </p>
  
  <div class="docstring"><p>Handles the sigil %W. It returns a list of &quot;words&quot; split by whitespace
without escaping nor interpreting interpolations.</p>

<h2>Modifiers</h2>

<ul>
<li><code>b</code>: binaries (default)</li>
<li><code>a</code>: atoms</li>
<li><code>c</code>: char lists</li>
</ul>

<h2>Examples</h2>

<pre><code>iex&gt; %W(foo #{bar} baz)
[&quot;foo&quot;, &quot;\#{bar}&quot;, &quot;baz&quot;]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3528" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="sigil_c/2">
    <strong>sigil_c(arg1, list2)</strong>
  </p>
  
  <div class="docstring"><p>Handles the sigil %c. It returns a char list as if it was a single
quoted string, unescaping characters and replacing interpolations.</p>

<h2>Examples</h2>

<pre><code>iex&gt; %c(foo)
&#39;foo&#39;
iex&gt; %c(f#{:o}o)
&#39;foo&#39;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3439" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="sigil_r/2">
    <strong>sigil_r(arg1, options)</strong>
  </p>
  
  <div class="docstring"><p>Handles the sigil %r. It returns a Regex pattern.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Regex.match?(%r(foo), &quot;foo&quot;)
true
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3457" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="sigil_s/2">
    <strong>sigil_s(arg1, list2)</strong>
  </p>
  
  <div class="docstring"><p>Handles the sigil %s. It returns a string as if it was double quoted
string, unescaping characters and replacing interpolations.</p>

<h2>Examples</h2>

<pre><code>iex&gt; %s(foo)
&quot;foo&quot;
iex&gt; %s(f#{:o}o)
&quot;foo&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3404" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="sigil_w/2">
    <strong>sigil_w(arg1, modifiers)</strong>
  </p>
  
  <div class="docstring"><p>Handles the sigil %w. It returns a list of &quot;words&quot; split by whitespace.</p>

<h2>Modifiers</h2>

<ul>
<li><code>b</code>: binaries (default)</li>
<li><code>a</code>: atoms</li>
<li><code>c</code>: char lists</li>
</ul>

<h2>Examples</h2>

<pre><code>iex&gt; %w(foo #{:bar} baz)
[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]
iex&gt; %w(--source test/enum_test.exs)
[&quot;--source&quot;, &quot;test/enum_test.exs&quot;]
iex&gt; %w(foo bar baz)a
[:foo, :bar, :baz]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3503" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="to_char_list/1">
    <strong>to_char_list(arg)</strong>
  </p>
  
  <div class="docstring"><p>Convert the argument to a list according to the List.Chars protocol.</p>

<h2>Examples</h2>

<pre><code>iex&gt; to_char_list(:foo)
&#39;foo&#39;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2015" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="to_string/1">
    <strong>to_string(arg)</strong>
  </p>
  
  <div class="docstring"><p>Converts the argument to a string according to the String.Chars protocol.
This is the function invoked when there is string interpolation.</p>

<h2>Examples</h2>

<pre><code>iex&gt; to_string(:foo)
&quot;foo&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2000" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="try/1">
    <strong>try(args)</strong>
  </p>
  
  <div class="docstring"><p>Evaluate the given expressions and catch any error, exit
or throw that may have happened.</p>

<h2>Examples</h2>

<pre><code>try do
  do_something_that_may_fail(some_arg)
rescue
  ArgumentError -&gt;
    IO.puts &quot;Invalid argument given&quot;
catch
  value -&gt;
    IO.puts &quot;caught #{value}&quot;
else
  value -&gt;
    IO.puts &quot;Success! The result was #{value}&quot;
after
  IO.puts &quot;This is printed regardless if it failed or succeed&quot;
end
</code></pre>

<p>The rescue clause is used to handle exceptions, while the catch
clause can be used to catch thrown values. The else clause can
be used to control flow based on the result of the expression.
Catch, rescue and else clauses work based on pattern matching.</p>

<p>Note that calls inside <code>try</code> are not tail recursive since the VM
needs to keep the stacktrace in case an exception happens.</p>

<h2>Rescue clauses</h2>

<p>Besides relying on pattern matching, rescue clauses provides some
conveniences around exceptions that allows one to rescue an
exception by its name. All the following formats are valid rescue
expressions:</p>

<pre><code>try do
  UndefinedModule.undefined_function
rescue
  UndefinedFunctionError -&gt; nil
end

try do
  UndefinedModule.undefined_function
rescue
  [UndefinedFunctionError] -&gt; nil
end

# rescue and assign to x
try do
  UndefinedModule.undefined_function
rescue
  x in [UndefinedFunctionError] -&gt; nil
end

# rescue all and assign to x
try do
  UndefinedModule.undefined_function
rescue
  x -&gt; nil
end
</code></pre>

<h2>Catching exits and Erlang errors</h2>

<p>The catch clause works exactly the same as in erlang. Therefore,
one can also handle exits/errors coming from Erlang as below:</p>

<pre><code>try do
  exit(1)
catch
  :exit, 1 -&gt; IO.puts &quot;Exited with 1&quot;
end

try do
  error(:sample)
catch
  :error, :sample -&gt;
    IO.puts &quot;sample error&quot;
end
</code></pre>

<p>Although the second form should be avoided in favor of raise/rescue
control mechanisms.</p>

<h2>Else clauses</h2>

<p>Else clauses allow the result of the expression to be pattern
matched on:</p>

<pre><code>x = 2
try do
  1 / x
rescue
  ArithmeticError -&gt;
    :infinity
else
  y when y &lt; 1 and y &gt; -1 -&gt;
    :small
  _ -&gt;
    :large
end
</code></pre>

<p>If an else clause is not present the result of the expression will
be return, if no exceptions are raised:</p>

<pre><code>x = 1
^x =
  try do
    1 / x
  rescue
    ArithmeticError -&gt;
      :infinity
  end
</code></pre>

<p>However when an else clause is present but the result of the expression
does not match any of the patterns an exception will be raised. This
exception will not be caught by a catch or rescue in the same try:</p>

<pre><code>x = 1
try do
  try do
    1 / x
  rescue
    # The TryClauseError can not be rescued here:
    TryClauseError -&gt;
      :error_a
  else
    0 -&gt;
      :small
  end
rescue
  # The TryClauseError is rescued here:
  TryClauseError -&gt;
    :error_b
end
</code></pre>

<p>Similarly an exception inside an else clause is not caught or rescued
inside the same try:</p>

<pre><code>try do
  try do
    nil
  catch
    # The exit(1) call below can not be caught here:
    :exit, _ -&gt;
      :exit_a
  else
    _ -&gt;
      exit(1)
  end
catch
  # The exit is caught here:
  :exit, _ -&gt;
    :exit_b
end
</code></pre>

<p>This means the VM nolonger needs to keep the stacktrace once inside
an else clause and so tail recursion is possible when using a <code>try</code>
with a tail call as the final call inside an else clause. The same
is true for rescue and catch clauses.</p>

<h2>Variable visibility</h2>

<p>Since an expression inside <code>try</code> may not have been evaluated
due to an exception, any variable created inside <code>try</code> cannot
be accessed externaly. For instance:</p>

<pre><code>try do
  x = 1
  do_something_that_may_fail(same_arg)
  :ok
catch
  _, _ -&gt; :failed
end

x #=&gt; Cannot access `x`
</code></pre>

<p>In the example above, <code>x</code> cannot be accessed since it was defined
inside the <code>try</code> clause. A common practice to address this issue
is to return the variables defined inside <code>try</code>:</p>

<pre><code>x =
  try do
    x = 1
    do_something_that_may_fail(same_arg)
    x
  catch
    _, _ -&gt; :failed
  end
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2389" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="unless/2">
    <strong>unless(clause, options)</strong>
  </p>
  
  <div class="docstring"><p>Evaluates and returns the do-block passed in as a second argument
unless clause evaluates to true.
Returns nil otherwise.
See also <code>if</code>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; unless(1, do: &quot;Hello&quot;)
nil
iex&gt; unless(false, do: &quot;Hello&quot;)
&quot;Hello&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2659" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="use/2">
    <strong>use(module, args // [])</strong>
  </p>
  
  <div class="docstring"><p><code>use</code> is a simple mechanism for using a given module into
the current context.</p>

<h2>Examples</h2>

<p>For example, in order to write tests using the ExUnit framework,
a developer should use the <code>ExUnit.Case</code> module:</p>

<pre><code>defmodule AssertionTest do
  use ExUnit.Case, async: true

  def test_always_pass do
    true = true
  end
end
</code></pre>

<p>By calling <code>use</code>, a hook called <code>__using__</code> will be invoked in
<code>ExUnit.Case</code> which will then do the proper setup.</p>

<p>Simply put, <code>use</code> is simply a translation to:</p>

<pre><code>defmodule AssertionTest do
  require ExUnit.Case
  ExUnit.Case.__using__([async: true])

  def test_always_pass do
    true = true
  end
end
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L1907" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="xor/2">
    <strong>left xor right</strong>
  </p>
  
  <div class="docstring"><p>Boolean exclusive-or. Arguments must be booleans.
Returns <code>true</code> if and only if both arguments are different.
Allowed in guard clauses.</p>

<h2>Examples</h2>

<pre><code>iex&gt; true xor false
true
iex&gt; true xor true
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L187" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="|&gt;/2">
    <strong>left |&gt; right</strong>
  </p>
  
  <div class="docstring"><p><code>|&gt;</code> is called the pipeline operator as it is useful
to write pipeline style expressions. This operator
introduces the expression on the left as the first
argument to the function call on the right.</p>

<h2>Examples</h2>

<pre><code>iex&gt; [1, [2], 3] |&gt; List.flatten |&gt; Enum.map(&amp;(&amp;1 * 2))
[2,4,6]
</code></pre>

<p>The expression above is simply translated to:</p>

<pre><code>Enum.map(List.flatten([1, [2], 3]), &amp;(&amp;1 * 2))
</code></pre>

<p>Be aware of operator precendence when using this operator.
For example, the following expression:</p>

<pre><code>String.graphemes &quot;Hello&quot; |&gt; Enum.reverse
</code></pre>

<p>Is translated to:</p>

<pre><code>String.graphemes(&quot;Hello&quot; |&gt; Enum.reverse)
</code></pre>

<p>Which will result in an error as Enumerable protocol
is not defined for binaries. Adding explicit parenthesis
resolves the ambiguity:</p>

<pre><code>String.graphemes(&quot;Hello&quot;) |&gt; Enum.reverse
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L3062" target="_blank" class="view_source">Source</a>
  
</div>
<div class="detail">
  <p class="signature" id="||/2">
    <strong>left || right</strong>
  </p>
  
  <div class="docstring"><p>Provides a short-circuit operator that evaluates and returns the second
expression only if the first one does not evaluate to true (i.e. it
is either nil or false). Returns the first expression otherwise.</p>

<h2>Examples</h2>

<pre><code>iex&gt; false || false
false
iex&gt; nil || true
true
iex&gt; false || 1
1
iex&gt; true || throw(:bad)
true
</code></pre>

<p>Notice that, unlike Erlang&#39;s <code>or</code> operator,
this operator accepts any expression as an argument,
not only booleans, however it is not allowed in guards.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/v0.11.1/lib/elixir/lib/kernel.ex#L2981" target="_blank" class="view_source">Source</a>
  
</div>

        </div>
      

      
    </div>
  </body>
</html>
