<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Basic types - Elixir</title>
  <link href="http://feeds.feedburner.com/ElixirLang" rel="alternate" title="Elixir's Blog" type="application/atom+xml" />
  <link rel="stylesheet" type="text/css" href="/css/style.css" />
  <link rel="stylesheet" type="text/css" href="/css/syntax.css" />
  <link rel="stylesheet" href="/js/icons/style.css">
  <!--[if lt IE 8]><!-->
  <link rel="stylesheet" href="/js/icons/ie7/ie7.css">
  <!--<![endif]-->
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" id="font-bitter-css" href="//fonts.googleapis.com/css?family=Bitter:400,700" type="text/css" media="screen" />
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="search" type="application/opensearchdescription+xml" title="elixir-lang.org" href="/opensearch.xml" />
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-8268430-6', 'auto');
  ga('send', 'pageview');
  </script>
  <!-- Begin Jekyll SEO tag v2.2.3 -->
<meta property="og:title" content="Basic types" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://elixir-lang.org/ja/getting-started/basic-types.html" />
<meta property="og:url" content="https://elixir-lang.org/ja/getting-started/basic-types.html" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"WebPage","headline":"Basic types","url":"https://elixir-lang.org/ja/getting-started/basic-types.html"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body class="">
  <div id="container">
    <div class="wrap">
    <div id="header">
      <div id="branding">
        <a id="site-title" href="/" title="Elixir" rel="Home">
          <img class="logo" src="/images/logo/logo.png" alt="Elixir Logo" />
        </a>
      </div>

      <div id="menu-primary" class="menu-container">
        <div class="menu">
          <ul id="menu-primary-items">
            <li class="menu-item home"><a class="spec" href="/">Home</a></li>
            <li class="menu-item install"><a class="spec" href="/install.html">Install</a></li>
            <li class="menu-item getting-started"><a class="spec" href="/getting-started/introduction.html">Guides</a></li>
            <li class="menu-item learning"><a class="spec" href="/learning.html">Learning</a></li>
            <li class="menu-item docs"><a class="spec" href="/docs.html">Docs</a></li>
            <li class="menu-item development"><a class="spec" href="/development.html">Development</a></li>
            <li class="menu-item blog"><a class="spec" href="/blog/">Blog</a></li>
            <li class="menu-item packages"><a class="spec" href="https://hex.pm/">Packages</a></li>
          </ul>
        </div>
      </div>

      <div class="clear"></div>
    </div>

    <div id="main">


<div id="sidebar-primary" class="sidebar">
  <div class="widget news">
  <h3>
    News: <a href="/blog/2018/07/25/elixir-v1-7-0-released/">Elixir v1.7 released</a>
  </h3>
</div>

<div class="widget search">
  <form method="get" id="search-form" class="search-form" action="https://www.google.com/search">
		<div>
			<input class="search-text" type="text" name="q" placeholder="Search..." id="searchfield" aria-label="Search box">
			<input type="hidden" name="sitesearch" value="elixir-lang.org">
			<input class="search-submit button" name="submit" type="submit" value="Search" aria-label="Search button">
		</div>
	</form>
</div>

  <div id="mini-docu" class="widget">
  <a href="http://doc.honeypot.io/elixir-documentary-2018/?utm_source=elixir_home&utm_medium=referral">
    <div class="mini-docu-cta">
      <div class="mini-docu-copy">Watch the Elixir<br />mini-documentary!</div>
    </div>
  </a>
</div>


  
  
    <div class="widget">
     <h3 class="widget-title">Getting Started</h3>
      <ol>
        
          <li><a class="spec" href="/getting-started/introduction.html" title="Introduction">Introduction</a></li>
        
          <li><a class="spec" href="/getting-started/basic-types.html" title="Basic types">Basic types</a></li>
        
          <li><a class="spec" href="/getting-started/basic-operators.html" title="Basic operators">Basic operators</a></li>
        
          <li><a class="spec" href="/getting-started/pattern-matching.html" title="Pattern matching">Pattern matching</a></li>
        
          <li><a class="spec" href="/getting-started/case-cond-and-if.html" title="case, cond and if">case, cond and if</a></li>
        
          <li><a class="spec" href="/getting-started/binaries-strings-and-char-lists.html" title="Binaries, strings and char lists">Binaries, strings and char lists</a></li>
        
          <li><a class="spec" href="/getting-started/keywords-and-maps.html" title="Keywords and maps">Keywords and maps</a></li>
        
          <li><a class="spec" href="/getting-started/modules-and-functions.html" title="Modules and Functions">Modules and Functions</a></li>
        
          <li><a class="spec" href="/getting-started/recursion.html" title="Recursion">Recursion</a></li>
        
          <li><a class="spec" href="/getting-started/enumerables-and-streams.html" title="Enumerables and streams">Enumerables and streams</a></li>
        
          <li><a class="spec" href="/getting-started/processes.html" title="Processes">Processes</a></li>
        
          <li><a class="spec" href="/getting-started/io-and-the-file-system.html" title="IO and the file system">IO and the file system</a></li>
        
          <li><a class="spec" href="/getting-started/alias-require-and-import.html" title="alias, require and import">alias, require and import</a></li>
        
          <li><a class="spec" href="/getting-started/module-attributes.html" title="Module attributes">Module attributes</a></li>
        
          <li><a class="spec" href="/getting-started/structs.html" title="Structs">Structs</a></li>
        
          <li><a class="spec" href="/getting-started/protocols.html" title="Protocols">Protocols</a></li>
        
          <li><a class="spec" href="/getting-started/comprehensions.html" title="Comprehensions">Comprehensions</a></li>
        
          <li><a class="spec" href="/getting-started/sigils.html" title="Sigils">Sigils</a></li>
        
          <li><a class="spec" href="/getting-started/try-catch-and-rescue.html" title="try, catch and rescue">try, catch and rescue</a></li>
        
          <li><a class="spec" href="/getting-started/typespecs-and-behaviours.html" title="Typespecs and behaviours">Typespecs and behaviours</a></li>
        
          <li><a class="spec" href="/getting-started/debugging.html" title="Debugging">Debugging</a></li>
        
          <li><a class="spec" href="/getting-started/erlang-libraries.html" title="Erlang libraries">Erlang libraries</a></li>
        
          <li><a class="spec" href="/getting-started/where-to-go-next.html" title="Where to go next">Where to go next</a></li>
        
      </ol>
    </div>
  
    <div class="widget">
     <h3 class="widget-title">Mix and OTP</h3>
      <ol>
        
          <li><a class="spec" href="/getting-started/mix-otp/introduction-to-mix.html" title="Introduction to Mix">Introduction to Mix</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/agent.html" title="Agent">Agent</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/genserver.html" title="GenServer">GenServer</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/supervisor-and-application.html" title="Supervisor and Application">Supervisor and Application</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/dynamic-supervisor.html" title="DynamicSupervisor">DynamicSupervisor</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/ets.html" title="ETS">ETS</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/dependencies-and-umbrella-projects.html" title="Dependencies and umbrella projects">Dependencies and umbrella projects</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/task-and-gen-tcp.html" title="Task and gen_tcp">Task and gen_tcp</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/docs-tests-and-with.html" title="Doctests, patterns and with">Doctests, patterns and with</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/distributed-tasks-and-configuration.html" title="Distributed tasks and configuration">Distributed tasks and configuration</a></li>
        
      </ol>
    </div>
  
    <div class="widget">
     <h3 class="widget-title">Meta-programming in Elixir</h3>
      <ol>
        
          <li><a class="spec" href="/getting-started/meta/quote-and-unquote.html" title="Quote and unquote">Quote and unquote</a></li>
        
          <li><a class="spec" href="/getting-started/meta/macros.html" title="Macros">Macros</a></li>
        
          <li><a class="spec" href="/getting-started/meta/domain-specific-languages.html" title="Domain Specific Languages">Domain Specific Languages</a></li>
        
      </ol>
    </div>
  

  <div id="elixir-radar" class="widget">
  <h3 class="widget-title">Elixir Radar Newsletter</h3>
  <p>A weekly Elixir email newsletter with content curated by Plataformatec.</p>
  <div class="elixir-radar-cta">
    <div class="cta-copy">
      <div class="cta-title">
        Elixir Radar
      </div>
      <div class="cta-subtitle">
        weekly newsletter
      </div>
    </div>
    <div class="cta-button-container">
      <a href="http://plataformatec.com.br/elixir-radar/weekly-newsletter?utm_campaign=elixir_lang_cta&utm_medium=cta&utm_source=elixir_lang_website" class="cta-button">
        Subscribe now
      </a>
    </div>
  </div>
</div>

  <div id="distilled-by" class="widget">
  <h3 class="widget-title">Created at</h3>
  <ul>
    <li class="image"><a href="http://plataformatec.com.br" title="Plataformatec"><img src="/images/logo/plataformatec.png" alt="Plataformatec Logo" width="190" height="74" /></a></li>
  </ul>

  <p>
    <a class="spec" href="http://plataformatec.com.br">Plataformatec</a> offers consulting and development services for companies using Elixir.
  </p>
</div>

</div>

<div id="content">
  <article>
    <h1 id="basic-types">Basic types</h1>

<div id="toc" class="toc"></div>

<p>In this chapter we will learn more about Elixir basic types: integers, floats, booleans, atoms, strings, lists and tuples. Some basic types are:</p>

<pre><code class="language-iex">iex&gt; 1          # integer
iex&gt; 0x1F       # integer
iex&gt; 1.0        # float
iex&gt; true       # boolean
iex&gt; :atom      # atom / symbol
iex&gt; "elixir"   # string
iex&gt; [1, 2, 3]  # list
iex&gt; {1, 2, 3}  # tuple
</code></pre>

<h2 id="basic-arithmetic">Basic arithmetic</h2>

<p>Open up <code class="highlighter-rouge">iex</code> and type the following expressions:</p>

<pre><code class="language-iex">iex&gt; 1 + 2
3
iex&gt; 5 * 5
25
iex&gt; 10 / 2
5.0
</code></pre>

<p>Notice that <code class="highlighter-rouge">10 / 2</code> returned a float <code class="highlighter-rouge">5.0</code> instead of an integer <code class="highlighter-rouge">5</code>. This is expected. In Elixir, the operator <code class="highlighter-rouge">/</code> always returns a float. If you want to do integer division or get the division remainder, you can invoke the <code class="highlighter-rouge">div</code> and <code class="highlighter-rouge">rem</code> functions:</p>

<pre><code class="language-iex">iex&gt; div(10, 2)
5
iex&gt; div 10, 2
5
iex&gt; rem 10, 3
1
</code></pre>

<p>Notice that Elixir allows you to drop the parentheses when invoking named functions. This feature gives a cleaner syntax when writing declarations and control-flow constructs.</p>

<p>Elixir also supports shortcut notations for entering binary, octal, and hexadecimal numbers:</p>

<pre><code class="language-iex">iex&gt; 0b1010
10
iex&gt; 0o777
511
iex&gt; 0x1F
31
</code></pre>

<p>Float numbers require a dot followed by at least one digit and also support <code class="highlighter-rouge">e</code> for scientific notation:</p>

<pre><code class="language-iex">iex&gt; 1.0
1.0
iex&gt; 1.0e-10
1.0e-10
</code></pre>

<p>Floats in Elixir are 64-bit double precision.</p>

<p>You can invoke the <code class="highlighter-rouge">round</code> function to get the closest integer to a given float, or the <code class="highlighter-rouge">trunc</code> function to get the integer part of a float.</p>

<pre><code class="language-iex">iex&gt; round(3.58)
4
iex&gt; trunc(3.58)
3
</code></pre>

<h2 id="identifying-functions">Identifying functions</h2>

<p>Functions in Elixir are identified by both their name and their arity. The arity of a function describes the number of arguments that the function takes. From this point on we will use both the function name and its arity to describe functions throughout the documentation. <code class="highlighter-rouge">round/1</code> identifies the function which is named <code class="highlighter-rouge">round</code> and takes 1 argument, whereas <code class="highlighter-rouge">round/2</code> identifies a different (nonexistent) function with the same name but with an arity of <code class="highlighter-rouge">2</code>.</p>

<h2 id="booleans">Booleans</h2>

<p>Elixir supports <code class="highlighter-rouge">true</code> and <code class="highlighter-rouge">false</code> as booleans:</p>

<pre><code class="language-iex">iex&gt; true
true
iex&gt; true == false
false
</code></pre>

<p>Elixir provides a bunch of predicate functions to check for a value type. For example, the <code class="highlighter-rouge">is_boolean/1</code> function can be used to check if a value is a boolean or not:</p>

<pre><code class="language-iex">iex&gt; is_boolean(true)
true
iex&gt; is_boolean(1)
false
</code></pre>

<p>You can also use <code class="highlighter-rouge">is_integer/1</code>, <code class="highlighter-rouge">is_float/1</code> or <code class="highlighter-rouge">is_number/1</code> to check, respectively, if an argument is an integer, a float, or either.</p>

<blockquote>
  <p>Note: At any moment you can type <code class="highlighter-rouge">h()</code> in the shell to print information on how to use the shell. The <code class="highlighter-rouge">h</code> helper can also be used to access documentation for any function. For example, typing <code class="highlighter-rouge">h is_integer/1</code> is going to print the documentation for the <code class="highlighter-rouge">is_integer/1</code> function. It also works with operators and other constructs (try <code class="highlighter-rouge">h ==/2</code>).</p>
</blockquote>

<h2 id="atoms">Atoms</h2>

<p>An atom is a constant whose name is its own value. Some other languages call these symbols:</p>

<pre><code class="language-iex">iex&gt; :hello
:hello
iex&gt; :hello == :world
false
</code></pre>

<p>The booleans <code class="highlighter-rouge">true</code> and <code class="highlighter-rouge">false</code> are, in fact, atoms:</p>

<pre><code class="language-iex">iex&gt; true == :true
true
iex&gt; is_atom(false)
true
iex&gt; is_boolean(:false)
true
</code></pre>

<p>Finally, Elixir has a construct called aliases which we will explore later. Aliases start in upper case and are also atoms:</p>

<pre><code class="language-iex">iex&gt; is_atom(Hello)
true
</code></pre>

<h2 id="strings">Strings</h2>

<p>Strings in Elixir are delimited by double quotes, and they are encoded in UTF-8:</p>

<pre><code class="language-iex">iex&gt; "hellö"
"hellö"
</code></pre>

<blockquote>
  <p>Note: if you are running on Windows, there is a chance your terminal does not use UTF-8 by default. You can change the encoding of your current session by running <code class="highlighter-rouge">chcp 65001</code> before entering IEx.</p>
</blockquote>

<p>Elixir also supports string interpolation:</p>

<pre><code class="language-iex">iex&gt; "hellö #{:world}"
"hellö world"
</code></pre>

<p>Strings can have line breaks in them. You can introduce them using escape sequences:</p>

<pre><code class="language-iex">iex&gt; "hello
...&gt; world"
"hello\nworld"
iex&gt; "hello\nworld"
"hello\nworld"
</code></pre>

<p>You can print a string using the <code class="highlighter-rouge">IO.puts/1</code> function from the <code class="highlighter-rouge">IO</code> module:</p>

<pre><code class="language-iex">iex&gt; IO.puts "hello\nworld"
hello
world
:ok
</code></pre>

<p>Notice that the <code class="highlighter-rouge">IO.puts/1</code> function returns the atom <code class="highlighter-rouge">:ok</code> after printing.</p>

<p>Strings in Elixir are represented internally by binaries which are sequences of bytes:</p>

<pre><code class="language-iex">iex&gt; is_binary("hellö")
true
</code></pre>

<p>We can also get the number of bytes in a string:</p>

<pre><code class="language-iex">iex&gt; byte_size("hellö")
6
</code></pre>

<p>Notice that the number of bytes in that string is 6, even though it has 5 characters. That’s because the character “ö” takes 2 bytes to be represented in UTF-8. We can get the actual length of the string, based on the number of characters, by using the <code class="highlighter-rouge">String.length/1</code> function:</p>

<pre><code class="language-iex">iex&gt; String.length("hellö")
5
</code></pre>

<p>The <a href="https://hexdocs.pm/elixir/String.html">String module</a> contains a bunch of functions that operate on strings as defined in the Unicode standard:</p>

<pre><code class="language-iex">iex&gt; String.upcase("hellö")
"HELLÖ"
</code></pre>

<h2 id="anonymous-functions">Anonymous functions</h2>

<p>Anonymous functions can be created inline and are delimited by the keywords <code class="highlighter-rouge">fn</code> and <code class="highlighter-rouge">end</code>:</p>

<pre><code class="language-iex">iex&gt; add = fn a, b -&gt; a + b end
#Function&lt;12.71889879/2 in :erl_eval.expr/5&gt;
iex&gt; add.(1, 2)
3
iex&gt; is_function(add)
true
iex&gt; is_function(add, 2) # check if add is a function that expects exactly 2 arguments
true
iex&gt; is_function(add, 1) # check if add is a function that expects exactly 1 argument
false
</code></pre>

<p>Functions are “first class citizens” in Elixir meaning they can be passed as arguments to other functions in the same way as integers and strings. In the example, we have passed the function in the variable <code class="highlighter-rouge">add</code> to the <code class="highlighter-rouge">is_function/1</code> function which correctly returned <code class="highlighter-rouge">true</code>. We can also check the arity of the function by calling <code class="highlighter-rouge">is_function/2</code>.</p>

<p>Note that a dot (<code class="highlighter-rouge">.</code>) between the variable and parentheses is required to invoke an anonymous function. The dot ensures there is no ambiguity between calling an anonymous function named <code class="highlighter-rouge">add</code> and a named function <code class="highlighter-rouge">add/2</code>. In this sense, Elixir makes a clear distinction between anonymous functions and named functions. We will explore those differences in <a href="/getting-started/modules-and-functions.html">Chapter 8</a>.</p>

<p>Anonymous functions are closures and as such they can access variables that are in scope when the function is defined. Let’s define a new anonymous function that uses the <code class="highlighter-rouge">add</code> anonymous function we have previously defined:</p>

<pre><code class="language-iex">iex&gt; double = fn a -&gt; add.(a, a) end
#Function&lt;6.71889879/1 in :erl_eval.expr/5&gt;
iex&gt; double.(2)
4
</code></pre>

<p>Keep in mind a variable assigned inside a function does not affect its surrounding environment:</p>

<pre><code class="language-iex">iex&gt; x = 42
42
iex&gt; (fn -&gt; x = 0 end).()
0
iex&gt; x
42
</code></pre>

<h2 id="linked-lists">(Linked) Lists</h2>

<p>Elixir uses square brackets to specify a list of values. Values can be of any type:</p>

<pre><code class="language-iex">iex&gt; [1, 2, true, 3]
[1, 2, true, 3]
iex&gt; length [1, 2, 3]
3
</code></pre>

<p>Two lists can be concatenated or subtracted using the <code class="highlighter-rouge">++/2</code> and <code class="highlighter-rouge">--/2</code> operators respectively:</p>

<pre><code class="language-iex">iex&gt; [1, 2, 3] ++ [4, 5, 6]
[1, 2, 3, 4, 5, 6]
iex&gt; [1, true, 2, false, 3, true] -- [true, false]
[1, 2, 3, true]
</code></pre>

<p>List operators never modify the existing list. Concatenating to or removing elements from a list returns a new list. We say that Elixir data structures are <em>immutable</em>. One advantage of immutability is that it leads to clearer code. You can freely pass the data around with the guarantee no one will change it - only transform it.</p>

<p>Throughout the tutorial, we will talk a lot about the head and tail of a list. The head is the first element of a list and the tail is the remainder of the list. They can be retrieved with the functions <code class="highlighter-rouge">hd/1</code> and <code class="highlighter-rouge">tl/1</code>. Let’s assign a list to a variable and retrieve its head and tail:</p>

<pre><code class="language-iex">iex&gt; list = [1, 2, 3]
iex&gt; hd(list)
1
iex&gt; tl(list)
[2, 3]
</code></pre>

<p>Getting the head or the tail of an empty list throws an error:</p>

<pre><code class="language-iex">iex&gt; hd []
** (ArgumentError) argument error
</code></pre>

<p>Sometimes you will create a list and it will return a value in single quotes. For example:</p>

<pre><code class="language-iex">iex&gt; [11, 12, 13]
'\v\f\r'
iex&gt; [104, 101, 108, 108, 111]
'hello'
</code></pre>

<p>When Elixir sees a list of printable ASCII numbers, Elixir will print that as a charlist (literally a list of characters). Charlists are quite common when interfacing with existing Erlang code. Whenever you see a value in IEx and you are not quite sure what it is, you can use the <code class="highlighter-rouge">i/1</code> to retrieve information about it:</p>

<pre><code class="language-iex">iex&gt; i 'hello'
Term
  'hello'
Data type
  List
Description
  ...
Raw representation
  [104, 101, 108, 108, 111]
Reference modules
  List
</code></pre>

<p>Keep in mind single-quoted and double-quoted representations are not equivalent in Elixir as they are represented by different types:</p>

<pre><code class="language-iex">iex&gt; 'hello' == "hello"
false
</code></pre>

<p>Single quotes are charlists, double quotes are strings. We will talk more about them in the <a href="/getting-started/binaries-strings-and-char-lists.html">“Binaries, strings and charlists”</a> chapter.</p>

<h2 id="tuples">Tuples</h2>

<p>Elixir uses curly brackets to define tuples. Like lists, tuples can hold any value:</p>

<pre><code class="language-iex">iex&gt; {:ok, "hello"}
{:ok, "hello"}
iex&gt; tuple_size {:ok, "hello"}
2
</code></pre>

<p>Tuples store elements contiguously in memory. This means accessing a tuple element by index or getting the tuple size is a fast operation. Indexes start from zero:</p>

<pre><code class="language-iex">iex&gt; tuple = {:ok, "hello"}
{:ok, "hello"}
iex&gt; elem(tuple, 1)
"hello"
iex&gt; tuple_size(tuple)
2
</code></pre>

<p>It is also possible to put an element at a particular index in a tuple with <code class="highlighter-rouge">put_elem/3</code>:</p>

<pre><code class="language-iex">iex&gt; tuple = {:ok, "hello"}
{:ok, "hello"}
iex&gt; put_elem(tuple, 1, "world")
{:ok, "world"}
iex&gt; tuple
{:ok, "hello"}
</code></pre>

<p>Notice that <code class="highlighter-rouge">put_elem/3</code> returned a new tuple. The original tuple stored in the <code class="highlighter-rouge">tuple</code> variable was not modified. Like lists, tuples are also immutable. Every operation on a tuple returns a new tuple, it never changes the given one.</p>

<h2 id="lists-or-tuples">Lists or tuples?</h2>

<p>What is the difference between lists and tuples?</p>

<p>Lists are stored in memory as linked lists, meaning that each element in a list holds its value and points to the following element until the end of the list is reached. This means accessing the length of a list is a linear operation: we need to traverse the whole list in order to figure out its size.</p>

<p>Similarly, the performance of list concatenation depends on the length of the left-hand list:</p>

<pre><code class="language-iex">iex&gt; list = [1, 2, 3]

# This is fast as we only need to traverse `[0]` to prepend to `list`
iex&gt; [0] ++ list
[0, 1, 2, 3]

# This is slow as we need to traverse `list` to append 4
iex&gt; list ++ [4]
[1, 2, 3, 4]
</code></pre>

<p>Tuples, on the other hand, are stored contiguously in memory. This means getting the tuple size or accessing an element by index is fast. However, updating or adding elements to tuples is expensive because it requires creating a new tuple in memory:</p>

<pre><code class="language-iex">iex&gt; tuple = {:a, :b, :c, :d}
iex&gt; put_elem(tuple, 2, :e)
{:a, :b, :e, :d}
</code></pre>

<p>Note that this applies only to the tuple itself, not its contents. For instance, when you update a tuple, all entries are shared between the old and the new tuple, except for the entry that has been replaced. In other words, tuples and lists in Elixir are capable of sharing their contents. This reduces the amount of memory allocation the language needs to perform and is only possible thanks to the immutable semantics of the language.</p>

<p>Those performance characteristics dictate the usage of those data structures. One very common use case for tuples is to use them to return extra information from a function. For example, <code class="highlighter-rouge">File.read/1</code> is a function that can be used to read file contents. It returns a tuple:</p>

<pre><code class="language-iex">iex&gt; File.read("path/to/existing/file")
{:ok, "... contents ..."}
iex&gt; File.read("path/to/unknown/file")
{:error, :enoent}
</code></pre>

<p>If the path given to <code class="highlighter-rouge">File.read/1</code> exists, it returns a tuple with the atom <code class="highlighter-rouge">:ok</code> as the first element and the file contents as the second. Otherwise, it returns a tuple with <code class="highlighter-rouge">:error</code> and the error description.</p>

<p>Most of the time, Elixir is going to guide you to do the right thing. For example, there is an <code class="highlighter-rouge">elem/2</code> function to access a tuple item but there is no built-in equivalent for lists:</p>

<pre><code class="language-iex">iex&gt; tuple = {:ok, "hello"}
{:ok, "hello"}
iex&gt; elem(tuple, 1)
"hello"
</code></pre>

<p>When counting the elements in a data structure, Elixir also abides by a simple rule: the function is named <code class="highlighter-rouge">size</code> if the operation is in constant time (i.e. the value is pre-calculated) or <code class="highlighter-rouge">length</code> if the operation is linear (i.e. calculating the length gets slower as the input grows). As a mnemonic, both “length” and “linear” start with “l”.</p>

<p>For example, we have used 4 counting functions so far: <code class="highlighter-rouge">byte_size/1</code> (for the number of bytes in a string), <code class="highlighter-rouge">tuple_size/1</code> (for tuple size), <code class="highlighter-rouge">length/1</code> (for list length) and <code class="highlighter-rouge">String.length/1</code> (for the number of graphemes in a string). We use <code class="highlighter-rouge">byte_size</code> to get the number of bytes in a string – a cheap operation. Retrieving the number of Unicode characters, on the other hand, uses <code class="highlighter-rouge">String.length</code>, and may be expensive as it relies on a traversal of the entire string.</p>

<p>Elixir also provides <code class="highlighter-rouge">Port</code>, <code class="highlighter-rouge">Reference</code>, and <code class="highlighter-rouge">PID</code> as data types (usually used in process communication), and we will take a quick look at them when talking about processes. For now, let’s take a look at some of the basic operators that go with our basic types.</p>

  </article><!-- .hfeed -->

  <div id="edit-on-github">
    <span>Is something wrong?</span>
    <a href="/edit/master/ja/getting-started/basic-types.markdown">
      Edit this page on GitHub.
    </a>
  </div>

  
  
  
  
  

  
  
    
  
    
  
    
  

</div><!-- #content -->

      </div><!-- #main -->

      <div class="clear"></div>

      <div id="copyright">
        &copy; 2012–2018 <a href="http://plataformatec.com.br/">Plataformatec</a>. All rights reserved.
      </div>
    </div><!-- .wrap -->
  </div><!-- #container -->

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <script src="/js/toc/toc.js" type="text/javascript" charset="utf-8"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.toc').toc({
        title: '',
        listType: 'ol',
        minimumHeaders: 2,
        headers: 'h2, h3, h4, h5, h6',
        linkHere: true,
        linkHereTitle: 'Link here',
        backToTop: true,
        backToTopId: 'toc',
        backToTopTitle: 'Back to Table of Contents',
      });
      $('.jekyll-toc-header a.jekyll-toc-link-here span.jekyll-toc-icon').addClass('icon icon-link');
      $('.jekyll-toc-header a.jekyll-toc-back-to-top span.jekyll-toc-icon').addClass('icon icon-chevron-up');
    });
  </script>
</body>
</html>

