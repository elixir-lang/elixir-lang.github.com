<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Keywords and maps - Elixir</title>
  <link href="http://feeds.feedburner.com/ElixirLang" rel="alternate" title="Elixir's Blog" type="application/atom+xml" />
  <link rel="stylesheet" type="text/css" href="/css/style.css" />
  <link rel="stylesheet" type="text/css" href="/css/syntax.css" />
  <link rel="stylesheet" href="/js/icons/style.css">
  <!--[if lt IE 8]><!-->
  <link rel="stylesheet" href="/js/icons/ie7/ie7.css">
  <!--<![endif]-->
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" id="font-bitter-css" href="//fonts.googleapis.com/css?family=Bitter:400,700" type="text/css" media="screen" />
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="search" type="application/opensearchdescription+xml" title="elixir-lang.org" href="/opensearch.xml" />
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-8268430-6', 'auto');
  ga('send', 'pageview');
  </script>
  <!-- Begin Jekyll SEO tag v2.2.3 -->
<meta property="og:title" content="Keywords and maps" />
<meta property="og:locale" content="en_US" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"WebPage","headline":"Keywords and maps","url":"/ja/getting-started/keywords-and-maps.html"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body class="">
  <div id="container">
    <div class="wrap">
    <div id="header">
      <div id="branding">
        <a id="site-title" href="/" title="Elixir" rel="Home">
          <img class="logo" src="/images/logo/logo.png" alt="Elixir Logo" />
        </a>
      </div>

      <div id="menu-primary" class="menu-container">
        <div class="menu">
          <ul id="menu-primary-items">
            <li class="menu-item home"><a class="spec" href="/">Home</a></li>
            <li class="menu-item install"><a class="spec" href="/install.html">Install</a></li>
            <li class="menu-item getting-started"><a class="spec" href="/getting-started/introduction.html">Guides</a></li>
            <li class="menu-item learning"><a class="spec" href="/learning.html">Learning</a></li>
            <li class="menu-item docs"><a class="spec" href="/docs.html">Docs</a></li>
            <li class="menu-item blog"><a class="spec" href="/blog/">Blog</a></li>
            <li class="menu-item packages"><a class="spec" href="https://hex.pm/">Packages</a></li>
          </ul>
        </div>
      </div>

      <div class="clear"></div>
    </div>

    <div id="main">


<div id="sidebar-primary" class="sidebar">
  <div class="widget news">
  <h3>
    News: <a href="/blog/2017/07/25/elixir-v1-5-0-released/">Elixir v1.5 released</a>
  </h3>
</div>

<div class="widget search">
  <form method="get" id="search-form" class="search-form" action="https://www.google.com/search">
		<div>
			<input class="search-text" type="text" name="q" placeholder="Search..." id="searchfield" aria-label="Search box">
			<input type="hidden" name="sitesearch" value="elixir-lang.org">
			<input class="search-submit button" name="submit" type="submit" value="Search" aria-label="Search button">
		</div>
	</form>
</div>

  <div id="try-elixir" class="widget">
  <a href="https://www.codeschool.com/courses/try-elixir?utm_source=elixir_home&utm_medium=referral">
      <div class="try-elixir-cta">
        <div class="try-elixir-copy">Learn Elixir in your browser for free!</div>
      </div>
  </a>
</div>


  
  
    <div class="widget">
     <h3 class="widget-title">Getting Started</h3>
      <ol>
        
          <li><a class="spec" href="/getting-started/introduction.html" title="Introduction">Introduction</a></li>
        
          <li><a class="spec" href="/getting-started/basic-types.html" title="Basic types">Basic types</a></li>
        
          <li><a class="spec" href="/getting-started/basic-operators.html" title="Basic operators">Basic operators</a></li>
        
          <li><a class="spec" href="/getting-started/pattern-matching.html" title="Pattern matching">Pattern matching</a></li>
        
          <li><a class="spec" href="/getting-started/case-cond-and-if.html" title="case, cond and if">case, cond and if</a></li>
        
          <li><a class="spec" href="/getting-started/binaries-strings-and-char-lists.html" title="Binaries, strings and char lists">Binaries, strings and char lists</a></li>
        
          <li><a class="spec" href="/getting-started/keywords-and-maps.html" title="Keywords and maps">Keywords and maps</a></li>
        
          <li><a class="spec" href="/getting-started/modules-and-functions.html" title="Modules and Functions">Modules and Functions</a></li>
        
          <li><a class="spec" href="/getting-started/recursion.html" title="Recursion">Recursion</a></li>
        
          <li><a class="spec" href="/getting-started/enumerables-and-streams.html" title="Enumerables and streams">Enumerables and streams</a></li>
        
          <li><a class="spec" href="/getting-started/processes.html" title="Processes">Processes</a></li>
        
          <li><a class="spec" href="/getting-started/io-and-the-file-system.html" title="IO and the file system">IO and the file system</a></li>
        
          <li><a class="spec" href="/getting-started/alias-require-and-import.html" title="alias, require and import">alias, require and import</a></li>
        
          <li><a class="spec" href="/getting-started/module-attributes.html" title="Module attributes">Module attributes</a></li>
        
          <li><a class="spec" href="/getting-started/structs.html" title="Structs">Structs</a></li>
        
          <li><a class="spec" href="/getting-started/protocols.html" title="Protocols">Protocols</a></li>
        
          <li><a class="spec" href="/getting-started/comprehensions.html" title="Comprehensions">Comprehensions</a></li>
        
          <li><a class="spec" href="/getting-started/sigils.html" title="Sigils">Sigils</a></li>
        
          <li><a class="spec" href="/getting-started/try-catch-and-rescue.html" title="try, catch and rescue">try, catch and rescue</a></li>
        
          <li><a class="spec" href="/getting-started/typespecs-and-behaviours.html" title="Typespecs and behaviours">Typespecs and behaviours</a></li>
        
          <li><a class="spec" href="/getting-started/erlang-libraries.html" title="Erlang libraries">Erlang libraries</a></li>
        
          <li><a class="spec" href="/getting-started/where-to-go-next.html" title="Where to go next">Where to go next</a></li>
        
      </ol>
    </div>
  
    <div class="widget">
     <h3 class="widget-title">Mix and OTP</h3>
      <ol>
        
          <li><a class="spec" href="/getting-started/mix-otp/introduction-to-mix.html" title="Introduction to Mix">Introduction to Mix</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/agent.html" title="Agent">Agent</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/genserver.html" title="GenServer">GenServer</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/supervisor-and-application.html" title="Supervisor and Application">Supervisor and Application</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/ets.html" title="ETS">ETS</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/dependencies-and-umbrella-apps.html" title="Dependencies and umbrella apps">Dependencies and umbrella apps</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/task-and-gen-tcp.html" title="Task and gen-tcp">Task and gen-tcp</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/docs-tests-and-with.html" title="Docs, tests and with">Docs, tests and with</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/distributed-tasks-and-configuration.html" title="Distributed tasks and configuration">Distributed tasks and configuration</a></li>
        
      </ol>
    </div>
  
    <div class="widget">
     <h3 class="widget-title">Meta-programming in Elixir</h3>
      <ol>
        
          <li><a class="spec" href="/getting-started/meta/quote-and-unquote.html" title="Quote and unquote">Quote and unquote</a></li>
        
          <li><a class="spec" href="/getting-started/meta/macros.html" title="Macros">Macros</a></li>
        
          <li><a class="spec" href="/getting-started/meta/domain-specific-languages.html" title="Domain Specific Languages">Domain Specific Languages</a></li>
        
      </ol>
    </div>
  

  <div id="elixir-radar" class="widget">
  <h3 class="widget-title">Elixir Radar Newsletter</h3>
  <p>A weekly Elixir email newsletter with content curated by Plataformatec.</p>
  <div class="elixir-radar-cta">
    <div class="cta-copy">
      <div class="cta-title">
        Elixir Radar
      </div>
      <div class="cta-subtitle">
        weekly newsletter
      </div>
    </div>
    <div class="cta-button-container">
      <a href="http://plataformatec.com.br/elixir-radar/weekly-newsletter?utm_campaign=elixir_lang_cta&utm_medium=cta&utm_source=elixir_lang_website" class="cta-button">
        Subscribe now
      </a>
    </div>
  </div>
</div>

  <div id="distilled-by" class="widget">
  <h3 class="widget-title">Created at</h3>
  <ul>
    <li class="image"><a href="http://plataformatec.com.br" title="Plataformatec"><img src="/images/logo/plataformatec.png" alt="Plataformatec Logo" width="190" height="74" /></a></li>
  </ul>

  <p>
    <a class="spec" href="http://plataformatec.com.br">Plataformatec</a> offers consulting and development services for companies using Elixir.
  </p>
</div>

</div>

<div id="content">
  <article>
    <h1 id="keywords-and-maps">Keywords and maps</h1>

<div id="toc" class="toc"></div>

<p>So far we haven’t discussed any associative data structures, i.e. data structures that are able to associate a certain value (or multiple values) to a key. Different languages call these different names like dictionaries, hashes, associative arrays, etc.</p>

<p>In Elixir, we have two main associative data structures: keyword lists and maps. It’s time to learn more about them!</p>

<h2 id="keyword-lists">Keyword lists</h2>

<p>In many functional programming languages, it is common to use a list of 2-item tuples as the representation of a key-value data structure. In Elixir, when we have a list of tuples and the first item of the tuple (i.e. the key) is an atom, we call it a keyword list:</p>

<pre><code class="language-iex">iex&gt; list = [{:a, 1}, {:b, 2}]
[a: 1, b: 2]
iex&gt; list == [a: 1, b: 2]
true
</code></pre>

<p>As you can see above, Elixir supports a special syntax for defining such lists: <code class="highlighter-rouge">[key: value]</code>. Underneath it maps to the same list of tuples as above. Since keyword lists are lists, we can use all operations available to lists. For example, we can use <code class="highlighter-rouge">++</code> to add new values to a keyword list:</p>

<pre><code class="language-iex">iex&gt; list ++ [c: 3]
[a: 1, b: 2, c: 3]
iex&gt; [a: 0] ++ list
[a: 0, a: 1, b: 2]
</code></pre>

<p>Note that values added to the front are the ones fetched on lookup:</p>

<pre><code class="language-iex">iex&gt; new_list = [a: 0] ++ list
[a: 0, a: 1, b: 2]
iex&gt; new_list[:a]
0
</code></pre>

<p>Keyword lists are important because they have three special characteristics:</p>

<ul>
  <li>Keys must be atoms.</li>
  <li>Keys are ordered, as specified by the developer.</li>
  <li>Keys can be given more than once.</li>
</ul>

<p>For example, <a href="https://github.com/elixir-lang/ecto">the Ecto library</a> makes use of these features to provide an elegant DSL for writing database queries:</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="n">query</span> <span class="o">=</span> <span class="n">from</span> <span class="n">w</span> <span class="ow">in</span> <span class="no">Weather</span><span class="p">,</span>
      <span class="ss">where:</span> <span class="n">w</span><span class="o">.</span><span class="n">prcp</span> <span class="o">&gt;</span> <span class="m">0</span><span class="p">,</span>
      <span class="ss">where:</span> <span class="n">w</span><span class="o">.</span><span class="n">temp</span> <span class="o">&lt;</span> <span class="m">20</span><span class="p">,</span>
     <span class="ss">select:</span> <span class="n">w</span>
</code></pre>
</div>

<p>These characteristics are what prompted keyword lists to be the default mechanism for passing options to functions in Elixir. In chapter 5, when we discussed the <code class="highlighter-rouge">if/2</code> macro, we mentioned the following syntax is supported:</p>

<pre><code class="language-iex">iex&gt; if false, do: :this, else: :that
:that
</code></pre>

<p>The <code class="highlighter-rouge">do:</code> and <code class="highlighter-rouge">else:</code> pairs are keyword lists! In fact, the call above is equivalent to:</p>

<pre><code class="language-iex">iex&gt; if(false, [do: :this, else: :that])
:that
</code></pre>

<p>Which, as we have seen above, is the same as:</p>

<pre><code class="language-iex">iex&gt; if(false, [{:do, :this}, {:else, :that}])
:that
</code></pre>

<p>In general, when the keyword list is the last argument of a function, the square brackets are optional.</p>

<p>Although we can pattern match on keyword lists, it is rarely done in practice since pattern matching on lists requires the number of items and their order to match:</p>

<pre><code class="language-iex">iex&gt; [a: a] = [a: 1]
[a: 1]
iex&gt; a
1
iex&gt; [a: a] = [a: 1, b: 2]
** (MatchError) no match of right hand side value: [a: 1, b: 2]
iex&gt; [b: b, a: a] = [a: 1, b: 2]
** (MatchError) no match of right hand side value: [a: 1, b: 2]
</code></pre>

<p>In order to manipulate keyword lists, Elixir provides <a href="https://hexdocs.pm/elixir/Keyword.html">the <code class="highlighter-rouge">Keyword</code> module</a>. Remember, though, keyword lists are simply lists, and as such they provide the same linear performance characteristics as lists. The longer the list, the longer it will take to find a key, to count the number of items, and so on. For this reason, keyword lists are used in Elixir mainly for passing optional values. If you need to store many items or guarantee one-key associates with at maximum one-value, you should use maps instead.</p>

<h2 id="maps">Maps</h2>

<p>Whenever you need a key-value store, maps are the “go to” data structure in Elixir. A map is created using the <code class="highlighter-rouge">%{}</code> syntax:</p>

<pre><code class="language-iex">iex&gt; map = %{:a =&gt; 1, 2 =&gt; :b}
%{2 =&gt; :b, :a =&gt; 1}
iex&gt; map[:a]
1
iex&gt; map[2]
:b
iex&gt; map[:c]
nil
</code></pre>

<p>Compared to keyword lists, we can already see two differences:</p>

<ul>
  <li>Maps allow any value as a key.</li>
  <li>Maps’ keys do not follow any ordering.</li>
</ul>

<p>In contrast to keyword lists, maps are very useful with pattern matching. When a map is used in a pattern, it will always match on a subset of the given value:</p>

<pre><code class="language-iex">iex&gt; %{} = %{:a =&gt; 1, 2 =&gt; :b}
%{2 =&gt; :b, :a =&gt; 1}
iex&gt; %{:a =&gt; a} = %{:a =&gt; 1, 2 =&gt; :b}
%{2 =&gt; :b, :a =&gt; 1}
iex&gt; a
1
iex&gt; %{:c =&gt; c} = %{:a =&gt; 1, 2 =&gt; :b}
** (MatchError) no match of right hand side value: %{2 =&gt; :b, :a =&gt; 1}
</code></pre>

<p>As shown above, a map matches as long as the keys in the pattern exist in the given map. Therefore, an empty map matches all maps.</p>

<p>Variables can be used when accessing, matching and adding map keys:</p>

<pre><code class="language-iex">iex&gt; n = 1
1
iex&gt; map = %{n =&gt; :one}
%{1 =&gt; :one}
iex&gt; map[n]
:one
iex&gt; %{^n =&gt; :one} = %{1 =&gt; :one, 2 =&gt; :two, 3 =&gt; :three}
%{1 =&gt; :one, 2 =&gt; :two, 3 =&gt; :three}
</code></pre>

<p><a href="https://hexdocs.pm/elixir/Map.html">The <code class="highlighter-rouge">Map</code> module</a> provides a very similar API to the <code class="highlighter-rouge">Keyword</code> module with convenience functions to manipulate maps:</p>

<pre><code class="language-iex">iex&gt; Map.get(%{:a =&gt; 1, 2 =&gt; :b}, :a)
1
iex&gt; Map.put(%{:a =&gt; 1, 2 =&gt; :b}, :c, 3)
%{2 =&gt; :b, :a =&gt; 1, :c =&gt; 3}
iex&gt; Map.to_list(%{:a =&gt; 1, 2 =&gt; :b})
[{2, :b}, {:a, 1}]
</code></pre>

<p>Maps have the following syntax for updating a key’s value:</p>

<pre><code class="language-iex">iex&gt; map = %{:a =&gt; 1, 2 =&gt; :b}
%{2 =&gt; :b, :a =&gt; 1}

iex&gt; %{map | 2 =&gt; "two"}
%{2 =&gt; "two", :a =&gt; 1}
iex&gt; %{map | :c =&gt; 3}
** (KeyError) key :c not found in: %{2 =&gt; :b, :a =&gt; 1}
</code></pre>

<p>The syntax above requires the given key to exist. It cannot be used to add new keys. For example, using it with the <code class="highlighter-rouge">:c</code> key failed because there is no <code class="highlighter-rouge">:c</code> in the map.</p>

<p>When all the keys in a map are atoms, you can use the keyword syntax for convenience:</p>

<pre><code class="language-iex">iex&gt; map = %{a: 1, b: 2}
%{a: 1, b: 2}
</code></pre>

<p>Another interesting property of maps is that they provide their own syntax for accessing atom keys:</p>

<pre><code class="language-iex">iex&gt; map = %{:a =&gt; 1, 2 =&gt; :b}
%{2 =&gt; :b, :a =&gt; 1}

iex&gt; map.a
1
iex&gt; map.c
** (KeyError) key :c not found in: %{2 =&gt; :b, :a =&gt; 1}
</code></pre>

<p>Elixir developers typically prefer to use the <code class="highlighter-rouge">map.field</code> syntax and pattern matching instead of the functions in the <code class="highlighter-rouge">Map</code> module when working with maps because they lead to an assertive style of programming. <a href="http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/">This blog post</a> provides insight and examples on how you get more concise and faster software by writing assertive code in Elixir.</p>

<blockquote>
  <p>Note: Maps were recently introduced into the Erlang <abbr title="Virtual Machine">VM</abbr> and only from Elixir v1.2 they are capable of holding millions of keys efficiently. Therefore, if you are working with previous Elixir versions (v1.0 or v1.1) and you need to support at least hundreds of keys, you may consider using <a href="https://hexdocs.pm/elixir/HashDict.html">the <code class="highlighter-rouge">HashDict</code> module</a>.</p>
</blockquote>

<h2 id="nested-data-structures">Nested data structures</h2>

<p>Often we will have maps inside maps, or even keywords lists inside maps, and so forth. Elixir provides conveniences for manipulating nested data structures via the <code class="highlighter-rouge">put_in/2</code>, <code class="highlighter-rouge">update_in/2</code> and other macros giving the same conveniences you would find in imperative languages while keeping the immutable properties of the language.</p>

<p>Imagine you have the following structure:</p>

<pre><code class="language-iex">iex&gt; users = [
  john: %{name: "John", age: 27, languages: ["Erlang", "Ruby", "Elixir"]},
  mary: %{name: "Mary", age: 29, languages: ["Elixir", "F#", "Clojure"]}
]
[john: %{age: 27, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
 mary: %{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}]
</code></pre>

<p>We have a keyword list of users where each value is a map containing the name, age and a list of programming languages each user likes. If we wanted to access the age for john, we could write:</p>

<pre><code class="language-iex">iex&gt; users[:john].age
27
</code></pre>

<p>It happens we can also use this same syntax for updating the value:</p>

<pre><code class="language-iex">iex&gt; users = put_in users[:john].age, 31
[john: %{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
 mary: %{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}]
</code></pre>

<p>The <code class="highlighter-rouge">update_in/2</code> macro is similar but allows us to pass a function that controls how the value changes. For example, let’s remove “Clojure” from Mary’s list of languages:</p>

<pre><code class="language-iex">iex&gt; users = update_in users[:mary].languages, fn languages -&gt; List.delete(languages, "Clojure") end
[john: %{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
 mary: %{age: 29, languages: ["Elixir", "F#"], name: "Mary"}]
</code></pre>

<p>There is more to learn about <code class="highlighter-rouge">put_in/2</code> and <code class="highlighter-rouge">update_in/2</code>, including the <code class="highlighter-rouge">get_and_update_in/2</code> that allows us to extract a value and update the data structure at once. There are also <code class="highlighter-rouge">put_in/3</code>, <code class="highlighter-rouge">update_in/3</code> and <code class="highlighter-rouge">get_and_update_in/3</code> which allow dynamic access into the data structure. <a href="https://hexdocs.pm/elixir/Kernel.html">Check their respective documentation in the <code class="highlighter-rouge">Kernel</code> module for more information</a>.</p>

<p>This concludes our introduction to associative data structures in Elixir. You will find out that, given keyword lists and maps, you will always have the right tool to tackle problems that require associative data structures in Elixir.</p>

  </article><!-- .hfeed -->

  <div id="edit-on-github">
    <span>Is something wrong?</span>
    <a href="/edit/master/ja/getting-started/keywords-and-maps.markdown">
      Edit this page on GitHub.
    </a>
  </div>

  
  
  
  
  

  
  
    
  
    
  
    
  

</div><!-- #content -->

      </div><!-- #main -->

      <div class="clear"></div>

      <div id="copyright">
        &copy; 2012–2017 <a href="http://plataformatec.com.br/">Plataformatec</a>. All rights reserved.
      </div>
    </div><!-- .wrap -->
  </div><!-- #container -->

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <script src="/js/toc/toc.js" type="text/javascript" charset="utf-8"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.toc').toc({
        title: '',
        listType: 'ol',
        minimumHeaders: 2,
        headers: 'h2, h3, h4, h5, h6',
        linkHere: true,
        linkHereTitle: 'Link here',
        backToTop: true,
        backToTopId: 'toc',
        backToTopTitle: 'Back to Table of Contents',
      });
      $('.jekyll-toc-header a.jekyll-toc-link-here span.jekyll-toc-icon').addClass('icon icon-link');
      $('.jekyll-toc-header a.jekyll-toc-back-to-top span.jekyll-toc-icon').addClass('icon icon-chevron-up');
    });
  </script>
</body>
</html>

