<!DOCTYPE html>
<html>
  <head>
    <title>File</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <h1>
        File
        
      </h1>

      
        <div id="moduledoc" class="docstring">
          <p>This module contains function to manipulate files,
filenames and the filesystem. Many of the functions
that interact with the filesystem have their naming
based on its UNIX variants. For example, deleting a
file is done with <code>File.rm</code>. Getting its stats with
<code>File.stat</code>. If you want to read or write to a file
in chunks, check the IO module.</p>

<p>Most of the functions in this module return <code>:ok</code>
or <code>{ :ok, result }</code> in case of success, <code>{ :error, reason }</code>
otherwise. Those function are also followed by
a variant that ends with <code>!</code> which returns the
result (without the <code>{ :ok, result }</code> tuple) in
case of success or raises an exception in case it
fails. For example:</p>

<pre><code>File.read(&quot;hello.txt&quot;)
#=&gt; { :ok, &quot;World&quot; }

File.read(&quot;invalid.txt&quot;)
#=&gt; { :error, :enoent }

File.read!(&quot;hello.txt&quot;)
#=&gt; &quot;World&quot;

File.read!(&quot;invalid.txt&quot;)
#=&gt; raises File.Error
</code></pre>

<p>In general, a developer should use the former in case
he wants to react in the fie does not exist. The latter
should be used when the developer expects his software
to fail in case the file cannot be read (i.e. it is
literally an exception).</p>

<p>Finally, the functions in this module accept either
a char lists or a binary. When manipulating paths, a char
list is returned if one is given as argument. However,
when reading files, binaries are always returned.</p>

        </div>
      

      <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L55" target="_blank" class="view_source">Source</a>

      

      

      
        <h2>Functions summary</h2>
        <ul class="summary">
          <li>
  <span class="summary_signature">
    <a href="#basename/1">basename/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#basename/2">basename/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#cd/1">cd/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#cd!/1">cd!/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#cd!/2">cd!/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#close/1">close/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#copy/3">copy/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#copy!/3">copy!/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#cp/3">cp/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#cp!/3">cp!/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#cp_r/3">cp_r/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#cp_r!/3">cp_r!/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#cwd/0">cwd/0</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#cwd!/0">cwd!/0</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#dir?/1">dir?/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#dirname/1">dirname/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#exists?/1">exists?/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#expand_path/1">expand_path/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#expand_path/2">expand_path/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#extname/1">extname/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#iterator/1">iterator/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#iterator/2">iterator/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#iterator!/2">iterator!/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#join/1">join/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#join/2">join/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#mkdir/1">mkdir/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#mkdir!/1">mkdir!/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#mkdir_p/1">mkdir_p/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#mkdir_p!/1">mkdir_p!/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#open/2">open/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#open/3">open/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#open!/2">open!/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#open!/3">open!/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#read/1">read/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#read!/1">read!/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#regular?/1">regular?/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#rm/1">rm/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#rm!/1">rm!/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#rm_rf/1">rm_rf/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#rm_rf!/1">rm_rf!/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#rmdir/1">rmdir/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#rmdir!/1">rmdir!/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#rootname/1">rootname/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#rootname/2">rootname/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#split/1">split/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#stat/2">stat/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#stat!/2">stat!/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#touch/2">touch/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#touch!/2">touch!/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#wildcard/1">wildcard/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#write/3">write/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#write!/3">write!/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#write_stat/3">write_stat/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#write_stat!/3">write_stat!/3</a>
  </span>
</li>

        </ul>
      

      

      
        <div id="functions_details" class="details_list">
          <h2>Functions</h2>
          <div class="detail">
  <p class="signature" id="basename/1">
    <strong>basename(path)</strong>
  </p>
  <div class="docstring"><p>Returns the last component of the path or the path
itself if it does not contain any directory separators.</p>

<p>If the given <code>path</code> is a char list, returns a char list.
Otherwise returns a binary.</p>

<h2>Examples</h2>

<pre><code>File.basename(&quot;foo&quot;)
#=&gt; &quot;foo&quot;

File.basename(&quot;foo/bar&quot;)
#=&gt; &quot;bar&quot;

File.basename(&quot;/&quot;)
#=&gt; &quot;&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L194" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="basename/2">
    <strong>basename(path, extension)</strong>
  </p>
  <div class="docstring"><p>Returns the last component of <code>path</code> with the <code>extension</code>
stripped. This function should be used to remove a specific
extension which might, or might not, be there.</p>

<p>If the given <code>path</code> is a char list, returns a char list.
Otherwise returns a binary.</p>

<h2>Examples</h2>

<pre><code>File.basename(&quot;~/foo/bar.ex&quot;, &quot;.ex&quot;)
#=&gt; &quot;bar&quot;
File.basename(&quot;~/foo/bar.exs&quot;, &quot;.ex&quot;)
#=&gt; &quot;bar.exs&quot;
File.basename(&quot;~/foo/bar.old.ex&quot;, &quot;.ex&quot;)
#=&gt; &quot;bar.old&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L216" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="cd/1">
    <strong>cd(path)</strong>
  </p>
  <div class="docstring"><p>Sets the current working directory. Returns <code>:ok</code> if successful,
<code>{ :error, reason }</code> otherwise.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L1086" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="cd!/1">
    <strong>cd!(path)</strong>
  </p>
  <div class="docstring"><p>The same as <code>cd/0</code>, but raises an exception if it fails.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L1093" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="cd!/2">
    <strong>cd!(path, function)</strong>
  </p>
  <div class="docstring"><p>Changes the current directory to the given <code>path</code>,
executes the given function and then revert back
to the previous path regardless if there is an exception.</p>

<p>Raises an error if retrieving or changing the current
directory fails.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L1109" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="close/1">
    <strong>close(io_device)</strong>
  </p>
  <div class="docstring"><p>Closes the file referenced by <code>io_device</code>. It mostly returns <code>:ok</code>, except
for some severe errors such as out of memory.</p>

<p>Note that if the option <code>:delayed_write</code> was used when opening the file,
<code>close/1</code> might return an old write error and not even try to close the file.
See <code>open/2</code>.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L1127" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="copy/3">
    <strong>copy(source, destination, bytes_count // :infinity)</strong>
  </p>
  <div class="docstring"><p>Copies the contents of <code>source</code> to <code>destination</code>. Both
parameters can be a filename or an io device opened with <code>File.open</code>.
<code>bytes_count</code> specifies the number of bytes to count, the default
being <code>:infinity</code>.</p>

<p>If file <code>destination</code> already exists, it is overriden
by the contents in <code>source</code>.</p>

<p>Returns <code>{ :ok, bytes_copied }</code> if successful,
<code>{ :error, reason }</code> otherwise.</p>

<p>Typical error reasons are the same as in <code>open/2</code>,
<code>read/1</code> and <code>write/2</code>.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L567" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="copy!/3">
    <strong>copy!(source, destination, bytes_count // :infinity)</strong>
  </p>
  <div class="docstring"><p>The same as <code>copy/3</code> but raises an File.CopyError if it fails.
Returns the <code>bytes_copied</code> otherwise.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L575" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="cp/3">
    <strong>cp(source, destination, callback // fn _, _ -&gt;
  true
end)</strong>
  </p>
  <div class="docstring"><p>Copies the contents in <code>source</code> to <code>destination</code>.
Similar to the command <code>cp -r</code> in Unix systems,
this function behaves differently depending
if <code>source</code> and <code>destination</code> are a file or a directory.</p>

<p>If both are files, it simply copies <code>source</code> to
<code>destination</code>. However, if <code>destination</code> is a directory,
it copies the contents of <code>source</code> to <code>destination/source</code>
recursively.</p>

<p>If a file already exists in the destination,
it invokes a callback which should return
true if the existing file should be overriden,
false otherwise. It defaults to return true.</p>

<p>It returns <code>:ok</code> in case of success, returns
<code>{ :error, reason }</code> otherwise.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L603" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="cp!/3">
    <strong>cp!(source, destination, callback // fn _, _ -&gt;
  true
end)</strong>
  </p>
  <div class="docstring"><p>The same as <code>cp/3</code>, but raises File.CopyError if it fails.
Returns the list of copied files otherwise.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L626" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="cp_r/3">
    <strong>cp_r(source, destination, callback // fn _, _ -&gt;
  true
end)</strong>
  </p>
  <div class="docstring"><p>Copies the contents in source to destination.
Similar to the command <code>cp -r</code> in Unix systems,
this function behaves differently depending
if <code>source</code> and <code>destination</code> are a file or a directory.</p>

<p>If both are files, it simply copies <code>source</code> to
<code>destination</code>. However, if <code>destination</code> is a directory,
it copies the contents of <code>source</code> to <code>destination/source</code>
recursively.</p>

<p>If a file already exists in the destination,
it invokes a callback which should return
true if the existing file should be overriden,
false otherwise. It defaults to return true.</p>

<p>If a directory already exists in the destination
where a file is meant to be (or otherwise), this
function will fail.</p>

<p>This function may fail while copying files,
in such cases, it will leave the destination
directory in a dirty state, where already
copied files won&#39;t be removed.</p>

<p>It returns <code>{ :ok, files_and_directories }</code> in case of
success with all files and directories copied in no
specific order, <code>{ :error, reason }</code> otherwise.</p>

<h2>Examples</h2>

<pre><code># Copies &quot;a.txt&quot; to &quot;tmp/a.txt&quot;
File.cp_r &quot;a.txt&quot;, &quot;tmp&quot;

# Copies all files in &quot;samples&quot; to &quot;tmp/samples&quot;
File.cp_r &quot;samples&quot;, &quot;tmp&quot;

# Copies all files in &quot;samples&quot; to &quot;tmp&quot;
File.cp_r &quot;samples/.&quot;, &quot;tmp&quot;

# Same as before, but asks the user how to proceed in case of conflicts
File.cp_r &quot;samples/.&quot;, &quot;tmp&quot;, fn(source, destination) -&gt;
  IO.gets(&quot;Overriding #{destination} by #{source}. Type y to confirm.&quot;) == &quot;y&quot;
end
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L681" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="cp_r!/3">
    <strong>cp_r!(source, destination, callback // fn _, _ -&gt;
  true
end)</strong>
  </p>
  <div class="docstring"><p>The same as <code>cp_r/3</code>, but raises File.CopyError if it fails.
Returns the list of copied files otherwise.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L700" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="cwd/0">
    <strong>cwd()</strong>
  </p>
  <div class="docstring"><p>Gets the current working directory. In rare circumstances, this function can
fail on Unix. It may happen if read permission does not exist for the parent
directories of the current directory. For this reason, returns <code>{ :ok, cwd }</code>
in case of success, <code>{ :error, reason }</code> otherwise.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L1064" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="cwd!/0">
    <strong>cwd!()</strong>
  </p>
  <div class="docstring"><p>The same as <code>cwd/0</code>, but raises an exception if it fails.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L1074" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="dir?/1">
    <strong>dir?(path)</strong>
  </p>
  <div class="docstring"><p>Returns true if the path is a directory.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L150" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="dirname/1">
    <strong>dirname(path)</strong>
  </p>
  <div class="docstring"><p>Return the <code>directory</code> component of <code>path</code>.</p>

<p>If the given <code>path</code> is a char list, returns a char list.
Otherwise returns a binary.</p>

<h2>Examples</h2>

<pre><code>File.dirname(&quot;/foo/bar.ex&quot;)
#=&gt; &quot;foo&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L232" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="exists?/1">
    <strong>exists?(path)</strong>
  </p>
  <div class="docstring"><p>Returns true if the given argument exists.
It can be regular file, directory, socket,
symbolic link, named pipe or device file.</p>

<h2>Examples</h2>

<pre><code>File.exists?(&quot;test/&quot;)
#=&gt; true

File.exists?(&quot;missing.txt&quot;)
#=&gt; false

File.exists?(&quot;/dev/null&quot;)
#=&gt; true
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L171" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="expand_path/1">
    <strong>expand_path(path)</strong>
  </p>
  <div class="docstring"><p>Expands the path by returning its absolute name and expanding
any <code>.</code> and <code>..</code> characters.</p>

<p>If the given <code>path</code> is a char list, returns a char list.
Otherwise returns a binary.</p>

<h2>Examples</h2>

<pre><code>File.expand_path(&quot;/foo/bar/../bar&quot;) == &quot;/foo/bar&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L113" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="expand_path/2">
    <strong>expand_path(path, relative_to)</strong>
  </p>
  <div class="docstring"><p>Expands the path to the relative location and expanding
any <code>.</code> and <code>..</code> characters. If the path is already an
absolute path, the relative location is ignored.</p>

<p>If the given <code>path</code> is a char list, returns a char list.
Otherwise returns a binary.</p>

<h2>Examples</h2>

<pre><code>File.expand_path(&quot;foo/bar/../bar&quot;, &quot;/baz&quot;) == &quot;/baz/foo/bar&quot;
File.expand_path(&quot;/foo/bar/../bar&quot;, &quot;/baz&quot;) == &quot;/foo/bar&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L131" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="extname/1">
    <strong>extname(path)</strong>
  </p>
  <div class="docstring"><p>Return the <code>extension</code> of the last component of <code>path</code>.</p>

<p>If the given <code>path</code> is a char list, returns a char list.
Otherwise returns a binary.</p>

<h2>Examples</h2>

<pre><code>File.extname(&quot;foo.erl&quot;)
#=&gt; &quot;.erl&quot;
File.extname(&quot;~/foo/bar&quot;)
#=&gt; &quot;&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L250" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="iterator/1">
    <strong>iterator(device)</strong>
  </p>
  <div class="docstring"><p>Convert the file device into an iterator that can be
passed into <code>Enum</code>. The device is iterated line
by line lazily, at the end of iteration the file is
closed.</p>

<h2>Examples</h2>

<p>An example that lazily iterates a file replacing all double
quotes per single quotes and write each line to a target file
is shown below:</p>

<pre><code>source = File.iterator(&quot;README.md&quot;)
File.open &quot;NEWREADME.md&quot;, [:write], fn(target) -&gt;
  Enum.each source, fn(line) -&gt;
    IO.write target, Regex.replace_all(%r/&quot;/, line, &quot;&#39;&quot;)
  end
end
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L1151" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="iterator/2">
    <strong>iterator(file, mode)</strong>
  </p>
  <div class="docstring"><p>Opens the given <code>file</code> with the given <code>mode</code> and
returns its iterator. Fails for the same reasons
as <code>File.open</code>.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L1179" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="iterator!/2">
    <strong>iterator!(file, mode // [])</strong>
  </p>
  <div class="docstring"><p>Same as <code>iterator/2</code> but raises if the file
cannot be opened.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L1190" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="join/1">
    <strong>join(paths)</strong>
  </p>
  <div class="docstring"><p>Returns a string with one or more paths components joint by the path separator.
This function should be used to convert a list of strings in a path.</p>

<p>If the given <code>paths</code> are a char list, returns a char list.
Otherwise returns a binary.</p>

<h2>Examples</h2>

<pre><code>File.join([&quot;~&quot;, &quot;foo&quot;])
#=&gt; &quot;~/foo&quot;
File.join([&quot;foo&quot;])
#=&gt; &quot;foo&quot;
File.join([&quot;/&quot;, &quot;foo&quot;, &quot;bar&quot;])
#=&gt; &quot;/foo/bar&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L308" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="join/2">
    <strong>join(left, right)</strong>
  </p>
  <div class="docstring"><p>Join two paths.</p>

<p>If the given paths are a char list, returns a char list.
Otherwise returns a binary.</p>

<h2>Examples</h2>

<pre><code>File.join(&quot;foo&quot;, &quot;bar&quot;)
#=&gt; &quot;foo/bar&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L324" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="mkdir/1">
    <strong>mkdir(path)</strong>
  </p>
  <div class="docstring"><p>Tries to create the directory <code>path</code>. Missing parent directories are not created.
Returns <code>:ok</code> if successful, or <code>{:error, reason}</code> if an error occurs.</p>

<p>Typical error reasons are:</p>

<ul>
<li>:eacces  - Missing search or write permissions for the parent directories of <code>path</code>.</li>
<li>:eexist  - There is already a file or directory named <code>path</code>.</li>
<li>:enoent  - A component of <code>path</code> does not exist.</li>
<li>:enospc  - There is a no space left on the device.</li>
<li>:enotdir - A component of <code>path</code> is not a directory
         On some platforms, <code>:enoent</code> is returned instead.</li>
</ul>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L341" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="mkdir!/1">
    <strong>mkdir!(path)</strong>
  </p>
  <div class="docstring"><p>Same as <code>mkdir</code>, but raises an exception in case of failure. Otherwise <code>:ok</code>.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L348" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="mkdir_p/1">
    <strong>mkdir_p(path)</strong>
  </p>
  <div class="docstring"><p>Tries to create the directory <code>path</code>. Missing parent directories are created.
Returns <code>:ok</code> if successful, or <code>{:error, reason}</code> if an error occurs.</p>

<p>Typical error reasons are:</p>

<ul>
<li>:eacces  - Missing search or write permissions for the parent directories of <code>path</code>.</li>
<li>:enospc  - There is a no space left on the device.</li>
<li>:enotdir - A component of <code>path</code> is not a directory.</li>
</ul>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L366" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="mkdir_p!/1">
    <strong>mkdir_p!(path)</strong>
  </p>
  <div class="docstring"><p>Same as <code>mkdir_p</code>, but raises an exception in case of failure. Otherwise <code>:ok</code>.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L373" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="open/2">
    <strong>open(path, modes // [])</strong>
  </p>
  <div class="docstring"><p>Opens the given <code>path</code> according to the given list of modes.</p>

<p>By default, the file is opened in read mode, as a binary with utf8 encoding.</p>

<p>The allowed modes:</p>

<ul>
<li><p><code>:read</code> - The file, which must exist, is opened for reading.</p></li>
<li><p><code>:write</code> -  The file is opened for writing. It is created if it does not exist.
          If the file exists, and if write is not combined with read, the file will be truncated.</p></li>
<li><p><code>:append</code> - The file will be opened for writing, and it will be created if it does not exist.
          Every write operation to a file opened with append will take place at the end of the file.</p></li>
<li><p><code>:exclusive</code> - The file, when opened for writing, is created if it does not exist.
             If the file exists, open will return { :error, :eexist }.</p></li>
<li><p><code>:charlist</code> - When this term is given, read operations on the file will return char lists rather than binaries;</p></li>
<li><p><code>:compressed</code> -  Makes it possible to read or write gzip compressed files.
               The compressed option must be combined with either read or write, but not both.
               Note that the file size obtained with <code>stat/1</code> will most probably not
               match the number of bytes that can be read from a compressed file.</p></li>
</ul>

<p>If a function is given to modes (instead of a list), it dispatches to <code>open/3</code>.</p>

<p>Check <code>http://www.erlang.org/doc/man/file.html#open-2</code> for more information about
other options as <code>read_ahead</code> and <code>delayed_write</code>.</p>

<p>This function returns:</p>

<ul>
<li><p>{ :ok, io<em>device } - The file has been opened in the requested mode.
                   <code>io_device</code> is actually the pid of the process which handles the file.
                   This process is linked to the process which originally opened the file.
                   If any process to which the io</em>device is linked terminates, the file will
                   be closed and the process itself will be terminated. An io_device returned
                   from this call can be used as an argument to the <code>IO</code> module functions.</p></li>
<li><p>{ :error, reason } - The file could not be opened.</p></li>
</ul>

<h2>Examples</h2>

<pre><code>{ :ok, file } = File.open(&quot;foo.tar.gz&quot;, [:read, :compressed])
IO.readline(file)
File.close(file)
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L991" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="open/3">
    <strong>open(path, modes, function)</strong>
  </p>
  <div class="docstring"><p>Similar to <code>open/2</code> but expects a function as last argument.</p>

<p>The file is opened, given to the function as argument and
automatically closed after the function returns, regardless
if there was an error or not.</p>

<p>It returns <code>{ :ok, function_result }</code> in case of success,
<code>{ :error, reason }</code> otherwise.</p>

<p>Do not use this function with :delayed_write option
since automatically closing the file may fail
(as writes are delayed).</p>

<h2>Examples</h2>

<p>File.open!(&quot;foo.txt&quot;, [:read, :write], fn(file) -&gt;
    IO.readline(file)
  end)</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L1022" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="open!/2">
    <strong>open!(path, modes // [])</strong>
  </p>
  <div class="docstring"><p>Same as <code>open/2</code> but raises an error if file could not be opened.
Returns the <code>io_device</code> otherwise.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L1038" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="open!/3">
    <strong>open!(path, modes, function)</strong>
  </p>
  <div class="docstring"><p>Same as <code>open/3</code> but raises an error if file could not be opened.
Returns the function result otherwise.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L1050" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="read/1">
    <strong>read(path)</strong>
  </p>
  <div class="docstring"><p>Returns <code>{:ok, binary}</code>, where <code>binary</code> is a binary data object that contains the contents
of <code>path</code>, or <code>{:error, reason}</code> if an error occurs.</p>

<p>Typical error reasons:</p>

<ul>
<li>:enoent  - The file does not exist.</li>
<li>:eacces  - Missing permission for reading the file,
         or for searching one of the parent directories.</li>
<li>:eisdir  - The named file is a directory.</li>
<li>:enotdir - A component of the file name is not a directory.
         On some platforms, <code>:enoent</code> is returned instead.</li>
<li>:enomem  - There is not enough memory for the contents of the file.</li>
</ul>

<p>You can use <code>Erlang.file.format_error(reason)</code> to get a descriptive string of the error.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L397" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="read!/1">
    <strong>read!(path)</strong>
  </p>
  <div class="docstring"><p>Returns binary with the contents of the given filename or raises
File.Error if an error occurs.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L405" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="regular?/1">
    <strong>regular?(path)</strong>
  </p>
  <div class="docstring"><p>Returns true if the path is a regular file.</p>

<h2>Examples</h2>

<pre><code>File.regular? __FILE__ #=&gt; true
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L143" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="rm/1">
    <strong>rm(path)</strong>
  </p>
  <div class="docstring"><p>Tries to delete the file <code>path</code>.
Returns <code>:ok</code> if successful, or <code>{:error, reason}</code> if an error occurs.</p>

<p>Typical error reasons are:</p>

<ul>
<li>:enoent  - The file does not exist.</li>
<li>:eacces  - Missing permission for the file or one of its parents.</li>
<li>:eperm   - The file is a directory and user is not super-user.</li>
<li>:enotdir - A component of the file name is not a directory.
         On some platforms, enoent is returned instead.</li>
<li>:einval  - Filename had an improper type, such as tuple.</li>
</ul>

<h2>Examples</h2>

<pre><code>File.rm(&#39;foo.txt&#39;)
#=&gt; :ok

File.rm(&#39;tmp_dir/&#39;)
#=&gt; {:error, :eperm}
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L827" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="rm!/1">
    <strong>rm!(path)</strong>
  </p>
  <div class="docstring"><p>Same as <code>rm</code>, but raises an exception in case of failure. Otherwise <code>:ok</code>.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L834" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="rm_rf/1">
    <strong>rm_rf(path)</strong>
  </p>
  <div class="docstring"><p>Remove files and directories recursively at the given <code>path</code>.
Symlinks are not followed but simply removed, non existing
files are simply ignored (i.e. doesn&#39;t make this function fail).</p>

<p>Returns <code>{ :ok, files_and_directories }</code> with all files and
directories removed in no specific order, <code>{ :error, reason }</code>
otherwise.</p>

<h2>Examples</h2>

<pre><code>File.rm_rf &quot;samples&quot;
#=&gt; { :ok, [&quot;samples&quot;, &quot;samples/1.txt&quot;] }

File.rm_rf &quot;unknown&quot;
#=&gt; { :ok, [] }
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L888" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="rm_rf!/1">
    <strong>rm_rf!(path)</strong>
  </p>
  <div class="docstring"><p>Same as <code>rm_rf/1</code> but raises <code>File.Error</code> in case of failures,
otherwise the list of files or directories removed.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L935" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="rmdir/1">
    <strong>rmdir(path)</strong>
  </p>
  <div class="docstring"><p>Tries to delete the dir at <code>path</code>.
Returns <code>:ok</code> if successful, or <code>{:error, reason}</code> if an error occurs.</p>

<h2>Examples</h2>

<pre><code>File.rddir(&#39;tmp_dir&#39;)
#=&gt; :ok

File.rmdir(&#39;foo.txt&#39;)
#=&gt; {:error, :enotdir}
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L855" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="rmdir!/1">
    <strong>rmdir!(path)</strong>
  </p>
  <div class="docstring"><p>Same as <code>rmdir/1</code>, but raises an exception in case of failure. Otherwise <code>:ok</code>.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L862" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="rootname/1">
    <strong>rootname(path)</strong>
  </p>
  <div class="docstring"><p>Returns the <code>path</code> with the <code>extension</code> stripped.</p>

<p>If the given <code>path</code> is a char list, returns a char list.
Otherwise returns a binary.</p>

<h2>Examples</h2>

<pre><code>File.rootname(&quot;/foo/bar&quot;)
#=&gt; &quot;/foo/bar&quot;
File.rootname(&quot;/foo/bar.ex&quot;)
#=&gt; &quot;/foo/bar&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L268" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="rootname/2">
    <strong>rootname(path, extension)</strong>
  </p>
  <div class="docstring"><p>Returns the <code>path</code> with the <code>extension</code> stripped. This function should be used to
remove a specific extension which might, or might not, be there.</p>

<p>If the given <code>path</code> is a char list, returns a char list.
Otherwise returns a binary.</p>

<h2>Examples</h2>

<pre><code>File.rootname(&quot;/foo/bar.erl&quot;, &quot;.erl&quot;)
#=&gt; &quot;/foo/bar&quot;
File.rootname(&quot;/foo/bar.erl&quot;, &quot;.ex&quot;)
#=&gt; &quot;/foo/bar.erl&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L287" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="split/1">
    <strong>split(path)</strong>
  </p>
  <div class="docstring"><p>Returns a list with the path splitted by the path separator.
If an empty string is given, then it returns the root path.</p>

<h2>Examples</h2>

<pre><code> File.split(&quot;&quot;)
 #=&gt; [&quot;/&quot;]
 File.split(&quot;foo&quot;)
 #=&gt; [&quot;foo&quot;]
 File.split(&quot;/foo/bar&quot;)
 #=&gt; [&quot;/&quot;, &quot;foo&quot;, &quot;bar&quot;]
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L428" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="stat/2">
    <strong>stat(path, opts // [])</strong>
  </p>
  <div class="docstring"><p>Returns information about the <code>path</code>. If it exists, it
returns a <code>{ :ok, info }</code> tuple, where info is  as a
<code>File.Info</code> record. Retuns <code>{ :error, reason }</code> with
the same reasons as <code>File.read</code> if a failure occurs.</p>

<h2>Options</h2>

<p>The accepted options are:</p>

<ul>
<li><code>:time</code> if the time should be local, universal or posix.
Default is local.</li>
</ul>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L488" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="stat!/2">
    <strong>stat!(path, opts // [])</strong>
  </p>
  <div class="docstring"><p>Same as <code>stat</code> but returns the <code>File.Stat</code> directly and
throws <code>File.Error</code> if an error is returned.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L501" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="touch/2">
    <strong>touch(path, time // calendar.local_time())</strong>
  </p>
  <div class="docstring"><p>Updates modification time (mtime) and access time (atime) of
the given file. File is created if it doesnâ€™t exist.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L533" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="touch!/2">
    <strong>touch!(path, time // calendar.local_time())</strong>
  </p>
  <div class="docstring"><p>Same as <code>touch/1</code> but raises an exception if it fails.
Returns <code>:ok</code> otherwise.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L544" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="wildcard/1">
    <strong>wildcard(glob)</strong>
  </p>
  <div class="docstring"><p>Traverses files and directories according to the given <code>glob</code> expression.</p>

<p>The wildcard string looks like an ordinary filename, except that certain
&quot;wildcard characters&quot; are interpreted in a special way. The following
characters are special:</p>

<ul>
<li><code>?</code> - Matches one character.</li>
<li><code>*</code> - Matches any number of characters up to the end of
    the filename, the next dot, or the next slash.</li>
<li><code>**</code> - Two adjacent <c>*</c>&#39;s used as a single pattern will
     match all files and zero or more directories and subdirectories.</li>
<li><code>[char1,char2,...]</code> - Matches any of the characters listed. Two characters
                    separated by a hyphen will match a range of characters.</li>
<li><code>{item1,item2,...}</code> - Matches one of the alternatives.</li>
</ul>

<p>Other characters represent themselves. Only filenames that have exactly
the same character in the same position will match. Note that matching
is case-sensitive; i.e. &quot;a&quot; will not match &quot;A&quot;.</p>

<h2>Examples</h2>

<p>Imagine you have a directory called <code>projects</code> with three Elixir projects
inside of it: <code>elixir</code>, <code>exdoc</code> and <code>dynamo</code>. You can find all <code>.beam</code> files
inside their ebin directories all projects as follows:</p>

<pre><code>File.wildcard(&quot;projects/*/ebin/**/*.beam&quot;)
</code></pre>

<p>If you want to search for both <code>.beam</code> and <code>.app</code> files, you could do:</p>

<pre><code>File.wildcard(&quot;projects/*/ebin/**/*.{beam,app}&quot;)
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L465" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="write/3">
    <strong>write(path, content, modes // [])</strong>
  </p>
  <div class="docstring"><p>Writes <code>content</code> to the file <code>path</code>. The file is created if it
does not exist. If it exists, the previous contents are overwritten.
Returns <code>:ok</code> if successful, or <code>{:error, reason}</code> if an error occurs.</p>

<p>Typical error reasons are:</p>

<ul>
<li>:enoent - A component of the file name does not exist.</li>
<li>:enotdir - A component of the file name is not a directory.
         On some platforms, enoent is returned instead.</li>
<li>:enospc - There is a no space left on the device.</li>
<li>:eacces - Missing permission for writing the file or searching one of the parent directories.</li>
<li>:eisdir - The named file is a directory.</li>
</ul>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L790" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="write!/3">
    <strong>write!(path, content, modes // [])</strong>
  </p>
  <div class="docstring"><p>Same as <code>write/3</code> but raises an exception if it fails, returns <code>:ok</code> otherwise.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L797" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="write_stat/3">
    <strong>write_stat(path, stat, opts // [])</strong>
  </p>
  <div class="docstring"><p>Writes the given <code>File.Stat</code> back to the filesystem at the given
path. Returns <code>:ok</code> or <code>{ :error, reason }</code>.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L513" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="write_stat!/3">
    <strong>write_stat!(path, stat, opts // [])</strong>
  </p>
  <div class="docstring"><p>Same as <code>write_stat/3</code> but raises an exception if it fails.
Returns <code>:ok</code> otherwise.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex#L521" target="_blank" class="view_source">Source</a>
</div>
        </div>
      

      
    </div>
  </body>
</html>
