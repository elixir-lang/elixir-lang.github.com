<!DOCTYPE html>
<html>
  <head>
    <title>File</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <h1>
        File
        
      </h1>

      
        <div id="moduledoc" class="docstring">
          <p>This module contains function to manipulate files,
filenames and the filesystem. Many of the functions
that interact with the filesystem have their naming
based on its UNIX variants. For example, deleting a
file is done with <code>File.rm</code>. Getting its stats with
<code>File.stat</code>. If you want to read or write to a file
in chunks, check the IO module.</p>

        </div>
      

      <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L1" target="_blank" class="view_source">Source</a>

      

      

      
        <h2>Functions summary</h2>
        <ul class="summary">
          <li>
  <span class="summary_signature">
    <a href="#basename/1">basename/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#basename/2">basename/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#close/1">close/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#dir?/1">dir?/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#dirname/1">dirname/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#exists?/1">exists?/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#expand_path/1">expand_path/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#expand_path/2">expand_path/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#extname/1">extname/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#join/1">join/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#join/2">join/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#mkdir/1">mkdir/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#mkdir_p/1">mkdir_p/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#open/2">open/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#read/1">read/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#read!/1">read!/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#read_info/2">read_info/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#read_info!/2">read_info!/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#regular?/1">regular?/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#rm/1">rm/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#rootname/1">rootname/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#rootname/2">rootname/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#split/1">split/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#stat/2">stat/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#stat!/2">stat!/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#wildcard/1">wildcard/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#write/3">write/3</a>
  </span>
</li>

        </ul>
      

      

      
        <div id="functions_details" class="details_list">
          <h2>Functions</h2>
          <div class="detail">
  <p class="signature" id="basename/1">
    <strong>basename(path)</strong>
  </p>
  <div class="docstring"><p>Returns the last component of the path or the path
itself if it does not contain any directory separators.</p>

<h2>Examples</h2>

<pre><code>File.basename(&quot;foo&quot;)
#=&gt; &quot;foo&quot;

File.basename(&quot;foo/bar&quot;)
#=&gt; &quot;bar&quot;

File.basename(&quot;/&quot;)
#=&gt; &quot;&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L138" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="basename/2">
    <strong>basename(path, extension)</strong>
  </p>
  <div class="docstring"><p>Returns the last component of <code>path</code> with the <code>extension</code>
stripped. This function should be used to remove a specific
extension which might, or might not, be there.</p>

<h2>Examples</h2>

<pre><code>File.basename(&quot;~/foo/bar.ex&quot;, &quot;.ex&quot;)
#=&gt; &quot;bar&quot;
File.basename(&quot;~/foo/bar.exs&quot;, &quot;.ex&quot;)
#=&gt; &quot;bar.exs&quot;
File.basename(&quot;~/foo/bar.old.ex&quot;, &quot;.ex&quot;)
#=&gt; &quot;bar.old&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L157" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="close/1">
    <strong>close(io_device)</strong>
  </p>
  <div class="docstring"><p>Closes the file referenced by <code>io_device</code>. It mostly returns <code>:ok</code>, expect
for some severe errors such as out of memory.</p>

<p>Note that if the option <code>:delayed_write</code> was used when opening the file,
<code>close/1</code> might return an old write error and not even try to close the file.
See <code>open/2</code>.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L479" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="dir?/1">
    <strong>dir?(path)</strong>
  </p>
  <div class="docstring"><p>Returns true if the path is a directory.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L97" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="dirname/1">
    <strong>dirname(path)</strong>
  </p>
  <div class="docstring"><p>Return the <code>directory</code> component of <code>path</code>.</p>

<h2>Examples</h2>

<pre><code>File.dirname(&quot;/foo/bar.ex&quot;)
#=&gt; &quot;foo&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L170" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="exists?/1">
    <strong>exists?(path)</strong>
  </p>
  <div class="docstring"><p>Returns true if the given argument exists.
It can be regular file, directory, socket,
symbolic link, named pipe or device file.</p>

<h2>Examples</h2>

<pre><code>File.exists?(&quot;test/&quot;)
#=&gt; true

File.exists?(&quot;missing.txt&quot;)
#=&gt; false

File.exists?(&quot;/dev/null&quot;)
#=&gt; true
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L118" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="expand_path/1">
    <strong>expand_path(path)</strong>
  </p>
  <div class="docstring"><p>Expands the path by returning its absolute name and expanding
any <code>.</code> and <code>..</code> characters.</p>

<h2>Examples</h2>

<pre><code>File.expand_path(&quot;/foo/bar/../bar&quot;) == &quot;/foo/bar&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L63" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="expand_path/2">
    <strong>expand_path(path, relative_to)</strong>
  </p>
  <div class="docstring"><p>Expands the path to the relative location and expanding
any <code>.</code> and <code>..</code> characters. If the path is already an
absolute path, the relative location is ignored.</p>

<h2>Examples</h2>

<pre><code>File.expand_path(&quot;foo/bar/../bar&quot;, &quot;/baz&quot;) == &quot;/baz/foo/bar&quot;
File.expand_path(&quot;/foo/bar/../bar&quot;, &quot;/baz&quot;) == &quot;/foo/bar&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L78" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="extname/1">
    <strong>extname(path)</strong>
  </p>
  <div class="docstring"><p>Return the <code>extension</code> of the last component of <code>path</code>.</p>

<h2>Examples</h2>

<pre><code>File.extname(&quot;foo.erl&quot;)
#=&gt; &quot;.erl&quot;
File.extname(&quot;~/foo/bar&quot;)
#=&gt; &quot;&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L185" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="join/1">
    <strong>join(paths)</strong>
  </p>
  <div class="docstring"><p>Returns a string with one or more paths components joint by the path separator.
This function should be used to convert a list of strings in a path.</p>

<h2>Examples</h2>

<pre><code>File.join([&quot;~&quot;, &quot;foo&quot;])
#=&gt; &quot;~/foo&quot;
File.join([&quot;foo&quot;])
#=&gt; &quot;foo&quot;
File.join([&quot;/&quot;, &quot;foo&quot;, &quot;bar&quot;])
#=&gt; &quot;/foo/bar&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L234" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="join/2">
    <strong>join(left, right)</strong>
  </p>
  <div class="docstring"><p>Join two paths.</p>

<h2>Examples</h2>

<pre><code>File.join(&quot;foo&quot;, &quot;bar&quot;)
#=&gt; &quot;foo/bar&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L247" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="mkdir/1">
    <strong>mkdir(path)</strong>
  </p>
  <div class="docstring"><p>Tries to create the directory <code>path</code>. Missing parent directories are not created.
Returns <code>:ok</code> if successful, or <code>{:error, reason}</code> if an error occurs.</p>

<p>Typical error reasons are:</p>

<ul>
<li>:eacces  - Missing search or write permissions for the parent directories of <code>path</code>.</li>
<li>:eexist  - There is already a file or directory named <code>path</code>.</li>
<li>:enoent  - A component of <code>path</code> does not exist.</li>
<li>:enospc  - There is a no space left on the device.</li>
<li>:enotdir - A component of <code>path</code> is not a directory
         On some platforms, <code>:enoent</code> is returned instead.</li>
</ul>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L264" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="mkdir_p/1">
    <strong>mkdir_p(path)</strong>
  </p>
  <div class="docstring"><p>Tries to create the directory <code>path</code>. Missing parent directories are created.
Returns <code>:ok</code> if successful, or <code>{:error, reason}</code> if an error occurs.</p>

<p>Typical error reasons are:</p>

<ul>
<li>:eacces  - Missing search or write permissions for the parent directories of <code>path</code>.</li>
<li>:enospc  - There is a no space left on the device.</li>
<li>:enotdir - A component of <code>path</code> is not a directory
         On some platforms, <code>:enoent</code> is returned instead.</li>
</ul>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L279" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="open/2">
    <strong>open(filename, options // [])</strong>
  </p>
  <div class="docstring"></div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L467" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="read/1">
    <strong>read(path)</strong>
  </p>
  <div class="docstring"><p>Returns <code>{:ok, binary}</code>, where <code>binary</code> is a binary data object that contains the contents
of <code>path</code>, or <code>{:error, reason}</code> if an error occurs.</p>

<p>Typical error reasons:</p>

<ul>
<li>:enoent  - The file does not exist.</li>
<li>:eacces  - Missing permission for reading the file,
         or for searching one of the parent directories.</li>
<li>:eisdir  - The named file is a directory.</li>
<li>:enotdir - A component of the file name is not a directory.
         On some platforms, <code>:enoent</code> is returned instead.</li>
<li>:enomem  - There is not enough memory for the contents of the file.</li>
</ul>

<p>You can use <code>Erlang.file.format_error(reason)</code> to get a descriptive string of the error.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L299" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="read!/1">
    <strong>read!(path)</strong>
  </p>
  <div class="docstring"><p>Returns binary with the contents of the given filename or raises
File.Error if an error occurs.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L307" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="read_info/2">
    <strong>read_info(path, opts // [])</strong>
  </p>
  <div class="docstring"></div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L399" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="read_info!/2">
    <strong>read_info!(path, opts // [])</strong>
  </p>
  <div class="docstring"></div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L404" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="regular?/1">
    <strong>regular?(path)</strong>
  </p>
  <div class="docstring"><p>Returns true if the path is a regular file.</p>

<h2>Examples</h2>

<pre><code>File.regular? __FILE__ #=&gt; true
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L90" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="rm/1">
    <strong>rm(filename)</strong>
  </p>
  <div class="docstring"><p>Tries to delete the file <code>filename</code>.
Returns <code>:ok</code> if successful, or <code>{:error, reason}</code> if an error occurs.</p>

<p>Typical error reasons are:</p>

<ul>
<li>:enoent  - The file does not exist.</li>
<li>:eacces  - Missing permission for the file or one of its parents.</li>
<li>:eperm   - The file is a directory and user is not super-user.</li>
<li>:enotdir - A component of the file name is not a directory.
         On some platforms, enoent is returned instead.</li>
<li>:einval  - Filename had an improper type, such as tuple.</li>
</ul>

<h2>Examples</h2>

<pre><code>File.rm(&#39;foo.txt&#39;)
#=&gt; :ok

File.rm(&#39;tmp_dir/&#39;)
#=&gt; {:error, :eperm}
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L462" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="rootname/1">
    <strong>rootname(path)</strong>
  </p>
  <div class="docstring"><p>Returns the <code>path</code> with the <code>extension</code> stripped.</p>

<h2>Examples</h2>

<pre><code>File.rootname(&quot;/foo/bar&quot;)
#=&gt; &quot;/foo/bar&quot;
File.rootname(&quot;/foo/bar.ex&quot;)
#=&gt; &quot;/foo/bar&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L200" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="rootname/2">
    <strong>rootname(path, extension)</strong>
  </p>
  <div class="docstring"><p>Returns the <code>path</code> with the <code>extension</code> stripped. This function should be used to
remove a specific extension which might, or might not, be there.</p>

<h2>Examples</h2>

<pre><code>File.rootname(&quot;/foo/bar.erl&quot;, &quot;.erl&quot;)
#=&gt; &quot;/foo/bar&quot;
File.rootname(&quot;/foo/bar.erl&quot;, &quot;.ex&quot;)
#=&gt; &quot;/foo/bar.erl&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L216" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="split/1">
    <strong>split(path)</strong>
  </p>
  <div class="docstring"><p>Returns a list with the path splitted by the path separator.
If an empty string is given, then it returns the root path.</p>

<h2>Examples</h2>

<pre><code> File.split(&quot;&quot;)
 #=&gt; [&quot;/&quot;]
 File.split(&quot;foo&quot;)
 #=&gt; [&quot;foo&quot;]
 File.split(&quot;/foo/bar&quot;)
 #=&gt; [&quot;/&quot;, &quot;foo&quot;, &quot;bar&quot;]
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L330" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="stat/2">
    <strong>stat(path, opts // [])</strong>
  </p>
  <div class="docstring"><p>Returns information about a file. If the file exists, it
returns a <code>{ :ok, info }</code> tuple, where info is  as a
<code>File.Info</code> record. Retuns <code>{ :error, reason }</code> with
the same reasons as <code>File.read</code> if a failure occurs.</p>

<h2>Options</h2>

<p>The accepted options are:</p>

<ul>
<li><code>:time</code> if the time should be local, universal or posix.
Default is local.</li>
</ul>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L390" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="stat!/2">
    <strong>stat!(path, opts // [])</strong>
  </p>
  <div class="docstring"><p>Same as <code>stat</code> but returns the <code>File.Stat</code> directly and
throws <code>File.Error</code> if an error is returned.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L413" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="wildcard/1">
    <strong>wildcard(glob)</strong>
  </p>
  <div class="docstring"><p>Traverses files and directories according to the given glob expression.</p>

<p>The wildcard string looks like an ordinary filename, except that certain
&quot;wildcard characters&quot; are interpreted in a special way. The following
characters are special:</p>

<ul>
<li><code>?</code> - Matches one character.</li>
<li><code>*</code> - Matches any number of characters up to the end of
    the filename, the next dot, or the next slash.</li>
<li><code>**</code> - Two adjacent <c>*</c>&#39;s used as a single pattern will
     match all files and zero or more directories and subdirectories.</li>
<li><code>[char1,char2,...]</code> - Matches any of the characters listed. Two characters
                    separated by a hyphen will match a range of characters.</li>
<li><code>{item1,item2,...}</code> - Matches one of the alternatives.</li>
</ul>

<p>Other characters represent themselves. Only filenames that have exactly
the same character in the same position will match. Note that matching
is case-sensitive; i.e. &quot;a&quot; will not match &quot;A&quot;.</p>

<h2>Examples</h2>

<p>Imagine you have a directory called <code>projects</code> with three Elixir projects
inside of it: <code>elixir</code>, <code>exdoc</code> and <code>dynamo</code>. You can find all <code>.beam</code> files
inside their ebin directories all projects as follows:</p>

<pre><code>File.wildcard(&quot;projects/*/ebin/**/*.beam&quot;)
</code></pre>

<p>If you want to search for both <code>.beam</code> and <code>.app</code> files, you could do:</p>

<pre><code>File.wildcard(&quot;projects/*/ebin/**/*.{beam,app}&quot;)
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L367" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="write/3">
    <strong>write(filename, content, modes // [])</strong>
  </p>
  <div class="docstring"><p>Tries to write <code>content</code> to the file <code>filename</code>. The file is created if it
does not exist. If it exists, the previous contents are overwritten.
Returns <code>:ok</code> if successful, or <code>{:error, reason}</code> if an error occurs.</p>

<p>Typical error reasons are:</p>

<ul>
<li>:enoent - A component of the file name does not exist.</li>
<li>:enotdir - A component of the file name is not a directory.
         On some platforms, enoent is returned instead.</li>
<li>:enospc - There is a no space left on the device.</li>
<li>:eacces - Missing permission for writing the file or searching one of the parent directories.</li>
<li>:eisdir - The named file is a directory.</li>
</ul>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/file.ex#L436" target="_blank" class="view_source">Source</a>
</div>
        </div>
      

      
    </div>
  </body>
</html>
