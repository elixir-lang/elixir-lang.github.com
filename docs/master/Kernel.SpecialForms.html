<!DOCTYPE html>
<html>
  <head>
    <title>Kernel.SpecialForms</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <h1>
        Kernel.SpecialForms
        
      </h1>

      
        <div id="moduledoc" class="docstring">
          <p>In this module we define Elixir special forms. Those are called
special forms because they cannot be overridden by the developer
and sometimes have lexical scope (like <code>alias</code>, <code>import</code>, etc).</p>

<p>This module also documents Elixir&#39;s pseudo variables (<code>__MODULE__</code>,
<code>__FILE__</code>, <code>__ENV__</code> and <code>__CALLER__</code>). Pseudo variables return
information about Elixir&#39;s compilation environment and can only
be read, never assigned to.</p>

<p>Finally, it also documents 3 special forms (<code>__block__</code>,
<code>__scope__</code> and <code>__aliases__</code>), which are not intended to be
called directly by the developer but they appear in quoted
contents since they are essential in Elixir&#39;s constructions.</p>

        </div>
      

      <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L1" target="_blank" class="view_source">Source</a>

      

      

      

      
        <h2>Macros summary</h2>
        <ul class="summary">
          <li>
  <span class="summary_signature">
    <a href="#&lt;&lt;&gt;&gt;/1">&lt;&lt;&gt;&gt;/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#[]/1">[]/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#__ENV__/0">__ENV__/0</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#__FILE__/0">__FILE__/0</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#__MODULE__/0">__MODULE__/0</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#__aliases__/1">__aliases__/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#__block__/1">__block__/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#__scope__/2">__scope__/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#alias/2">alias/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#bc/1">bc/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#import/2">import/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#lc/1">lc/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#quote/2">quote/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#require/2">require/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#unquote/1">unquote/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#unquote_splicing/1">unquote_splicing/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#{}/1">{}/1</a>
  </span>
</li>

        </ul>
      

      

      

      
        <div id="macros_details" class="details_list">
          <h2>Macros</h2>
          <div class="detail">
  <p class="signature" id="&lt;&lt;&gt;&gt;/1">
    <strong>&lt;&lt;&gt;&gt;(args)</strong>
  </p>
  <div class="docstring"><p>Defines a new bitstring.</p>

<h2>Examples</h2>

<pre><code>:&lt;&lt;&gt;&gt;.(1,2,3)
&lt;&lt; 1, 2, 3 &gt;&gt;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L46" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="[]/1">
    <strong>[](args)</strong>
  </p>
  <div class="docstring"><p>Defines a new list.</p>

<h2>Examples</h2>

<pre><code>:[].(1,2,3)
[ 1, 2, 3 ]
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L36" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="__ENV__/0">
    <strong>__ENV__()</strong>
  </p>
  <div class="docstring"><p>Returns the current environment information as a <code>Macro.Env</code>
record. In the environment you can access the current filename,
line numbers, set up aliases, the current function and others.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L184" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="__FILE__/0">
    <strong>__FILE__()</strong>
  </p>
  <div class="docstring"><p>Returns the current file name as a binary.
Although the file can be accessed in the <strong>ENV</strong>, this macro
is a convenient shortcut.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L198" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="__MODULE__/0">
    <strong>__MODULE__()</strong>
  </p>
  <div class="docstring"><p>Returns the current module name as an atom or nil otherwise.
Although the module can be accessed in the <strong>ENV</strong>, this macro
is a convenient shortcut.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L191" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="__aliases__/1">
    <strong>__aliases__(args)</strong>
  </p>
  <div class="docstring"><p>This is the special form used to hold aliases information.
At compilation time, it is usually compiled to an atom:</p>

<pre><code>quote do: Foo.Bar
{ :__aliases__, 0, [:Foo,:Bar] }
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L451" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="__block__/1">
    <strong>__block__(args)</strong>
  </p>
  <div class="docstring"><p>This is the special form used whenever we have a block
of expressions in Elixir. This special form is private
and should not be invoked directly:</p>

<pre><code>quote do: (1; 2; 3)
#=&gt; { :__block__, 0, [1,2,3] }
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L428" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="__scope__/2">
    <strong>__scope__(opts, args)</strong>
  </p>
  <div class="docstring"><p>This is the special form used whenever we have to temporarily
change the scope information of a block. Used when <code>quote</code> is
invoked with <code>location: :keep</code> to execute a given block as if
it belonged to another file.</p>

<pre><code>quote location: :keep, do: 1
#=&gt; { :__scope__, 1,[[file: &quot;iex&quot;],[do: 1]] }
</code></pre>

<p>Check <code>quote/1</code> for more information.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L441" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="alias/2">
    <strong>alias(module, opts)</strong>
  </p>
  <div class="docstring"><p><code>alias</code> is used to setup atom aliases, often useful with modules names.</p>

<h2>Examples</h2>

<p><code>alias</code> can be used to setup an alias for any module:</p>

<pre><code>defmodule Math do
  alias MyKeyword, as: Keyword
end
</code></pre>

<p>In the example above, we have set up <code>MyOrdict</code> to be alias
as <code>Keyword</code>. So now, any reference to <code>Keyword</code> will be
automatically replaced by <code>MyKeyword</code>.</p>

<p>In case one wants to access the original <code>Keyword</code>, it can be done
by accessing Elixir:</p>

<pre><code>Keyword.values   #=&gt; uses MyKeyword.values
Elixir.Keyword.values #=&gt; uses Keyword.values
</code></pre>

<p>Notice that calling <code>alias</code> without the <code>as:</code> option automatically
sets an alias based on the last part of the module. For example:</p>

<pre><code>alias Foo.Bar.Baz
</code></pre>

<p>Is the same as:</p>

<pre><code>alias Foo.Bar.Baz, as: Baz
</code></pre>

<h2>Lexical scope</h2>

<p><code>import</code>, <code>require</code> and <code>alias</code> are called directives and all
have lexical scope. This means you can set up aliases inside
specific functions and it won&#39;t affect the overall scope.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L84" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="bc/1">
    <strong>bc(args)</strong>
  </p>
  <div class="docstring"><p>Defines a bit comprehension. It follows the same syntax as
a list comprehension but expects each element returned to
be a bitstring. For example, here is how to remove all
spaces from a string:</p>

<pre><code>bc &lt;&lt;c&gt;&gt; inbits &quot; hello world &quot;, c != ? , do: &lt;&lt;c&gt;&gt;
&quot;helloworld&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L417" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="import/2">
    <strong>import(module, opts)</strong>
  </p>
  <div class="docstring"><p><code>import</code> allows one to easily access functions or macros from
others modules without using the qualified name.</p>

<h2>Examples</h2>

<p>If you want to use the <code>values</code> function from <code>Keyword</code> several times
in your module and you don&#39;t want to always type <code>Keyword.values</code>,
you can simply import it:</p>

<pre><code>defmodule Math do
  import Keyword, only: [values: 1]

  def some_function do
    # call values(orddict)
  end
end
</code></pre>

<p>In this case, we are importing only the function <code>values</code> (with arity 1)
from <code>Keyword</code>. Although <code>only</code> is optional, its usage is recommended.
<code>except</code> could also be given as an option. If no option is given, all
functions and macros are imported.</p>

<p>In case you want to import only functions or macros, you can pass a
first argument selecting the scope:</p>

<pre><code>import :macros, MyMacros
</code></pre>

<p>And you can then use <code>only</code> or <code>except</code> to filter the macros being
included. By default, Elixir won&#39;t import functions or macros that
start with underscore. Underscored functions can be explicitly turned
on by passing <code>underscored: true</code>.</p>

<h2>Lexical scope</h2>

<p>It is important to notice that <code>import</code> is lexical. This means you
can import specific macros inside specific functions:</p>

<pre><code>defmodule Math do
  def some_function do
    # 1) Disable `if/2` from Kernel
    import Kernel, except: [if: 2]

    # 2) Require the new `if` macro from MyMacros
    import MyMacros

    # 3) Use the new macro
    if do_something, it_works
  end
end
</code></pre>

<p>In the example above, we imported macros from <code>MyMacros</code>, replacing
the original <code>if/2</code> implementation by our own during that
specific function. All other functions in that module will still
be able to use the original one.</p>

<h2>Alias/Require shortcut</h2>

<p>All imported modules are also required by default. <code>import</code>
also accepts <code>as:</code> as an option so it automatically sets up
an alias. Please check <code>alias</code> for more information.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L177" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="lc/1">
    <strong>lc(args)</strong>
  </p>
  <div class="docstring"><p>List comprehensions allow you to quickly build a list from another list:</p>

<pre><code>lc n inlist [1,2,3,4], do: n * 2
#=&gt; [2,4,6,8]
</code></pre>

<p>A comprehension accepts many generators and also filters. Generators
are defined using both <code>inlist</code> and <code>inbits</code> operators, allowing you
to loop lists and bitstrings:</p>

<pre><code># A list generator:
lc n inlist [1,2,3,4], do: n * 2
#=&gt; [2,4,6,8]

# A bit string generator:
lc &lt;&lt;n&gt;&gt; inbits &lt;&lt;1,2,3,4&gt;&gt;, do: n * 2
#=&gt; [2,4,6,8]

# A generator from a variable:
list = [1,2,3,4]
lc n inlist list, do: n * 2
#=&gt; [2,4,6,8]

# A comprehension with two generators
lc x inlist [1,2], y inlist [2,3], do: x*y
#=&gt; [2,3,4,6]
</code></pre>

<p>Filters can also be given:</p>

<pre><code># A comprehension with a generator and a filter
lc n inlist [1,2,3,4,5,6], rem(n, 2) == 0, do: n
#=&gt; [2,4,6]
</code></pre>

<p>Bit string generators are quite useful when you need to
organize bit string streams:</p>

<pre><code>iex&gt; pixels = &lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;
iex&gt; lc &lt;&lt;r:8,g:8,b:8&gt;&gt; inbits pixels, do: {r,g,b}
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L405" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="quote/2">
    <strong>quote(opts, list2)</strong>
  </p>
  <div class="docstring"><p>Allows you to get the representation of any expression.</p>

<h2>Examples</h2>

<pre><code>quote do: sum(1, 2, 3)
#=&gt; { :sum, 0, [1, 2, 3] }
</code></pre>

<h2>Program representation</h2>

<p>The building block of an Elixir program is a tuple with three elements,
for example:</p>

<pre><code>{ :sum, 1, [1, 2, 3] }
</code></pre>

<p>The tuple above represents a function call to sum passing 1, 2 and
3 as arguments. The tuple elements are:</p>

<ul>
<li>The first element of the tuple is always an atom or
another tuple in the same representation;</li>
<li>The second element of the tuple is always an integer
representing the line number;</li>
<li>The third element of the tuple are the arguments for the
function call. The third argument may be an atom, meaning
that it may be a variable.</li>
</ul>

<h2>Macro literals</h2>

<p>Besides the tuple described above, Elixir has a few literals that
when quoted return themselves. They are:</p>

<pre><code>:sum         #=&gt; Atoms
1            #=&gt; Integers
2.0          #=&gt; Floats
[1,2]        #=&gt; Lists
&quot;binaries&quot;   #=&gt; Binaries
{key, value} #=&gt; Tuple with two elements
</code></pre>

<h2>Hygiene</h2>

<p>Elixir macros are hygienic regarding to variables. This means
a variable defined in a macro cannot affect the scope where
the macro is included. Consider the following example:</p>

<pre><code>defmodule Hygiene do
  defmacro no_interference do
    quote do: a = 1
  end
end

require Hygiene

a = 10
Hygiene.no_interference
a #=&gt; 10
</code></pre>

<p>In the example above, <code>a</code> returns 10 even if the macro
is apparently setting it to 1 because the variables defined
in the macro does not affect the context the macro is
executed. If you want to set or get a variable, you can do
it with the help of the <code>var!</code> macro:</p>

<pre><code>defmodule NoHygiene do
  defmacro interference do
    quote do: var!(a) = 1
  end
end

require NoHygiene

a = 10
NoHygiene.interference
a #=&gt; 11
</code></pre>

<p>Notice that aliases are not hygienic in Elixir, ambiguity
must be solved by prepending Elixir:</p>

<pre><code>quote do
  Elixir.Foo #=&gt; Access the root Foo
  Foo        #=&gt; Access the Foo alias in the current module
                 (if any is set), then fallback to Elixir.Foo
end
</code></pre>

<h2>Options</h2>

<ul>
<li><code>:hygiene</code> - When false, disables hygiene;</li>
<li><code>:unquote</code> - When false, disables unquoting. Useful when you have a quote
inside another quote and want to control which quote is able to unquote;</li>
<li><code>:location</code> - When set to <code>:keep</code>, keeps the current line and file on quotes.
            Read the Stacktrace information section below for more information;</li>
</ul>

<h2>Stacktrace information</h2>

<p>One of Elixir goals is to provide proper stacktrace whenever there is an
exception. In order to work properly with macros, the default behavior
in quote is to set the line to 0. When a macro is invoked and the quoted
expressions is expanded, 0 is replaced by the line of the call site.</p>

<p>This is a good behavior for the majority of the cases, except if the macro
is defining new functions. Consider this example:</p>

<pre><code>defmodule MyServer do
  use GenServer.Behaviour
end
</code></pre>

<p><code>GenServer.Behaviour</code> defines new functions in our <code>MyServer</code> module.
However, if there is an exception in any of these functions, we want
the stacktrace to point to the <code>GenServer.Behaviour</code> and not the line
that calls <code>use GenServer.Behaviour</code>. For this reason, there is an
option called <code>:location</code> that when set to <code>:keep</code> keeps these proper
semantics:</p>

<pre><code>quote location: :keep do
  def handle_call(request, _from, state) do
    { :reply, :undef, state }
  end
end
</code></pre>

<p>It is important to warn though that <code>location: :keep</code> evaluates the
code as if it was defined inside <code>GenServer.Behaviour</code> file, in
particular, the macro <code>__FILE__</code> will always point to
<code>GenServer.Behaviour</code> file.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L324" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="require/2">
    <strong>require(module, opts)</strong>
  </p>
  <div class="docstring"><p><code>require</code> is used to require the presence of external
modules so macros can be invoked.</p>

<h2>Examples</h2>

<p>Notice that usually modules should not be required before usage,
the only exception is if you want to use the macros from a module.
In such cases, you need to explicitly require them.</p>

<p>Let&#39;s suppose you created your own <code>if</code> implementation in the module
<code>MyMacros</code>. If you want to invoke it, you need to first explicitly
require the <code>MyMacros</code>:</p>

<pre><code>defmodule Math do
  require MyMacros
  MyMacros.if do_something, it_works
end
</code></pre>

<p>An attempt to call a macro that was not loaded will raise an error.</p>

<h2>Alias shortcut</h2>

<p><code>require</code> also accepts <code>as:</code> as an option so it automatically sets
up an alias. Please check <code>alias</code> for more information.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L113" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="unquote/1">
    <strong>unquote(expr)</strong>
  </p>
  <div class="docstring"><p>Unquotes the given expression from inside a macro.</p>

<h2>Examples</h2>

<p>Imagine the situation you have a variable <code>name</code> and
you want to inject it inside some quote. The first attempt
would be:</p>

<pre><code>value = 13
quote do: sum(1, value, 3)
</code></pre>

<p>Which would then return:</p>

<pre><code>{ :sum, 0, [1, { :value, 0, quoted }, 3] }
</code></pre>

<p>Which is not the expected result. For this, we use unquote:</p>

<pre><code>value = 13
quote do: sum(1, unquote(value), 3)
#=&gt; { :sum, 0, [1, 13, 3] }
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L349" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="unquote_splicing/1">
    <strong>unquote_splicing(expr)</strong>
  </p>
  <div class="docstring"><p>Unquotes the given list expanding its arguments. Similar
to unquote.</p>

<h2>Examples</h2>

<pre><code>values = [2,3,4]
quote do: sum(1, unquote_splicing(values), 5)
#=&gt; { :sum, 0, [1, 2, 3, 4, 5] }
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L362" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="{}/1">
    <strong>{}(args)</strong>
  </p>
  <div class="docstring"><p>Defines a new tuple.</p>

<h2>Examples</h2>

<pre><code>:{}.(1,2,3)
{ 1, 2, 3 }
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/kernel/special_forms.ex#L26" target="_blank" class="view_source">Source</a>
</div>
        </div>
      

      
    </div>
  </body>
</html>
