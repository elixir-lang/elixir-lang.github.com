<!DOCTYPE html>
<html>
  <head>
    <title>Regex</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <h1>
        Regex
        
      </h1>

      
        <div id="moduledoc" class="docstring">
          <p>Regular expressions for Elixir built on top of the re module
in the Erlang Standard Library. More information can be found
on re documentation: <a href="http://www.erlang.org/doc/man/re.html">http://www.erlang.org/doc/man/re.html</a></p>

<p>Regular expressions in Elixir can be created using Regex.compile!
or using the special form with <code>%r</code>:</p>

<pre><code># A simple regular expressions that matches foo anywhere in the string
%r/foo/

# A regular expression with case insensitive options and handle unicode chars
%r/foo/iu
</code></pre>

<p>The re module provides several options, the one available in Elixir, followed by
their shortcut in parenthesis, are:</p>

<ul>
<li>unicode (u) - enable unicode specific patterns like \p</li>
<li>caseless (i) - add case insensitivity</li>
<li>dotall (s) - causes dot to match newlines and also set newline to anycrlf.
The new line setting can be overwritten by setting <code>(*CR)</code> or <code>(*LF)</code> or
<code>(*CRLF)</code> or <code>(*ANY)</code> according to re documentation</li>
<li>multiline (m) - causes <code>^</code> and <code>$</code> to mark the beginning and end of each line.
You need to use <code>\A</code> and <code>\z</code> to match the end or beginning of the string</li>
<li>extended (x) - whitespace characters are ignored except when escaped and
allow <code>#</code> to delimit comments</li>
<li>firstline (f) - forces the unanchored pattern to match before or at the first
newline, though the matched text may continue over the newline</li>
<li>ungreedy (r) - invert the &quot;greediness&quot; of the regexp</li>
<li>groups (g) - compile with info about groups available</li>
</ul>

<p>The options not available are:</p>

<ul>
<li>anchored - not available, use <code>^</code> or <code>\A</code> instead</li>
<li>dollar_endonly - not available, use <code>\z</code> instead</li>
<li>no<em>auto</em>capture - not available, use <code>?:</code> instead</li>
<li>newline - not available, use <code>(*CR)</code> or <code>(*LF)</code> or <code>(*CRLF)</code> or <code>(*ANYCRLF)</code>
or <code>(*ANY)</code> at the beginning of the regexp according to the re documentation</li>
</ul>

<p>Most of the functions in this module accept either a binary or a char list
as subject. The result is based on the argument (a binary will return
a binary, a char list will return a char list).</p>

        </div>
      

      <a href="https://github.com/elixir-lang/elixir/blob/87da4e91bbcf3d6b25a7709ba82b428ddbfcdcf7/lib/elixir/lib/regex.ex#L1" target="_blank" class="view_source">Source</a>

      

      

      
        <h2 id="functions_summary">Functions summary</h2>
        <ul class="summary">
          <li>
  <span class="summary_signature">
    <a href="#captures/3">captures/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#compile/2">compile/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#compile!/2">compile!/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#escape/1">escape/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#groups/1">groups/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#match?/2">match?/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#opts/1">opts/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#re_pattern/1">re_pattern/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#replace/4">replace/4</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#run/3">run/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#scan/3">scan/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#source/1">source/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#split/3">split/3</a>
  </span>
</li>

        </ul>
      

      

      

      
        <div id="functions_details" class="details_list">
          <h2>Functions</h2>
          <div class="detail">
  <p class="signature" id="captures/3">
    <strong>captures(regex, string, options // [])</strong>
  </p>
  <div class="docstring"><p>Returns the given captures as a list of tuples.
Requires the regex to be compiled with the groups option.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Regex.captures(%r/c(?&lt;foo&gt;d)/g, &quot;abcd&quot;)
[foo: &quot;d&quot;]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/87da4e91bbcf3d6b25a7709ba82b428ddbfcdcf7/lib/elixir/lib/regex.ex#L140" target="_blank" class="view_source">Source</a>
  
</div><div class="detail">
  <p class="signature" id="compile/2">
    <strong>compile(source, options // &quot;&quot;)</strong>
  </p>
  <div class="docstring"><p>Compiles the regular expression according to the given options.</p>

<p>It returns <code>{ :ok, regex }</code> in case of success,
<code>{ :error, reason }</code> otherwise.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/87da4e91bbcf3d6b25a7709ba82b428ddbfcdcf7/lib/elixir/lib/regex.ex#L57" target="_blank" class="view_source">Source</a>
  
</div><div class="detail">
  <p class="signature" id="compile!/2">
    <strong>compile!(source, options // &quot;&quot;)</strong>
  </p>
  <div class="docstring"><p>Compiles the regular expression according to the given options.
Fails with <code>Regex.CompileError</code> if the regex cannot be compiled.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/87da4e91bbcf3d6b25a7709ba82b428ddbfcdcf7/lib/elixir/lib/regex.ex#L75" target="_blank" class="view_source">Source</a>
  
</div><div class="detail">
  <p class="signature" id="escape/1">
    <strong>escape(string)</strong>
  </p>
  <div class="docstring"><p>Escapes a string to be literally matched in a regex.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Regex.escape(&quot;.&quot;)
&quot;\\.&quot;
iex&gt; Regex.escape(&quot;\\what if&quot;)
&quot;\\\\what\\ if&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/87da4e91bbcf3d6b25a7709ba82b428ddbfcdcf7/lib/elixir/lib/regex.ex#L291" target="_blank" class="view_source">Source</a>
  
</div><div class="detail">
  <p class="signature" id="groups/1">
    <strong>groups(arg1)</strong>
  </p>
  <div class="docstring"><p>Returns list of named groups in regex.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Regex.groups(%r/(?&lt;foo&gt;foo)/g)
[:foo]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/87da4e91bbcf3d6b25a7709ba82b428ddbfcdcf7/lib/elixir/lib/regex.ex#L195" target="_blank" class="view_source">Source</a>
  
</div><div class="detail">
  <p class="signature" id="match?/2">
    <strong>match?(arg1, string)</strong>
  </p>
  <div class="docstring"><p>Returns a boolean if there was a match or not.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Regex.match?(%r/foo/, &quot;foo&quot;)
true
iex&gt; Regex.match?(%r/foo/, &quot;bar&quot;)
false
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/87da4e91bbcf3d6b25a7709ba82b428ddbfcdcf7/lib/elixir/lib/regex.ex#L93" target="_blank" class="view_source">Source</a>
  
</div><div class="detail">
  <p class="signature" id="opts/1">
    <strong>opts(arg1)</strong>
  </p>
  <div class="docstring"><p>Returns the regex options as a string.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Regex.opts(%r(foo)m)
&quot;m&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/87da4e91bbcf3d6b25a7709ba82b428ddbfcdcf7/lib/elixir/lib/regex.ex#L182" target="_blank" class="view_source">Source</a>
  
</div><div class="detail">
  <p class="signature" id="re_pattern/1">
    <strong>re_pattern(arg1)</strong>
  </p>
  <div class="docstring"><p>Returns the underlying <code>re_pattern</code> in the regular expression.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/87da4e91bbcf3d6b25a7709ba82b428ddbfcdcf7/lib/elixir/lib/regex.ex#L156" target="_blank" class="view_source">Source</a>
  
</div><div class="detail">
  <p class="signature" id="replace/4">
    <strong>replace(arg1, string, replacement, options // [])</strong>
  </p>
  <div class="docstring"><p>Receives a regex, a binary and a replacement and returns a new
binary where the all matches are replaced by replacement.</p>

<p>Inside the replacement, you can either give &quot;&amp;&quot; to access the
whole regular expression or \N, where N is in integer to access
a specific matching parens. You can also set global to false
if you want to replace just the first occurrence.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Regex.replace(%r/d/, &quot;abc&quot;, &quot;d&quot;)
&quot;abc&quot;
iex&gt; Regex.replace(%r/b/, &quot;abc&quot;, &quot;d&quot;)
&quot;adc&quot;
iex&gt; Regex.replace(%r/b/, &quot;abc&quot;, &quot;[&amp;]&quot;)
&quot;a[b]c&quot;
iex&gt; Regex.replace(%r/b/, &quot;abc&quot;, &quot;[\\&amp;]&quot;)
&quot;a[&amp;]c&quot;
iex&gt; Regex.replace(%r/(b)/, &quot;abc&quot;, &quot;[\\1]&quot;)
&quot;a[b]c&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/87da4e91bbcf3d6b25a7709ba82b428ddbfcdcf7/lib/elixir/lib/regex.ex#L269" target="_blank" class="view_source">Source</a>
  
</div><div class="detail">
  <p class="signature" id="run/3">
    <strong>run(regex, string, options // [])</strong>
  </p>
  <div class="docstring"><p>Runs the regular expression against the given string.
It returns a list with all matches, nil if no match ocurred, or []
if it matched, /g was specified, but nothing was captured.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Regex.run(%r/c(d)/, &quot;abcd&quot;)
[&quot;cd&quot;, &quot;d&quot;]
iex&gt; Regex.run(%r/e/, &quot;abcd&quot;)
nil
iex&gt; Regex.run(%r/c(d)/, &quot;abcd&quot;, return: :index)
[{2,2},{3,1}]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/87da4e91bbcf3d6b25a7709ba82b428ddbfcdcf7/lib/elixir/lib/regex.ex#L112" target="_blank" class="view_source">Source</a>
  
</div><div class="detail">
  <p class="signature" id="scan/3">
    <strong>scan(regex, string, options // [])</strong>
  </p>
  <div class="docstring"><p>Same as run, but scans the target several times collecting all matches of
the regular expression. A list is returned with each match. If the item in
the list is a binary, it means there were no captures. If the item is another
list, each element in this secondary list is a capture.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Regex.scan(%r/c(d|e)/, &quot;abcd abce&quot;)
[[&quot;d&quot;], [&quot;e&quot;]]
iex&gt; Regex.scan(%r/c(?:d|e)/, &quot;abcd abce&quot;)
[&quot;cd&quot;, &quot;ce&quot;]
iex&gt; Regex.scan(%r/e/, &quot;abcd&quot;)
[]
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/87da4e91bbcf3d6b25a7709ba82b428ddbfcdcf7/lib/elixir/lib/regex.ex#L215" target="_blank" class="view_source">Source</a>
  
</div><div class="detail">
  <p class="signature" id="source/1">
    <strong>source(arg1)</strong>
  </p>
  <div class="docstring"><p>Returns the regex source as binary.</p>

<h2>Examples</h2>

<pre><code>iex&gt; Regex.source(%r(foo))
&quot;foo&quot;
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/87da4e91bbcf3d6b25a7709ba82b428ddbfcdcf7/lib/elixir/lib/regex.ex#L169" target="_blank" class="view_source">Source</a>
  
</div><div class="detail">
  <p class="signature" id="split/3">
    <strong>split(regex, string, options // [])</strong>
  </p>
  <div class="docstring"><p>Split the given target in the number of parts specified.
If no ammount of parts is given, it defaults to :infinity.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/87da4e91bbcf3d6b25a7709ba82b428ddbfcdcf7/lib/elixir/lib/regex.ex#L231" target="_blank" class="view_source">Source</a>
  
</div>
        </div>
      

      

      
    </div>
  </body>
</html>
