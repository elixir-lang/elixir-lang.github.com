<!DOCTYPE html>
<html>
  <head>
    <title>Code</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <h1>
        Code
        
      </h1>

      
        <div id="moduledoc" class="docstring">
          <p>The Code module is responsible to manage code compilation,
code evaluation and code loading.</p>

<p>It complements (Erlang&#39;s code module)<a href="(www.erlang.org/doc/man/code.html)">1</a> to add behavior
which is specific to Elixir.</p>

        </div>
      

      <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L1" target="_blank" class="view_source">Source</a>

      

      

      
        <h2>Functions summary</h2>
        <ul class="summary">
          <li>
  <span class="summary_signature">
    <a href="#append_path/1">append_path/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#compile_string/2">compile_string/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#compiler_options/0">compiler_options/0</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#compiler_options/1">compiler_options/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#ensure_compiled/1">ensure_compiled/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#ensure_loaded/1">ensure_loaded/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#eval/3">eval/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#eval_quoted/3">eval_quoted/3</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#load_file/2">load_file/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#loaded_files/0">loaded_files/0</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#prepend_path/1">prepend_path/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#require_file/2">require_file/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#string_to_ast/2">string_to_ast/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#string_to_ast!/2">string_to_ast!/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#unload_files/1">unload_files/1</a>
  </span>
</li>

        </ul>
      

      

      
        <div id="functions_details" class="details_list">
          <h2>Functions</h2>
          <div class="detail">
  <p class="signature" id="append_path/1">
    <strong>append_path(path)</strong>
  </p>
  <div class="docstring"><p>Appends a path to Erlang VM code path.
The path is expanded with <code>File.expand_path</code> before added.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L34" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="compile_string/2">
    <strong>compile_string(string, file // &quot;nofile&quot;)</strong>
  </p>
  <div class="docstring"><p>Compiles the given string and returns a list of tuples where
the first element is the module name and the second one is its
binary.</p>

<p>For compiling many files at once, check <code>Kernel.ParallelCompiler</code>.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L235" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="compiler_options/0">
    <strong>compiler_options()</strong>
  </p>
  <div class="docstring"><p>Loads the compilation options from the code server.
Check compiler_options/1 for more information.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L205" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="compiler_options/1">
    <strong>compiler_options(opts)</strong>
  </p>
  <div class="docstring"><p>Sets compilation options. Those options are global
since they are stored by Elixir&#39;s Code Server.</p>

<p>Available options are:</p>

<ul>
<li>docs       - when true, retain documentation in the compiled module.
           True by default;</li>
<li>debug_info - when true, retain debug information in the compiled module.
           This allows a developer to reconstruct the original source
           code, for such reasons, false by default;</li>
<li>ignore<em>module</em>conflict - when true, override modules that were already defined
                       without raising errors, false by default;</li>
</ul>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L224" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="ensure_compiled/1">
    <strong>ensure_compiled(module)</strong>
  </p>
  <div class="docstring"><p>Ensures the given module is compiled and loaded. If the module
is already loaded, it works as no-op. If the module was not
loaded yet, it checks if it needs to be compiled first and just
then tries to load it.</p>

<p>If it succeeds loading the module anyhow, it returns
<code>{ :module, module }</code>. If not, returns <code>{ :error, reason }</code> with
the error reason.</p>

<p>Check <code>ensure_loaded/1</code> for more information on module loading
and when to use <code>ensure_loaded/1</code> or <code>ensure_compiled/1</code>.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L294" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="ensure_loaded/1">
    <strong>ensure_loaded(module)</strong>
  </p>
  <div class="docstring"><p>Ensures the given module is loaded. If the module is already
loaded, it works as no-op. If the module was not loaded yet,
it tries to load it.</p>

<p>If it succeeds loading the module anyhow, it returns
<code>{ :module, module }</code>. If not, returns <code>{ :error, reason }</code> with
the error reason.</p>

<h2>Code loading on the Erlang VM</h2>

<p>Erlang has two modes to load code: interactive and embedded.</p>

<p>By default, the Erlang VM runs on interactive mode, where modules
are loaded as needed. In embedded mode the opposite happens, as all
modules need to be loaded upfront or explicitly.</p>

<p>Therefore, this function is useful to check if a module is loaded
before using it and react accordingly. For example, the <code>URI</code> module
uses this function to check if a specific parser exists and is for the
given URI scheme.</p>

<h2>Code.ensure_compiled</h2>

<p>Elixir also contains an <code>ensure_compiled/1</code> function that is a
superset of <code>ensure_loaded/1</code>.</p>

<p>Since Elixir&#39;s compilation happens in parallel, in some situations
you may need to use a module but it was not compiled yet, therefore
it can&#39;t even be loaded.</p>

<p><code>ensure_compiled/1</code> puts a halt in the current process until the
module we are depending on is available.</p>

<p>In most of the cases, <code>ensure_loaded</code> is enough. <code>ensure_compiled</code>
must be used just in same rare conditions, usually involving macros
that needs to invoke a module for callback information.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L277" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="eval/3">
    <strong>eval(string, binding // [], opts // [])</strong>
  </p>
  <div class="docstring"><p>Evalutes the contents given by string. The second argument is the binding
(which should be a Keyword) followed by a keyword list of options. The
options can be:</p>

<ul>
<li><code>:file</code> - the file to be considered in the evaluation</li>
<li><code>:line</code> - the line the script starts</li>
<li><code>:delegate_locals_to</code> - delegate local calls to the given module,
otherwise functions are evaluated inside Erlang&#39;s default scope.</li>
</ul>

<h2>Examples</h2>

<pre><code>Code.eval &quot;a + b&quot;, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line
#=&gt; { 3, [ {:a, 1}, {:b, 2} ] }
</code></pre>

<p>When passing the <strong>ENV</strong>&#39;s file and line, we could simply get
the location which already returns both fields as a keywords lists:</p>

<pre><code>Code.eval &quot;a + b&quot;, [a: 1, b: 2], __ENV__.location
#=&gt; { 3, [ {:a, 1}, {:b, 2} ] }
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L68" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="eval_quoted/3">
    <strong>eval_quoted(quoted, binding // [], opts // [])</strong>
  </p>
  <div class="docstring"><p>Evalutes the quoted contents.</p>

<h2>Options</h2>

<p>This function accepts a list of options. The supported
options are:</p>

<ul>
<li><p><code>:file</code> - The filename to be used in stacktraces
and the file reported in the <strong>ENV</strong> variable.</p></li>
<li><p><code>:line</code> - The line reported in the <strong>ENV</strong> variable.</p></li>
</ul>

<h2>Examples</h2>

<pre><code>contents = quote hygiene: false, do: a + b

Code.eval_quoted contents, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line
#=&gt; { 3, [ {:a, 1}, {:b, 2} ] }
</code></pre>

<p>When passing the <strong>ENV</strong>&#39;s file and line, we could simply get
the location which already returns both fields as a keywords lists:</p>

<pre><code>Code.eval_quoted contents, [a: 1, b: 2], __ENV__.location
#=&gt; { 3, [ {:a, 1}, {:b, 2} ] }
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L101" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="load_file/2">
    <strong>load_file(file, relative_to // nil)</strong>
  </p>
  <div class="docstring"><p>Loads the given <code>file</code>. Accepts <code>relative_to</code> as an argument
to tell where the file is located. If the file was already
required/loaded, loads it again. It returns all the modules
defined in the file.</p>

<p>Notice that if <code>load_file</code> is invoked by different processes
concurrently, the target file will be invoked concurrently
in many times. I.e. if <code>load_file</code> is called N times with
a given file, the given file will be loaded N times. Check
<code>require_file</code> if you don&#39;t want a file to be loaded concurrently.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L166" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="loaded_files/0">
    <strong>loaded_files()</strong>
  </p>
  <div class="docstring"><p>Returns all the loaded files.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L16" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="prepend_path/1">
    <strong>prepend_path(path)</strong>
  </p>
  <div class="docstring"><p>Prepends a path to Erlang VM code path.
The path is expanded with <code>File.expand_path</code> before added.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L42" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="require_file/2">
    <strong>require_file(file, relative_to // nil)</strong>
  </p>
  <div class="docstring"><p>Requires the given <code>file</code>. Accepts <code>relative_to</code> as an argument
to tell where the file is located. If the file was already
required/loaded, loads it again. It returns all the modules
defined in the file.</p>

<p>Notice that if <code>require_file</code> is invoked by different processes
concurrently, the first process to invoke <code>require_file</code> acquires
a lock and the remaining ones will block until the file is
available. I.e. if <code>require_file</code> is called N times with a given
file, the given file will be loaded only once. Check <code>load_file</code>
if you want a file to be loaded concurrently.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L187" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="string_to_ast/2">
    <strong>string_to_ast(string, opts // [])</strong>
  </p>
  <div class="docstring"><p>Converts the given string to AST. It returns { :ok, ast }
if it succeeds, { :error, { line, error, token } } otherwise.</p>

<h2>Options</h2>

<ul>
<li><p><code>:file</code> - The filename to be used in stacktraces
and the file reported in the <strong>ENV</strong> variable.</p></li>
<li><p><code>:line</code> - The line reported in the <strong>ENV</strong> variable.</p></li>
</ul>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L119" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="string_to_ast!/2">
    <strong>string_to_ast!(string, opts // [])</strong>
  </p>
  <div class="docstring"><p>Converts the given string to AST. It returns the ast if it succeeds,
raises an exception otherwise. The exception is a TokenMissingError
in case a token is missing (usually because the expression is incomplete),
SyntaxError otherwise.</p>

<h2>Options</h2>

<ul>
<li><p><code>:file</code> - The filename to be used in stacktraces
and the file reported in the <strong>ENV</strong> variable.</p></li>
<li><p><code>:line</code> - The line reported in the <strong>ENV</strong> variable.</p></li>
</ul>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L143" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="unload_files/1">
    <strong>unload_files(files)</strong>
  </p>
  <div class="docstring"><p>Removes the given files from the loaded files list.
The modules defined in the file are not removed,
calling this function only removes it from the list,
allowing it to be required again.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/code.ex#L26" target="_blank" class="view_source">Source</a>
</div>
        </div>
      

      
    </div>
  </body>
</html>
