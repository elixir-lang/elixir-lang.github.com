<!DOCTYPE html>
<html>
  <head>
    <title>Elixir.SpecialForms</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <h1>
        Elixir.SpecialForms
        
      </h1>

      
        <div id="moduledoc" class="docstring">
          <p>In this module we define Elixir special forms. Those are called
special forms because they cannot be overridden by the developer
and sometimes have lexical scope (like refer, require, import, etc).</p>

        </div>
      

      <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L1" target="_blank" class="view_source">Source</a>

      

      

      

      
        <h2>Macros summary</h2>
        <ul class="summary">
          <li>
  <span class="summary_signature">
    <a href="#&lt;&lt;&gt;&gt;/1">&lt;&lt;&gt;&gt;/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#[]/1">[]/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#__FILE__/0">__FILE__/0</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#__FUNCTION__/0">__FUNCTION__/0</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#__LINE__/0">__LINE__/0</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#__MODULE__/0">__MODULE__/0</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#bc/1">bc/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#fn/1">fn/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#import/2">import/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#in_guard/1">in_guard/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#lc/1">lc/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#loop/1">loop/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#quote/2">quote/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#recur/1">recur/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#refer/2">refer/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#require/2">require/2</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#unquote/1">unquote/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#unquote_splicing/1">unquote_splicing/1</a>
  </span>
</li>
<li>
  <span class="summary_signature">
    <a href="#{}/1">{}/1</a>
  </span>
</li>

        </ul>
      

      

      
        <div id="macros_details" class="details_list">
          <h2>Macros</h2>
          <div class="detail">
  <p class="signature" id="&lt;&lt;&gt;&gt;/1">
    <strong>&lt;&lt;&gt;&gt;/1</strong>
  </p>
  <div class="docstring"><p>Defines a new bitstring.</p>

<h2>Examples</h2>

<pre><code>:&lt;&lt;&gt;&gt;.(1,2,3)
&lt;&lt; 1, 2, 3 &gt;&gt;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L36" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="[]/1">
    <strong>[]/1</strong>
  </p>
  <div class="docstring"><p>Defines a new list.</p>

<h2>Examples</h2>

<pre><code>:[].(1,2,3)
[ 1, 2, 3 ]
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L26" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="__FILE__/0">
    <strong>__FILE__/0</strong>
  </p>
  <div class="docstring"><p>Returns the current file name as a binary.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L175" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="__FUNCTION__/0">
    <strong>__FUNCTION__/0</strong>
  </p>
  <div class="docstring"><p>Returns the current function as a tuple,
where the first element is the name as an atom
and the second is the arity as an integer.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L187" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="__LINE__/0">
    <strong>__LINE__/0</strong>
  </p>
  <div class="docstring"><p>Returns the current line number as an integer.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L180" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="__MODULE__/0">
    <strong>__MODULE__/0</strong>
  </p>
  <div class="docstring"><p>Returns the current module name as an atom or nil otherwise.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L170" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="bc/1">
    <strong>bc/1</strong>
  </p>
  <div class="docstring"><p>Defines a bit comprehension. It follows the same syntax as
a list comprehension but expects each element returned to
be a bitstring. For example, here is how to remove all
spaces from a string:</p>

<pre><code>bc &lt;&lt;c&gt;&gt; in &quot; hello world &quot; when c != ? , do: &lt;&lt;c&gt;&gt;
&quot;helloworld&quot;
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L462" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="fn/1">
    <strong>fn/1</strong>
  </p>
  <div class="docstring"><p>Returns an anonymous function based on the given arguments.</p>

<h2>Examples</h2>

<pre><code>sum = fn(x, y) -&gt; x + y end
sum.(1, 2) #=&gt; 3
</code></pre>

<p>Notice that a function needs to be invoked using the dot between
the function and the arguments.</p>

<p>A function could also be defined using the <code>end</code> syntax, although
it is recommend to use it only with the stab operator in order to
avoid ambiguity. For example, consider this case:</p>

<pre><code>Enum.map [1,2,3], fn x -&gt;
  x * 2
end
</code></pre>

<p>The example works fine because <code>-&gt;</code> binds to the closest function call,
which is <code>fn</code>, but if we replace it by <code>do/end</code>, it will fail:</p>

<pre><code>Enum.map [1,2,3], fn(x) do
  x * 2
end
</code></pre>

<p>The reason it fails is because do/end always bind to the farthest
function call.</p>

<h2>Function with multiple clauses</h2>

<p>One may define a function which expects different clauses as long
as all clauses expects the same number of arguments:</p>

<pre><code>fun = fn do
  x, y when y &lt; 0 -&gt;
    x - y
  x, y -&gt;
    x + y
end

fun.(10, -10) #=&gt; 20
fun.(10, 10)  #=&gt; 20
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L365" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="import/2">
    <strong>import/2</strong>
  </p>
  <div class="docstring"><p><code>import</code> allows one to easily access functions or macros from
others modules without using the qualified name.</p>

<h2>Examples</h2>

<p>If you want to use the <code>values</code> function from <code>Keyword</code> several times
in your module and you don&#39;t want to always type <code>Keyword.values</code>,
you can simply import it:</p>

<pre><code>defmodule Math do
  import Keyword, only: [values: 1]

  def some_function do
    # call values(orddict)
  end
end
</code></pre>

<p>In this case, we are importing only the function <code>values</code> (with arity 1)
from <code>Keyword</code>. Although <code>only</code> is optional, its usage is recommended.
<code>except</code> could also be given as an option. If no option is given, all
functions and macros are imported.</p>

<p>In case you want to import only functions or macros, you can pass a
first argument selecting the scope:</p>

<pre><code>import :macros, MyMacros
</code></pre>

<p>And you can then use <code>only</code> or <code>except</code> to filter the macros being
included.</p>

<h2>Lexical scope</h2>

<p>It is important to notice that <code>import</code> is lexical. This means you
can import specific macros inside specific functions:</p>

<pre><code>defmodule Math do
  def some_function do
    # 1) Disable `if/2` from Elixir.Builtin
    import Elixir.Builtin, except: [if: 2]

    # 2) Require the new `if` macro from MyMacros
    import MyMacros

    # 3) Use the new macro
    if do_something, it_works
  end
end
</code></pre>

<p>In the example above, we imported macros from <code>MyMacros</code>, replacing
the original <code>if/2</code> implementation by our own during that
specific function. All other functions in that module will still
be able to use the original one.</p>

<h2>Refer/Require shortcut</h2>

<p>All imported modules are also required by default. <code>import</code>
also accepts <code>as:</code> as an option so it automatically sets up
an alias. Please check <code>refer</code> for more information.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L165" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="in_guard/1">
    <strong>in_guard/1</strong>
  </p>
  <div class="docstring"><p>Keeps one of the given expressions depending in the context
of evaluation is a guard or not. This is useful when creating
macro that should work both inside and outside guards but
still hold some characteristics.</p>

<h2>Example</h2>

<p>A good example is the <code>is_exception/1</code> macro defined in Elixir:</p>

<pre><code> defmacro is_exception(thing) do
   quote do
     quote do
       is_tuple(unquote(thing)) and elem(unquote(thing), 2) == :__exception__
     else
       result = unquote(thing)
       is_tuple(result) and elem(result, 2) == :__exception__
     end
   end
 end
</code></pre>

<p>Notice that if inside a guard, we unquote the same element twice.
This will cause the same element to be evaluted twice, but this is
fine for guards since we cannot assign variables in guards and
we cannot call expressions inside guards. However, when outside
of a guard, evaluating the arguments twice can be harmful and
unexpected, for this reason, we save the result in a variable.</p>

<p>In the example above, <code>in_guard</code> is allowing us to customize
the same macro to work inside and outside guards.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L495" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="lc/1">
    <strong>lc/1</strong>
  </p>
  <div class="docstring"><p>List comprehensions allow you to quickly build a list from another list:</p>

<pre><code>lc n in [1,2,3,4], do: n * 2
#=&gt; [2,4,6,8]
</code></pre>

<p>A comprehension accepts many generators and also filters. Filters must be given after the when clause:</p>

<pre><code># A comprehension with a generator and a filter
lc n in [1,2,3,4,5,6] when rem(n, 2) == 0, do: n
#=&gt; [2,4,6]

# A comprehension with two generators
lc x in [1,2], y in [2,3], do: x*y
#=&gt; [2,3,4,6]
</code></pre>

<p>Elixir provides generators for both lists and bitstrings:</p>

<pre><code># A list generator:
lc n in [1,2,3,4], do: n * 2
#=&gt; [2,4,6,8]

# A bit string generator:
lc &lt;&lt;n&gt;&gt; in &lt;&lt;1,2,3,4&gt;&gt;, do: n * 2
#=&gt; [2,4,6,8]
</code></pre>

<p>Bit string generators are quite useful when you need to organize bit string streams:</p>

<pre><code>iex&gt; pixels = &lt;&lt;213,45,132,64,76,32,76,0,0,234,32,15&gt;&gt;
iex&gt; lc &lt;&lt;r:8,g:8,b:8&gt;&gt; in pixels, do: {r,g,b}
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
</code></pre>

<p>Elixir does its best to hide the differences between list and bit string generators.
However, there is a special case due to Erlang limitation where we need to explicitly
tell Erlang that a list is being given as argument:</p>

<pre><code># This will fail because when Elixir sees that the left side
# of the in expression is a bit string, it expects the right side
# to be a bit string as well:
lc &lt;&lt;n&gt;&gt; in [&lt;&lt;1&gt;&gt;,&lt;&lt;2&gt;&gt;,&lt;&lt;3&gt;&gt;], do: n*2
#=&gt; ** (ErlangError) erlang error {:bad_generator,[&lt;&lt;1&gt;&gt;,&lt;&lt;2&gt;&gt;,&lt;&lt;3&gt;&gt;]}

# You need to be explicit and use inlist:
lc inlist(&lt;&lt;n&gt;&gt;, [&lt;&lt;1&gt;&gt;,&lt;&lt;2&gt;&gt;,&lt;&lt;3&gt;&gt;]), do: n*2
#=&gt; [2,4,6]

# For consistency, inbin is also available:
lc inbin(&lt;&lt;n&gt;&gt;, &lt;&lt;1,2,3&gt;&gt;), do: n*2
#=&gt; [2,4,6]
</code></pre>

<p>Notice that although comprehensions uses <code>when</code> to specify filters, filters are not
guards and therefore accept any expression (they are not limited as guards).</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L450" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="loop/1">
    <strong>loop/1</strong>
  </p>
  <div class="docstring"><p>Handle annonymous recursive loops.</p>

<h2>Examples</h2>

<pre><code>list = [1,2,3]

loop list, [] do
  [h|t], acc -&gt;
    recur t, [h*2|acc]
  [], acc -&gt;
    acc
end
#=&gt; [6,4,2]
</code></pre>

<p>Notice that all match clauses expects the same ammount
of arguments. Guards can also be given.</p>

<p>Recursion happens by calling recur with the same number
of arguments of each match clause. <code>recur</code> does not guarantee
that it will be tail recursive.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L389" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="quote/2">
    <strong>quote/2</strong>
  </p>
  <div class="docstring"><p>Allows you to get the representation of any expression.</p>

<h2>Examples</h2>

<pre><code>quote do: sum(1, 2, 3)
#=&gt; { :sum, 0, [1, 2, 3] }
</code></pre>

<h2>Homoiconicity</h2>

<p>Elixir is an homoiconic language. Any Elixir program can be
represented using its own data structures. The building block
of Elixir homoiconicity is a tuple with three elements, for example:</p>

<pre><code>{ :sum, 1, [1, 2, 3] }
</code></pre>

<p>The tuple above represents a function call to sum passing 1, 2 and
3 as arguments. The tuple elements are:</p>

<ul>
<li>The first element of the tuple is always an atom or
another tuple in the same representation;</li>
<li>The second element of the tuple is always an integer
representing the line number;</li>
<li>The third element of the tuple are the arguments for the
function call. The third argument may be an atom, meaning
that it may be a variable.</li>
</ul>

<h2>Macro literals</h2>

<p>Besides the tuple described above, Elixir has a few literals that
when quoted return themselves. They are:</p>

<pre><code>:sum         #=&gt; Atoms
1            #=&gt; Integers
2.0          #=&gt; Floats
[1,2]        #=&gt; Lists
&quot;binaries&quot;   #=&gt; Binaries
{key, value} #=&gt; Tuple with two elements
</code></pre>

<h2>Hygiene</h2>

<p>Elixir macros are hygienic regarding to variables. This means
a variable defined in a macro cannot affect the scope where
the macro is included. Consider the following example:</p>

<pre><code>defmodule Hygiene do
  defmacro no_interference do
    quote do: a = 1
  end
end

require Hygiene

a = 10
Hygiene.no_interference
a #=&gt; 10
</code></pre>

<p>In the example above, <code>a</code> returns 10 even if the macro
is apparently setting it to 1 because the variables defined
in the macro does not affect the context the macro is
executed. If you want to set or get a variable, you can do
it with the help of the <code>var!</code> macro:</p>

<pre><code>defmodule NoHygiene do
  defmacro interference do
    quote do: var!(a) = 1
  end
end

require NoHygiene

a = 10
NoHygiene.interference
a #=&gt; 11
</code></pre>

<p>Notice that references are not hygienic in Elixir unless
you explicitly access it via <strong>MAIN</strong> to the reference name.</p>

<pre><code>quote do
  __MAIN__.Foo #=&gt; Access the root Foo
  Foo   #=&gt; Access the Foo reference in the current
             module (if any is set), then fallback to root
end
</code></pre>

<h2>Options</h2>

<p><code>quote</code> also accepts some options as arguments. For example,
hygiene can be turned off via <code>hygiene: false</code> which is useful
when one is generating a code that should be inserted into
some function.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L280" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="recur/1">
    <strong>recur/1</strong>
  </p>
  <div class="docstring"><p>A function that forces the current loop to recur. See <code>loop/1</code>
for more information.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L395" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="refer/2">
    <strong>refer/2</strong>
  </p>
  <div class="docstring"><p><code>refer</code> is used to setup aliases between modules.</p>

<h2>Examples</h2>

<p><code>refer</code> can be used to setup an alias for any module:</p>

<pre><code>defmodule Math do
  refer MyKeyword, as: Keyword
end
</code></pre>

<p>In the example above, we have set up <code>MyOrdict</code> to be referenced
as <code>Keyword</code>. So now, any reference to <code>Keyword</code> will be
automatically replaced by <code>MyKeyword</code>.</p>

<p>In case one wants to access the original <code>Keyword</code>, it can be done
by accessing <strong>MAIN</strong>:</p>

<pre><code>Keyword.values   #=&gt; uses MyKeyword.values
__MAIN__.Keyword.values #=&gt; uses Keyword.values
</code></pre>

<p>Notice that calling <code>refer</code> without the <code>as:</code> option automatically
sets an alias based on the last part of the module. For example:</p>

<pre><code>refer Foo.Bar.Baz
</code></pre>

<p>Is the same as:</p>

<pre><code>refer Foo.Bar.Baz, as: Baz
</code></pre>

<h2>Lexical scope</h2>

<p><code>import</code>, <code>require</code> and <code>refer</code> are called directives and all
have lexical scope. This means you can set up aliases inside
specific functions and it won&#39;t affect the overall scope.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L74" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="require/2">
    <strong>require/2</strong>
  </p>
  <div class="docstring"><p><code>require</code> is used to require the presence of external
modules so macros can be invoked.</p>

<h2>Examples</h2>

<p>Notice that usually modules should not be required before usage,
the only exception is if you want to use the macros from a module.
In such cases, you need to explicitly require them.</p>

<p>Let&#39;s suppose you created your own <code>if</code> implementation in the module
<code>MyMacros</code>. If you want to invoke it, you need to first explicitly
require the <code>MyMacros</code>:</p>

<pre><code>defmodule Math do
  require MyMacros
  MyMacros.if do_something, it_works
end
</code></pre>

<p>An attempt to call a macro that was not loaded will raise an error.</p>

<h2>Refer shortcut</h2>

<p><code>require</code> also accepts <code>as:</code> as an option so it automatically sets
up an alias. Please check <code>refer</code> for more information.</p>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L103" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="unquote/1">
    <strong>unquote/1</strong>
  </p>
  <div class="docstring"><p>Unquotes the given expression from inside a macro.</p>

<h2>Examples</h2>

<p>Imagine the situation you have a variable <code>name</code> and
you want to inject it inside some quote. The first attempt
would be:</p>

<pre><code>value = 13
quote do: sum(1, value, 3)
</code></pre>

<p>Which would then return:</p>

<pre><code>{ :sum, 0, [1, { :value, 0, quoted }, 3] }
</code></pre>

<p>Which is not the expected result. For this, we use unquote:</p>

<pre><code>value = 13
quote do: sum(1, unquote(value), 3)
#=&gt; { :sum, 0, [1, 13, 3] }
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L305" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="unquote_splicing/1">
    <strong>unquote_splicing/1</strong>
  </p>
  <div class="docstring"><p>Unquotes the given list expanding its arguments. Similar
to unquote.</p>

<h2>Examples</h2>

<pre><code>values = [2,3,4]
quote do: sum(1, unquote_splicing(values), 5)
#=&gt; { :sum, 0, [1, 2, 3, 4, 5] }
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L318" target="_blank" class="view_source">Source</a>
</div><div class="detail">
  <p class="signature" id="{}/1">
    <strong>{}/1</strong>
  </p>
  <div class="docstring"><p>Defines a new tuple.</p>

<h2>Examples</h2>

<pre><code>:{}.(1,2,3)
{ 1, 2, 3 }
</code></pre>
</div>
  <a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/special_forms.ex#L16" target="_blank" class="view_source">Source</a>
</div>
        </div>
      
    </div>
  </body>
</html>
